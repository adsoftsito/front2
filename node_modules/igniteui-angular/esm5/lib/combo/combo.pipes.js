/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { forwardRef, Inject, Pipe } from '@angular/core';
import { cloneArray } from '../core/utils';
import { DataUtil } from '../data-operations/data-util';
import { IgxComboComponent } from './combo.component';
import { FilteringStrategy } from '../data-operations/filtering-strategy';
import { FilteringExpressionsTree } from '../data-operations/filtering-expressions-tree';
/**
 * @hidden
 */
var IgxComboFilteringPipe = /** @class */ (function () {
    function IgxComboFilteringPipe(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} logic
     * @return {?}
     */
    IgxComboFilteringPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} logic
     * @return {?}
     */
    function (collection, expressions, logic) {
        var /** @type {?} */ filteringExpressionsTree = new FilteringExpressionsTree(logic);
        filteringExpressionsTree.filteringOperands = expressions;
        var /** @type {?} */ state = { expressionsTree: filteringExpressionsTree, strategy: new SimpleFilteringStrategy() };
        state.expressionsTree.filteringOperands = this.combo.filteringExpressions;
        if (!state.expressionsTree.filteringOperands.length) {
            return collection;
        }
        var /** @type {?} */ result = DataUtil.filter(cloneArray(collection), state);
        return result;
    };
    IgxComboFilteringPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboFiltering'
                },] },
    ];
    /** @nocollapse */
    IgxComboFilteringPipe.ctorParameters = function () { return [
        { type: IgxComboComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return IgxComboComponent; }),] },] },
    ]; };
    return IgxComboFilteringPipe;
}());
export { IgxComboFilteringPipe };
function IgxComboFilteringPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxComboFilteringPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxComboFilteringPipe.ctorParameters;
    /** @type {?} */
    IgxComboFilteringPipe.prototype.combo;
}
/**
 * @hidden
 */
var /**
 * @hidden
 */
SimpleFilteringStrategy = /** @class */ (function (_super) {
    tslib_1.__extends(SimpleFilteringStrategy, _super);
    function SimpleFilteringStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    SimpleFilteringStrategy.prototype.findMatchByExpression = /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    function (rec, expr) {
        var /** @type {?} */ cond = expr.condition;
        var /** @type {?} */ val = expr.fieldName === undefined ? rec : rec[expr.fieldName];
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    };
    return SimpleFilteringStrategy;
}(FilteringStrategy));
/**
 * @hidden
 */
export { SimpleFilteringStrategy };
/**
 * @hidden
 */
var IgxComboSortingPipe = /** @class */ (function () {
    function IgxComboSortingPipe(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @return {?}
     */
    IgxComboSortingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expression
     * @return {?}
     */
    function (collection, expression) {
        var /** @type {?} */ state = { expressions: [] };
        state.expressions = this.combo.sortingExpressions;
        if (!state.expressions.length) {
            return collection;
        }
        var /** @type {?} */ result = DataUtil.sort(cloneArray(collection), state);
        return result;
    };
    IgxComboSortingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboSorting',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxComboSortingPipe.ctorParameters = function () { return [
        { type: IgxComboComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return IgxComboComponent; }),] },] },
    ]; };
    return IgxComboSortingPipe;
}());
export { IgxComboSortingPipe };
function IgxComboSortingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxComboSortingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxComboSortingPipe.ctorParameters;
    /** @type {?} */
    IgxComboSortingPipe.prototype.combo;
}
/**
 * @hidden
 */
var IgxComboGroupingPipe = /** @class */ (function () {
    function IgxComboGroupingPipe(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} groupKey
     * @return {?}
     */
    IgxComboGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} groupKey
     * @return {?}
     */
    function (collection, groupKey) {
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        var /** @type {?} */ data = cloneArray(collection);
        var /** @type {?} */ inserts = 0;
        var /** @type {?} */ currentHeader = null;
        for (var /** @type {?} */ i = 0; i < collection.length; i++) {
            var /** @type {?} */ insertFlag = 0;
            if (currentHeader !== collection[i][groupKey]) {
                currentHeader = collection[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, (_a = {},
                    _a[this.combo.valueKey] = currentHeader,
                    _a[this.combo.groupKey] = currentHeader,
                    _a.isHeader = true,
                    _a));
                inserts++;
            }
        }
        return data;
        var _a;
    };
    IgxComboGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboGrouping'
                },] },
    ];
    /** @nocollapse */
    IgxComboGroupingPipe.ctorParameters = function () { return [
        { type: IgxComboComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return IgxComboComponent; }),] },] },
    ]; };
    return IgxComboGroupingPipe;
}());
export { IgxComboGroupingPipe };
function IgxComboGroupingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxComboGroupingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxComboGroupingPipe.ctorParameters;
    /** @type {?} */
    IgxComboGroupingPipe.prototype.combo;
}
/**
 * @hidden
 */
var IgxComboFilterConditionPipe = /** @class */ (function () {
    function IgxComboFilterConditionPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxComboFilterConditionPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.split(/(?=[A-Z])/).join(' ');
    };
    IgxComboFilterConditionPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'filterCondition',
                    pure: true
                },] },
    ];
    return IgxComboFilterConditionPipe;
}());
export { IgxComboFilterConditionPipe };
function IgxComboFilterConditionPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxComboFilterConditionPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxComboFilterConditionPipe.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tYm8ucGlwZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvbWJvL2NvbWJvLnBpcGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUd4RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUV0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQzs7Ozs7SUFXckYsK0JBRVc7UUFBQSxVQUFLLEdBQUwsS0FBSztLQUNYOzs7Ozs7O0lBRUUseUNBQVM7Ozs7OztjQUFDLFVBQWlCLEVBQUUsV0FBbUMsRUFDdEQsS0FBcUI7UUFDbEMscUJBQU0sd0JBQXdCLEdBQUksSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RSx3QkFBd0IsQ0FBQyxpQkFBaUIsR0FBRyxXQUFXLENBQUM7UUFDekQscUJBQU0sS0FBSyxHQUFvQixFQUFFLGVBQWUsRUFBRSx3QkFBd0IsRUFBRSxRQUFRLEVBQUUsSUFBSSx1QkFBdUIsRUFBRSxFQUFDLENBQUM7UUFDckgsS0FBSyxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDO1FBRTFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQyxVQUFVLENBQUM7U0FDckI7UUFFRCxxQkFBTSxNQUFNLEdB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RyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3hDLFVBQVUsR0FBRyxDQUFDLENBQUM7YUFDbEI7WUFDRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUNiLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sRUFBRSxDQUFDO29CQUN0QixHQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFHLGFBQWE7b0JBQ3BDLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUcsYUFBYTtvQkFDcEMsV0FBUSxHQUFFLElBQUk7d0JBQ2hCLENBQUM7Z0JBQ0gsT0FBTyxFQUFFLENBQUM7YUFDYjtTQUNKO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQzs7OztnQkFqQ25CLElBQUksU0FBQztvQkFDRixJQUFJLEVBQUUsZUFBZTtpQkFDeEI7Ozs7Z0JBMUVRLGlCQUFpQix1QkE4RWpCLE1BQU0sU0FBQyxVQUFVLENBQUMsY0FBTSxPQUFBLGlCQUFpQixFQUFqQixDQUFpQixDQUFDOzsrQkFuRm5EOztTQWdGYSxvQkFBb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0Q3RCLCtDQUFTOzs7O2NBQUMsS0FBYTtRQUMxQixNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7OztnQkFSakQsSUFBSSxTQUFDO29CQUNGLElBQUksRUFBRSxpQkFBaUI7b0JBQ3ZCLElBQUksRUFBRSxJQUFJO2lCQUNiOztzQ0F4SEQ7O1NBMEhhLDJCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcndhcmRSZWYsIEluamVjdCwgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY2xvbmVBcnJheSB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRGF0YVV0aWwgfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IEZpbHRlcmluZ0xvZ2ljLCBJRmlsdGVyaW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4Q29tYm9Db21wb25lbnQgfSBmcm9tICcuL2NvbWJvLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJRmlsdGVyaW5nU3RhdGUgfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdjb21ib0ZpbHRlcmluZydcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q29tYm9GaWx0ZXJpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IElneENvbWJvQ29tcG9uZW50KSlcbiAgICAgICAgcHVibGljIGNvbWJvOiBJZ3hDb21ib0NvbXBvbmVudFxuICAgICkgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IGFueVtdLCBleHByZXNzaW9uczogSUZpbHRlcmluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgICAgICAgICAgICAgIGxvZ2ljOiBGaWx0ZXJpbmdMb2dpYykge1xuICAgICAgICBjb25zdCBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgPSAgbmV3IEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZShsb2dpYyk7XG4gICAgICAgIGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5maWx0ZXJpbmdPcGVyYW5kcyA9IGV4cHJlc3Npb25zO1xuICAgICAgICBjb25zdCBzdGF0ZTogSUZpbHRlcmluZ1N0YXRlID0geyBleHByZXNzaW9uc1RyZWU6IGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSwgc3RyYXRlZ3k6IG5ldyBTaW1wbGVGaWx0ZXJpbmdTdHJhdGVneSgpfTtcbiAgICAgICAgc3RhdGUuZXhwcmVzc2lvbnNUcmVlLmZpbHRlcmluZ09wZXJhbmRzID0gdGhpcy5jb21iby5maWx0ZXJpbmdFeHByZXNzaW9ucztcblxuICAgICAgICBpZiAoIXN0YXRlLmV4cHJlc3Npb25zVHJlZS5maWx0ZXJpbmdPcGVyYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRGF0YVV0aWwuZmlsdGVyKGNsb25lQXJyYXkoY29sbGVjdGlvbiksIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgY2xhc3MgU2ltcGxlRmlsdGVyaW5nU3RyYXRlZ3kgZXh0ZW5kcyBGaWx0ZXJpbmdTdHJhdGVneSB7XG4gICAgcHVibGljIGZpbmRNYXRjaEJ5RXhwcmVzc2lvbihyZWM6IG9iamVjdCwgZXhwcjogSUZpbHRlcmluZ0V4cHJlc3Npb24pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgY29uZCA9IGV4cHIuY29uZGl0aW9uO1xuICAgICAgICBjb25zdCB2YWwgPSBleHByLmZpZWxkTmFtZSA9PT0gdW5kZWZpbmVkID8gcmVjIDogcmVjW2V4cHIuZmllbGROYW1lXTtcbiAgICAgICAgcmV0dXJuIGNvbmQubG9naWModmFsLCBleHByLnNlYXJjaFZhbCwgZXhwci5pZ25vcmVDYXNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2NvbWJvU29ydGluZycsXG4gICAgcHVyZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hDb21ib1NvcnRpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBJZ3hDb21ib0NvbXBvbmVudCkpXG4gICAgICAgIHB1YmxpYyBjb21ibzogSWd4Q29tYm9Db21wb25lbnRcbiAgICApIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgZXhwcmVzc2lvbjogSVNvcnRpbmdFeHByZXNzaW9uIHwgSVNvcnRpbmdFeHByZXNzaW9uW10pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGV4cHJlc3Npb25zOiBbXSB9O1xuICAgICAgICBzdGF0ZS5leHByZXNzaW9ucyA9IHRoaXMuY29tYm8uc29ydGluZ0V4cHJlc3Npb25zO1xuXG4gICAgICAgIGlmICghc3RhdGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBEYXRhVXRpbC5zb3J0KGNsb25lQXJyYXkoY29sbGVjdGlvbiksIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2NvbWJvR3JvdXBpbmcnXG59KVxuZXhwb3J0IGNsYXNzIElneENvbWJvR3JvdXBpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IElneENvbWJvQ29tcG9uZW50KSlcbiAgICAgICAgcHVibGljIGNvbWJvOiBJZ3hDb21ib0NvbXBvbmVudFxuICAgICkgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IGFueVtdLCBncm91cEtleTogYW55KSB7XG4gICAgICAgIHRoaXMuY29tYm8uZmlsdGVyZWREYXRhID0gY29sbGVjdGlvbjtcbiAgICAgICAgaWYgKCghZ3JvdXBLZXkgJiYgZ3JvdXBLZXkgIT09IDApIHx8ICFjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGNsb25lQXJyYXkoY29sbGVjdGlvbik7XG4gICAgICAgIGxldCBpbnNlcnRzID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRIZWFkZXIgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbnNlcnRGbGFnID0gMDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SGVhZGVyICE9PSBjb2xsZWN0aW9uW2ldW2dyb3VwS2V5XSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWFkZXIgPSBjb2xsZWN0aW9uW2ldW2dyb3VwS2V5XTtcbiAgICAgICAgICAgICAgICBpbnNlcnRGbGFnID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnNlcnRGbGFnKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zcGxpY2UoaSArIGluc2VydHMsIDAsIHtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuY29tYm8udmFsdWVLZXldOiBjdXJyZW50SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5jb21iby5ncm91cEtleV06IGN1cnJlbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlzSGVhZGVyOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZmlsdGVyQ29uZGl0aW9uJyxcbiAgICBwdXJlOiB0cnVlXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4Q29tYm9GaWx0ZXJDb25kaXRpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oJyAnKTtcbiAgICB9XG59XG4iXX0=