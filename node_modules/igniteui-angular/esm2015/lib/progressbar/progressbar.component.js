/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, ContentChild } from '@angular/core';
import { IgxProcessBarTextTemplateDirective } from './progressbar.common';
const /** @type {?} */ ONE_PERCENT = 0.01;
const /** @type {?} */ MIN_VALUE = 0;
/** @enum {string} */
const IgxTextAlign = {
    START: 'start',
    CENTER: 'center',
    END: 'end',
};
export { IgxTextAlign };
/**
 * @record
 */
export function IChangeProgressEventArgs() { }
function IChangeProgressEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IChangeProgressEventArgs.prototype.previousValue;
    /** @type {?} */
    IChangeProgressEventArgs.prototype.currentValue;
}
/**
 * @abstract
 */
export class BaseProgress {
    constructor() {
        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */
        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */
        this._max = 100;
        /**
         * @hidden
         */
        this._value = MIN_VALUE;
        /**
         * @hidden
         */
        this._animate = true;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *    let percentValue = this.progressBar.valueInPercent;
     *    alert(percentValue);
     * }
     * ```
     * @return {?}
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *    public setValue(event){
     *    this.progressBar.valueInPercent = 56;
     * }
     * //...
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
     * ```
     * @param {?} value
     * @return {?}
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        this._value += step;
        const /** @type {?} */ passedValue = convertInPercentage(val, this._max);
        const /** @type {?} */ progressValue = convertInPercentage(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
    /**
     * @hidden
     * @param {?} currentValue
     * @param {?} prevValue
     * @param {?} step
     * @return {?}
     */
    directionFlow(currentValue, prevValue, step) {
        if (currentValue < prevValue) {
            return step;
        }
        return -step;
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    updateProgress(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
}
function BaseProgress_tsickle_Closure_declarations() {
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype.requestAnimationId;
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype._valueInPercent;
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype._max;
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype._value;
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype._animate;
    /**
     * @hidden
     * @type {?}
     */
    BaseProgress.prototype._step;
}
let /** @type {?} */ NEXT_LINEAR_ID = 0;
let /** @type {?} */ NEXT_CIRCULAR_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgress {
    constructor() {
        super();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    /**
     * Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val) {
            return;
        }
        const /** @type {?} */ valueInRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInRange)) {
            return;
        }
        const /** @type {?} */ changedValues = {
            currentValue: valueInRange,
            previousValue: this._value
        };
        const /** @type {?} */ updateValue = super.directionFlow(this._value, val, this.step);
        if (this._animate && val >= this.step) {
            super.runAnimation(valueInRange, updateValue);
        }
        else {
            super.updateProgressDirectly(valueInRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
}
IgxLinearProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-linear-bar',
                template: `<div class="progress-linear" [class.progress-linear--striped]="striped">
    <div class="progress-linear__bar" #linearBar role="progressbar" aria-valuemin="0" [attr.aria-valuemax]="max" [attr.aria-valuenow]="value">
        <div class="progress-linear__bar-base"></div>
        <div class="progress-linear__bar-progress{{type ? '--' + type : ''}}" [style.width.%]="valueInPercent"></div>
    </div>
    <span 
        class="progress-linear__value{{textAlign ? '--' + textAlign : ''}}"
        [class.progress-linear__value--top]="textTop"
        [class.progress-linear__value--hidden]="!textVisibility">
            {{text ? text : valueInPercent + '%'}}
    </span>
</div>
`
            },] },
];
/** @nocollapse */
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
    "textAlign": [{ type: Input },],
    "textVisibility": [{ type: Input },],
    "textTop": [{ type: Input },],
    "text": [{ type: Input },],
    "striped": [{ type: Input },],
    "type": [{ type: Input },],
    "animate": [{ type: Input },],
    "max": [{ type: Input },],
    "step": [{ type: Input },],
    "value": [{ type: Input },],
    "onProgressChanged": [{ type: Output },],
};
function IgxLinearProgressBarComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxLinearProgressBarComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxLinearProgressBarComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxLinearProgressBarComponent.propDecorators;
    /**
     * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.id;
    /**
     * Set the position that defines where the text is aligned.
     * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
     * ```typescript
     * public positionCenter: IgxTextAlign;
     * public ngOnInit() {
     *    this.positionCenter = IgxTextAlign.CENTER;
     * }
     * //...
     * ```
     * ```html
     * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textAlign;
    /**
     * Set the text to be visible. By default it is set to true.
     * ```html
     * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textVisibility;
    /**
     * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
     * ```html
     * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textTop;
    /**
     * Set a custom text that is displayed according to the defined position.
     * ```html
     * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.text;
    /**
     * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
     * ```html
     * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.striped;
    /**
     * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.type;
    /**
     * An event, which is triggered after a progress is changed.
     * ```typescript
     * public progressChange(event) {
     *    alert("Progress made!");
     * }
     * //...
     * ```
     * ```html
     * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.onProgressChanged;
}
export class IgxCircularProgressBarComponent extends BaseProgress {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     * @return {?}
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * ```html
     * <igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val) {
            return;
        }
        const /** @type {?} */ valueInProperRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInProperRange)) {
            return;
        }
        const /** @type {?} */ changedValues = {
            currentValue: valueInProperRange,
            previousValue: this._value
        };
        const /** @type {?} */ updateValue = super.directionFlow(this._value, val, this.step);
        if (this.animate && val >= this.step) {
            super.runAnimation(valueInProperRange, updateValue);
        }
        else {
            this.updateProgressDirectly(valueInProperRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        const /** @type {?} */ FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     * @return {?}
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    /**
     * @param {?} percentage
     * @return {?}
     */
    getProgress(percentage) {
        return this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-circular-bar',
                template: `<svg #svg class="progress-circular" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"
    viewBox="0 0 100 100" preserveAspectRatio="none" role="progressbar" aria-valuemin="0" [attr.aria-valuemax]="max" [attr.aria-valuenow]="value">
    <circle class="progress-circular__innercircle" cx="50" cy="50" r="46" />
    <circle #circle class="progress-circular__circle" cx="50" cy="50" r="46" />
    <text #text [class.progress-circular__text--hidden]="!textVisibility" id="myTimer" text-anchor="middle" x="50" y="60">
            <ng-container *ngTemplateOutlet="textTemplate ? textTemplate.template : defaultTextTemplate; context: context">
            </ng-container>
    </text>

    <ng-template #defaultTextTemplate>
        <tspan class="progress-circular__text"> {{textContent ? textContent: valueInPercent + '%'}}</tspan>
    </ng-template>
</svg>`
            },] },
];
/** @nocollapse */
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2, },
];
IgxCircularProgressBarComponent.propDecorators = {
    "onProgressChanged": [{ type: Output },],
    "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
    "textVisibility": [{ type: Input },],
    "text": [{ type: Input },],
    "textTemplate": [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] },],
    "animate": [{ type: Input },],
    "max": [{ type: Input },],
    "step": [{ type: Input },],
    "value": [{ type: Input },],
    "_svgCircle": [{ type: ViewChild, args: ['circle',] },],
};
function IgxCircularProgressBarComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxCircularProgressBarComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxCircularProgressBarComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxCircularProgressBarComponent.propDecorators;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype.STROKE_OPACITY_DVIDER;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype.STROKE_OPACITY_ADDITION;
    /**
     * An event, which is triggered after a progress is changed.
     * ```typescript
     * public progressChange(event) {
     *    alert("Progress made!");
     * }
     * //...
     * ```
     * ```html
     * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.onProgressChanged;
    /**
     * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.id;
    /**
     * Sets the text visibility. By default it is set to true.
     * ```html
     * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.textVisibility;
    /**
     * Sets/gets the text to be displayed inside the `igxCircularBar`.
     * ```html
     * <igx-circular-bar text="Progress"></igx-circular-bar>
     * ```
     * ```typescript
     * let text = this.circularBar.text;
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.text;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype.textTemplate;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype._circleRadius;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype._circumference;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype._svgCircle;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype.renderer;
}
/**
 * @param {?} value
 * @param {?} max
 * @param {?=} min
 * @return {?}
 */
export function getValueInProperRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
/**
 * @param {?} value
 * @param {?} max
 * @return {?}
 */
export function convertInPercentage(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * The IgxProgressBarModule provides the {\@link IgxLinearProgressBarComponent},
 * {\@link IgxCircularProgressBarComponent} inside your application.
 */
export class IgxProgressBarModule {
}
IgxProgressBarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                imports: [CommonModule]
            },] },
];
function IgxProgressBarModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxProgressBarModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxProgressBarModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBRUgsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBRVIsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBRVQsWUFBWSxFQUNmLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQ0FBa0MsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTFFLHVCQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsdUJBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQzs7O1dBR1IsT0FBTztZQUNOLFFBQVE7U0FDWCxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7O0FBUWYsTUFBTTs7Ozs7a0NBSW1DLFNBQVM7Ozs7K0JBS2xCLFNBQVM7Ozs7b0JBSXBCLEdBQUc7Ozs7c0JBSUQsU0FBUzs7Ozt3QkFJUCxJQUFJOzs7Ozs7Ozs7Ozs7OztRQWtCZCxjQUFjO1FBQ3JCLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFpQnJCLGNBQWMsQ0FBQyxLQUFhO1FBQ25DLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDOzs7Ozs7OztJQU12QixZQUFZLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDNUMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLHFCQUFxQixDQUMzQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUNoRTs7Ozs7OztJQUtTLHNC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QUErQixFQUFFLGtDQUFrQyxDQUFDO2dCQUM3RyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7YUFDMUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPbkNoYW5nZXMsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgQ29udGVudENoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vcHJvZ3Jlc3NiYXIuY29tbW9uJztcblxuY29uc3QgT05FX1BFUkNFTlQgPSAwLjAxO1xuY29uc3QgTUlOX1ZBTFVFID0gMDtcblxuZXhwb3J0IGVudW0gSWd4VGV4dEFsaWduIHtcbiAgICBTVEFSVCA9ICdzdGFydCcsXG4gICAgQ0VOVEVSID0gJ2NlbnRlcicsXG4gICAgRU5EID0gJ2VuZCdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IG51bWJlcjtcbiAgICBjdXJyZW50VmFsdWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgcmVxdWVzdEFuaW1hdGlvbklkOiBudW1iZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWx1ZUluUGVyY2VudCA9IE1JTl9WQUxVRTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tYXggPSAxMDA7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYW5pbWF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdGVwO1xuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgL2BJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCB2YWx1ZSBpbiBwZXJjZW50YWdlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7IC8vIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRcbiAgICAgKnB1YmxpYyB2YWx1ZVBlcmNlbnQoZXZlbnQpe1xuICAgICAqICAgIGxldCBwZXJjZW50VmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50O1xuICAgICAqICAgIGFsZXJ0KHBlcmNlbnRWYWx1ZSk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZhbHVlSW5QZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUluUGVyY2VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqICAgIHB1YmxpYyBzZXRWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudCA9IDU2O1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cInNldFZhbHVlKClcIj5zZXRWYWx1ZTwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB2YWx1ZUluUGVyY2VudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlSW5QZXJjZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBydW5BbmltYXRpb24odmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgICAgICgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlICs9IHN0ZXA7XG4gICAgICAgIGNvbnN0IHBhc3NlZFZhbHVlID0gY29udmVydEluUGVyY2VudGFnZSh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzVmFsdWUgPSBjb252ZXJ0SW5QZXJjZW50YWdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluUGVyY2VudCA9PT0gcGFzc2VkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3ModmFsKTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbklkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSW5MaW1pdFJhbmdlKHByb2dyZXNzVmFsdWUsIHBhc3NlZFZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3ModmFsKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RBbmltYXRpb25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gcHJvZ3Jlc3NWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gY29udmVydEluUGVyY2VudGFnZSh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgcHJldlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtc3RlcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0luTGltaXRSYW5nZSh2YWw6IG51bWJlciwgY29tcGFyYXRvcjogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFeGNlZWRpbmdVcHBlckxpbWl0KHZhbCwgY29tcGFyYXRvciwgc3RlcCkgfHwgdGhpcy5pc0V4Y2VlZGluZ0xvd2VyTGltaXQodmFsLCBjb21wYXJhdG9yLCBzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ1VwcGVyTGltaXQodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBjb21wYXJhdG9yICYmIHN0ZXAgPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ0xvd2VyTGltaXQodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB2YWwgPCBjb21wYXJhdG9yICYmIHN0ZXAgPCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3ModmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgIHRoaXMudmFsdWVJblBlcmNlbnQgPSBjb252ZXJ0SW5QZXJjZW50YWdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpO1xuICAgIH1cbn1cbmxldCBORVhUX0xJTkVBUl9JRCA9IDA7XG5sZXQgTkVYVF9DSVJDVUxBUl9JRCA9IDA7XG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1saW5lYXItYmFyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1saW5lYXJcIiBbY2xhc3MucHJvZ3Jlc3MtbGluZWFyLS1zdHJpcGVkXT1cInN0cmlwZWRcIj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtbGluZWFyX19iYXJcIiAjbGluZWFyQmFyIHJvbGU9XCJwcm9ncmVzc2JhclwiIGFyaWEtdmFsdWVtaW49XCIwXCIgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIiBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1saW5lYXJfX2Jhci1iYXNlXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1saW5lYXJfX2Jhci1wcm9ncmVzc3t7dHlwZSA/ICctLScgKyB0eXBlIDogJyd9fVwiIFtzdHlsZS53aWR0aC4lXT1cInZhbHVlSW5QZXJjZW50XCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPHNwYW4gXG4gICAgICAgIGNsYXNzPVwicHJvZ3Jlc3MtbGluZWFyX192YWx1ZXt7dGV4dEFsaWduID8gJy0tJyArIHRleHRBbGlnbiA6ICcnfX1cIlxuICAgICAgICBbY2xhc3MucHJvZ3Jlc3MtbGluZWFyX192YWx1ZS0tdG9wXT1cInRleHRUb3BcIlxuICAgICAgICBbY2xhc3MucHJvZ3Jlc3MtbGluZWFyX192YWx1ZS0taGlkZGVuXT1cIiF0ZXh0VmlzaWJpbGl0eVwiPlxuICAgICAgICAgICAge3t0ZXh0ID8gdGV4dCA6IHZhbHVlSW5QZXJjZW50ICsgJyUnfX1cbiAgICA8L3NwYW4+XG48L2Rpdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3Mge1xuXG4gICAgLyoqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbaWRdPVwiJ2lneC1saW5lYXItYmFyLTU1J1wiIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtbGluZWFyLWJhci0ke05FWFRfTElORUFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgUG9zc2libGUgb3B0aW9ucyAtIGBJZ3hUZXh0QWxpZ24uU1RBUlRgIChkZWZhdWx0KSwgYElneFRleHRBbGlnbi5DRU5URVJgLCBgSWd4VGV4dEFsaWduLkVORGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcG9zaXRpb25DZW50ZXI6IElneFRleHRBbGlnbjtcbiAgICAgKnB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgKiAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRBbGlnbjogSWd4VGV4dEFsaWduID0gSWd4VGV4dEFsaWduLlNUQVJUO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdGhlIHRleHQgdG8gYmUgdmlzaWJsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRlZmF1bHRcIiBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdGhlIHBvc2l0aW9uIHRoYXQgZGVmaW5lcyBpZiB0aGUgdGV4dCBzaG91bGQgYmUgYWxpZ25lZCBhYm92ZSB0aGUgcHJvZ3Jlc3MgbGluZS4gQnkgZGVmYXVsdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRhbmdlclwiIFt0ZXh0VG9wXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFRvcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpTZXQgYSBjdXN0b20gdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqU2V0IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdG8gaGF2ZSBzdHJpcGVkIHN0eWxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3RyaXBlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdHlwZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gUG9zc2libGUgb3B0aW9ucyAtIGBkZWZhdWx0YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYW5kIGBkYW5nZXJgLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJkYW5nZXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZSA9ICdkZWZhdWx0JztcblxuICAgIC8qKlxuICAgICAqQW5pbWF0aW9uIG9uIHByb2dyZXNzIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW2FuaW1hdGVdPVwiZmFsc2VcIiBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgYW5pbWF0ZShhbmltYXRlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBhbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB3aGV0aGVyIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIGhhcyBhbmltYXRpb24gdHJ1ZS9mYWxzZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGFuaW1hdGlvblN0YXR1cyhldmVudCkge1xuICAgICAqICAgIGxldCBhbmltYXRpb25TdGF0dXMgPSB0aGlzLnByb2dyZXNzQmFyLmFuaW1hdGU7XG4gICAgICogICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBhbmltYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldCBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZC4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gMTAwLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4TnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdGhlIG1heGltdW0gcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBtYXhWYWx1ZShldmVudCkge1xuICAgICAqICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICBhbGVydChtYXgpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHZhbHVlIHdoaWNoIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9zdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICAqICAgIGFsZXJ0KHZhbHVlKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5SYW5nZSA9IGdldFZhbHVlSW5Qcm9wZXJSYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlSW5SYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VkVmFsdWVzID0ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlOiB2YWx1ZUluUmFuZ2UsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiB0aGlzLl92YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gc3VwZXIuZGlyZWN0aW9uRmxvdyh0aGlzLl92YWx1ZSwgdmFsLCB0aGlzLnN0ZXApO1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSAmJiB2YWwgPj0gdGhpcy5zdGVwKSB7XG4gICAgICAgICAgICBzdXBlci5ydW5BbmltYXRpb24odmFsdWVJblJhbmdlLCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbHVlSW5SYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpBbiBldmVudCwgd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIGEgcHJvZ3Jlc3MgaXMgY2hhbmdlZC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0NoYW5nZShldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiUHJvZ3Jlc3MgbWFkZSFcIik7XG4gICAgICp9XG4gICAgICogLy8uLi5cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIChvblByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCIgdHlwZT1cInN1Y2Nlc3NcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb25Qcm9ncmVzc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtY2lyY3VsYXItYmFyJyxcbiAgICB0ZW1wbGF0ZTogYDxzdmcgI3N2ZyBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHZlcnNpb249XCIxLjFcIlxuICAgIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgcm9sZT1cInByb2dyZXNzYmFyXCIgYXJpYS12YWx1ZW1pbj1cIjBcIiBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWVcIj5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX2lubmVyY2lyY2xlXCIgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDZcIiAvPlxuICAgIDxjaXJjbGUgI2NpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19jaXJjbGVcIiBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0NlwiIC8+XG4gICAgPHRleHQgI3RleHQgW2NsYXNzLnByb2dyZXNzLWNpcmN1bGFyX190ZXh0LS1oaWRkZW5dPVwiIXRleHRWaXNpYmlsaXR5XCIgaWQ9XCJteVRpbWVyXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiB4PVwiNTBcIiB5PVwiNjBcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZXh0VGVtcGxhdGUgPyB0ZXh0VGVtcGxhdGUudGVtcGxhdGUgOiBkZWZhdWx0VGV4dFRlbXBsYXRlOyBjb250ZXh0OiBjb250ZXh0XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3RleHQ+XG5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZXh0VGVtcGxhdGU+XG4gICAgICAgIDx0c3BhbiBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX190ZXh0XCI+IHt7dGV4dENvbnRlbnQgPyB0ZXh0Q29udGVudDogdmFsdWVJblBlcmNlbnQgKyAnJSd9fTwvdHNwYW4+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvc3ZnPmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzcyB7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IFNUUk9LRV9PUEFDSVRZX0RWSURFUiA9IDEwMDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IFNUUk9LRV9PUEFDSVRZX0FERElUSU9OID0gLjI7XG5cbiAgICAvKipcbiAgICAgKkFuIGV2ZW50LCB3aGljaCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSBwcm9ncmVzcyBpcyBjaGFuZ2VkLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqcHVibGljIHByb2dyZXNzQ2hhbmdlKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJQcm9ncmVzcyBtYWRlIVwiKTtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgKG9uUHJvZ3Jlc3NDaGFuZ2VkKT1cInByb2dyZXNzQ2hhbmdlKCRldmVudClcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Qcm9ncmVzc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWNpcmN1bGFyLWJhci0ke05FWFRfQ0lSQ1VMQVJfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSB0ZXh0IHZpc2liaWxpdHkuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VmlzaWJpbGl0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIGluc2lkZSB0aGUgYGlneENpcmN1bGFyQmFyYC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIHRleHQ9XCJQcm9ncmVzc1wiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqbGV0IHRleHQgPSB0aGlzLmNpcmN1bGFyQmFyLnRleHQ7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0OiBzdHJpbmc7XG5cbiAgICBAQ29udGVudENoaWxkKElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyB0ZXh0VGVtcGxhdGU6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbnRleHQoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogeyB2YWx1ZTogdGhpcy52YWx1ZSwgdmFsdWVJblBlcmNlbnQ6IHRoaXMudmFsdWVJblBlcmNlbnQsIG1heDogdGhpcy5tYXh9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKkFuaW1hdGlvbiBvbiBwcm9ncmVzcyBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIGhhcyBhbmltYXRpb24gdHJ1ZS9mYWxzZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICBhbGVydChhbmltYXRpb25TdGF0dXMpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgbWF4KG1heE51bTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21heCA9IG1heE51bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IG1heCA9IHRoaXMucHJvZ3Jlc3NCYXIubWF4O1xuICAgICAqICAgIGFsZXJ0KG1heCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjQ1XCIgW2FuaW1hdGVdPVwiZmFsc2VcIiBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9zdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICBhbGVydCh2YWx1ZSk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cImdldFZhbHVlKClcIj5DbGljazwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWw6IG51bWJlcikge1xuICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5Qcm9wZXJSYW5nZSA9IGdldFZhbHVlSW5Qcm9wZXJSYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlSW5Qcm9wZXJSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRWYWx1ZXMgPSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IHZhbHVlSW5Qcm9wZXJSYW5nZSxcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHRoaXMuX3ZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBzdXBlci5kaXJlY3Rpb25GbG93KHRoaXMuX3ZhbHVlLCB2YWwsIHRoaXMuc3RlcCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUgJiYgdmFsID49IHRoaXMuc3RlcCkge1xuICAgICAgICAgICAgc3VwZXIucnVuQW5pbWF0aW9uKHZhbHVlSW5Qcm9wZXJSYW5nZSwgdXBkYXRlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbHVlSW5Qcm9wZXJSYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2lyY2xlUmFkaXVzID0gNDY7XG4gICAgcHJpdmF0ZSBfY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5fY2lyY2xlUmFkaXVzO1xuXG4gICAgQFZpZXdDaGlsZCgnY2lyY2xlJykgcHJpdmF0ZSBfc3ZnQ2lyY2xlOiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgLy8gU2V0IGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBGUkFNRVMgPSBbe1xuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogdGhpcy5nZXRQcm9ncmVzcyh0aGlzLl92YWx1ZSksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy5fdmFsdWUgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHRoaXMuZ2V0UHJvZ3Jlc3ModGhpcy52YWx1ZUluUGVyY2VudCksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy52YWx1ZUluUGVyY2VudCAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSKSArIHRoaXMuU1RST0tFX09QQUNJVFlfQURESVRJT05cbiAgICAgICAgfV07XG4gICAgICAgIHRoaXMuX3N2Z0NpcmNsZS5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsLCBzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWwpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAgICAgICB0aGlzLmdldFByb2dyZXNzKHRoaXMudmFsdWVJblBlcmNlbnQpKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAgICAgKHRoaXMudmFsdWVJblBlcmNlbnQgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY3VtZmVyZW5jZSAtIChwZXJjZW50YWdlICogdGhpcy5fY2lyY3VtZmVyZW5jZSAvIDEwMCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVJblByb3BlclJhbmdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW4gPSAwKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SW5QZXJjZW50YWdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoMTAwICogdmFsdWUgLyBtYXgpO1xufVxuXG4vKipcbiAqIFRoZSBJZ3hQcm9ncmVzc0Jhck1vZHVsZSBwcm92aWRlcyB0aGUge0BsaW5rIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50fSxcbiAqIHtAbGluayBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50fSBpbnNpZGUgeW91ciBhcHBsaWNhdGlvbi5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCwgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCwgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50LCBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50LCBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlXSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQcm9ncmVzc0Jhck1vZHVsZSB7XG59XG4iXX0=