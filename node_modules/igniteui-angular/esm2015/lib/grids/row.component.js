/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, forwardRef, HostBinding, Input, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { IgxCheckboxComponent } from '../checkbox/checkbox.component';
import { IgxSelectionAPIService } from '../core/selection';
import { IgxGridForOfDirective } from '../directives/for-of/for_of.directive';
import { GridBaseAPIService } from './api.service';
import { IgxGridCellComponent } from './cell.component';
import { TransactionType } from '../services';
// unsupported: template constraints.
/**
 * @template T
 */
export class IgxRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} selection
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, selection, element, cdr) {
        this.gridAPI = gridAPI;
        this.selection = selection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__tr';
        /**
         * @hidden
         */
        this._rowSelection = false;
    }
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     * @return {?}
     */
    get rowData() {
        if (this.inEditMode) {
            return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
        }
        return this._rowData;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set rowData(v) {
        this._rowData = v;
    }
    /**
     * @return {?}
     */
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @return {?}
     */
    get styleClasses() {
        return this.resolveClasses();
    }
    /**
     * @hidden
     * @return {?}
     */
    get columns() {
        return this.grid.visibleColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowSelectable() {
        return this.grid.rowSelectable;
    }
    /**
     * @hidden
     * @return {?}
     */
    get dirty() {
        const /** @type {?} */ row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
        }
        return false;
    }
    /**
     * @hidden
     * @return {?}
     */
    get deleted() {
        return this.isRowDeleted();
    }
    /**
     * @return {?}
     */
    get inEditMode() {
        if (this.grid.rowEditable) {
            const /** @type {?} */ editRowState = this.gridAPI.get_edit_row_state(this.gridID);
            return (editRowState && editRowState.rowID === this.rowID) || false;
        }
        else {
            return false;
        }
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     * @return {?}
     */
    get grid() {
        return this.gridAPI.get(this.gridID);
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowID() {
        // A row in the grid is identified either by:
        // primaryKey data value,
        // or if the primaryKey is omitted, then the whole rowData is used instead.
        const /** @type {?} */ primaryKey = this.grid.primaryKey;
        return primaryKey ? this._rowData[primaryKey] : this._rowData;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onCheckboxClick(event) {
        const /** @type {?} */ newSelection = (event.checked) ?
            this.selection.add_item(this.gridID, this.rowID) :
            this.selection.delete_item(this.gridID, this.rowID);
        this.grid.triggerRowSelectionChange(newSelection, this, event);
    }
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     * @param {?} value
     * @return {?}
     */
    update(value) {
        const /** @type {?} */ editableCell = this.gridAPI.get_cell_inEditMode(this.gridID);
        if (editableCell && editableCell.cellID.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        this.gridAPI.update_row(value, this.gridID, this.rowID);
        this.cdr.markForCheck();
        this.grid.refreshSearch();
    }
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     * @return {?}
     */
    delete() {
        this.grid.deleteRowById(this.rowID);
    }
    /**
     * @hidden
     * @return {?}
     */
    get rowCheckboxAriaLabel() {
        return this.grid.primaryKey ?
            this.isSelected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
            this.isSelected ? 'Deselect row' : 'Select row';
    }
    /**
     * @hidden
     * @return {?}
     */
    ngDoCheck() {
        this.isSelected = this.rowSelectable ?
            this.grid.allRowsSelected ? true : this.selection.is_item_selected(this.gridID, this.rowID) :
            this.selection.is_item_selected(this.gridID, this.rowID);
        this.cdr.markForCheck();
        if (this.checkboxElement) {
            this.checkboxElement.checked = this.isSelected;
        }
    }
    /**
     * @hidden
     * @param {?} arr
     * @return {?}
     */
    notGroups(arr) {
        return arr.filter(c => !c.columnGroup);
    }
    /**
     * @hidden
     * @return {?}
     */
    resolveClasses() {
        const /** @type {?} */ indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        const /** @type {?} */ selectedClass = this.isSelected ? 'igx-grid__tr--selected' : '';
        const /** @type {?} */ editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        const /** @type {?} */ dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        const /** @type {?} */ deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        return `${this.defaultCssClass} ${indexClass} ${selectedClass} ${editClass} ${dirtyClass} ${deletedClass}`.trim();
    }
    /**
     * @return {?}
     */
    isRowDeleted() {
        const /** @type {?} */ state = this.grid.transactions.getState(this.rowID);
        if (state) {
            return state.type === TransactionType.DELETE;
        }
        return false;
    }
}
IgxRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-row',
                template: `<ng-container *ngIf="grid.groupingExpressions.length > 0">
    <div class="igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}"></div>
</ng-container>
<ng-container *ngIf="rowSelectable">
    <div class="igx-grid__cbx-selection">
        <igx-checkbox [checked]="isSelected" (change)="onCheckboxClick($event)" disableRipple="true" [aria-label]="rowCheckboxAriaLabel"></igx-checkbox>
    </div>
</ng-container>
<ng-container *ngIf="pinnedColumns.length > 0">
    <igx-grid-cell *ngFor="let col of notGroups(pinnedColumns)" [column]="col" [row]="this" [style.min-width.px]="col.width" [style.flex-basis.px]="col.width" [value]="rowData[col.field]" [cellTemplate]="col.bodyTemplate"></igx-grid-cell>
</ng-container>
<ng-template igxGridFor let-col [igxGridForOf]="notGroups(unpinnedColumns)" [igxForScrollContainer]="grid.parentVirtDir" let-colIndex="index" [igxForScrollOrientation]="'horizontal'" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>
    <igx-grid-cell [column]="col" [row]="this" [style.min-width.px]="col.width" [style.flex-basis.px]="col.width" [value]="rowData[col.field]" [cellTemplate]="col.bodyTemplate"></igx-grid-cell>
</ng-template>
`
            },] },
];
/** @nocollapse */
IgxRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService, },
    { type: IgxSelectionAPIService, },
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
IgxRowComponent.propDecorators = {
    "rowData": [{ type: Input },],
    "index": [{ type: Input },],
    "gridID": [{ type: Input },],
    "virtDirRow": [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] },],
    "checkboxElement": [{ type: ViewChild, args: [forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent },] },],
    "cells": [{ type: ViewChildren, args: [forwardRef(() => IgxGridCellComponent), { read: IgxGridCellComponent },] },],
    "role": [{ type: HostBinding, args: ['attr.role',] },],
    "dataRowIndex": [{ type: HostBinding, args: ['attr.data-rowIndex',] },],
    "styleClasses": [{ type: HostBinding, args: ['class',] },],
    "isSelected": [{ type: HostBinding, args: ['attr.aria-selected',] },],
};
function IgxRowComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxRowComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxRowComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxRowComponent.propDecorators;
    /** @type {?} */
    IgxRowComponent.prototype._rowData;
    /**
     * The index of the row.
     *
     * ```typescript
     * // get the index of the second selected row
     * let selectedRowIndex = this.grid.selectedRows[1].index;
     * ```
     * @type {?}
     */
    IgxRowComponent.prototype.index;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.gridID;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.virtDirRow;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.checkboxElement;
    /**
     * The rendered cells in the row component.
     *
     * ```typescript
     * // get the cells of the third selected row
     * let selectedRowCells = this.grid.selectedRows[2].cells;
     * ```
     * @type {?}
     */
    IgxRowComponent.prototype.cells;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.role;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.isSelected;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.focused;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype.defaultCssClass;
    /**
     * @hidden
     * @type {?}
     */
    IgxRowComponent.prototype._rowSelection;
    /** @type {?} */
    IgxRowComponent.prototype.gridAPI;
    /** @type {?} */
    IgxRowComponent.prototype.selection;
    /** @type {?} */
    IgxRowComponent.prototype.element;
    /** @type {?} */
    IgxRowComponent.prototype.cdr;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvcm93LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUVULFVBQVUsRUFDVixVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFDTCxTQUFTLEVBQ1QsU0FBUyxFQUNULFlBQVksRUFDZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN0RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFeEQsT0FBTyxFQUFFLGVBQWUsRUFBUyxNQUFNLGFBQWEsQ0FBQzs7Ozs7QUF1QnJELE1BQU07Ozs7Ozs7SUFzTUYsWUFBbUIsT0FBOEIsRUFDckMsV0FDRCxTQUNBO1FBSFEsWUFBTyxHQUFQLE9BQU8sQ0FBdUI7UUFDckMsY0FBUyxHQUFULFNBQVM7UUFDVixZQUFPLEdBQVAsT0FBTztRQUNQLFFBQUcsR0FBSCxHQUFHOzs7O29CQXZJQSxLQUFLOzs7O3VCQXdIRixLQUFLOzs7OytCQUtNLGNBQWM7Ozs7NkJBS2hCLEtBQUs7S0FLTzs7Ozs7Ozs7OztRQTdMM0IsT0FBTztRQUNkLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUN6RztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDOzs7Ozs7UUFHZCxPQUFPLENBQUMsQ0FBTTtRQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQzs7Ozs7UUFpRGxCLFlBQVk7UUFDWixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQzs7Ozs7O1FBT2xCLFlBQVk7UUFDWixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDOzs7Ozs7SUFNakMsSUFBSSxPQUFPO1FBQ1AsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO0tBQ25DOzs7OztJQUtELElBQUksYUFBYTtRQUNiLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQztLQUNsQzs7Ozs7SUFLRCxJQUFJLGVBQWU7UUFDZixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7S0FDcEM7Ozs7O1FBS1UsYUFBYTtRQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7Ozs7OztRQVV4QixLQUFLO1FBQ1osdUJBQU0sR0FBRyxHQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNOLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLGVBQWUsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUMsTUFBTSxDQUFDO1NBQ2xGO1FBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQzs7Ozs7O1FBSU4sT0FBTztRQUNkLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7Ozs7O1FBR3BCLFVBQVU7UUFDakIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLHVCQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNsRSxNQUFNLENBQUMsQ0FBQyxZQUFZLElBQUksWUFBWSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDO1NBQ3ZFO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDSixNQUFNLENBQUMsS0FBSyxDQUFDO1NBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CTCxJQUFJLElBQUk7UUFDSixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3hDOzs7OztRQUtVLEtBQUs7Ozs7UUFJWix1QkFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDeEMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7SUFXbEUsSUFBSSxhQUFhO1FBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0tBQ3JDOzs7Ozs7SUEwQk0sZUFBZSxDQUFDLEtBQUs7UUFDeEIsdUJBQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBYTVELE1BQU0sQ0FBQyxLQUFVO1FBQ3BCLHVCQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuRSxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDNUI7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7SUFZdkIsTUFBTTtRQUNULElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7O0lBTXhDLElBQUksb0JBQW9CO1FBQ3BCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvRixJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztLQUN2RDs7Ozs7SUFLTSxTQUFTO1FBQ1osSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzdGLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUN2QixJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1NBQ2xEOzs7Ozs7O0lBTUwsU0FBUyxDQUFDLEdBQUc7UUFDVCxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQzFDOzs7OztJQUtTLGNBQWM7UUFDcEIsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDL0UsdUJBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDdEUsdUJBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDOUQsdUJBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDNUQsdUJBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDakUsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsSUFBSSxVQUFVLElBQUksYUFBYSxJQUFJLFNBQVMsSUFBSSxVQUFVLElBQUksWUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDckg7Ozs7SUFFUyxZQUFZO1FBQ2xCLHVCQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDUixNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUMsTUFBTSxDQUFDO1NBQ2hEO1FBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQztLQUNoQjs7O1lBM1RKLFNBQVMsU0FBQztnQkFDUCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsbUJBQW1CLEVBQUUsS0FBSztnQkFDMUIsUUFBUSxFQUFFLFNBQVM7Z0JBQ25CLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Q0FjYjthQUNBOzs7O1lBekJRLGtCQUFrQjtZQUZsQixzQkFBc0I7WUFUM0IsVUFBVTtZQUhWLGlCQUFpQjs7O3dCQW1EaEIsS0FBSztzQkFtQkwsS0FBSzt1QkFNTCxLQUFLOzJCQU1MLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUscUJBQXFCLEVBQUU7Z0NBTXRELFNBQVMsU0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxvQkFBb0IsRUFBRTtzQkFXaEYsWUFBWSxTQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLG9CQUFvQixFQUFFO3FCQU1uRixXQUFXLFNBQUMsV0FBVzs2QkFHdkIsV0FBVyxTQUFDLG9CQUFvQjs2QkFRaEMsV0FBVyxTQUFDLE9BQU87MkJBb0NuQixXQUFXLFNBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRG9DaGVjayxcbiAgICBFbGVtZW50UmVmLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q2hpbGRyZW5cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDaGVja2JveENvbXBvbmVudCB9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlIH0gZnJvbSAnLi4vY29yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgSWd4R3JpZEZvck9mRGlyZWN0aXZlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuL2NvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlLCBTdGF0ZSB9IGZyb20gJy4uL3NlcnZpY2VzJztcbmltcG9ydCB7IElneEdyaWRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9ncmlkLWJhc2UuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgc2VsZWN0b3I6ICdpZ3gtcm93JyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgKm5nSWY9XCJncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoID4gMFwiPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fcm93LWluZGVudGF0aW9uIGlneC1ncmlkX19yb3ctaW5kZW50YXRpb24tLWxldmVsLXt7Z3JpZC5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aH19XCI+PC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJyb3dTZWxlY3RhYmxlXCI+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19jYngtc2VsZWN0aW9uXCI+XG4gICAgICAgIDxpZ3gtY2hlY2tib3ggW2NoZWNrZWRdPVwiaXNTZWxlY3RlZFwiIChjaGFuZ2UpPVwib25DaGVja2JveENsaWNrKCRldmVudClcIiBkaXNhYmxlUmlwcGxlPVwidHJ1ZVwiIFthcmlhLWxhYmVsXT1cInJvd0NoZWNrYm94QXJpYUxhYmVsXCI+PC9pZ3gtY2hlY2tib3g+XG4gICAgPC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIj5cbiAgICA8aWd4LWdyaWQtY2VsbCAqbmdGb3I9XCJsZXQgY29sIG9mIG5vdEdyb3VwcyhwaW5uZWRDb2x1bW5zKVwiIFtjb2x1bW5dPVwiY29sXCIgW3Jvd109XCJ0aGlzXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJjb2wud2lkdGhcIiBbdmFsdWVdPVwicm93RGF0YVtjb2wuZmllbGRdXCIgW2NlbGxUZW1wbGF0ZV09XCJjb2wuYm9keVRlbXBsYXRlXCI+PC9pZ3gtZ3JpZC1jZWxsPlxuPC9uZy1jb250YWluZXI+XG48bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtY29sIFtpZ3hHcmlkRm9yT2ZdPVwibm90R3JvdXBzKHVucGlubmVkQ29sdW1ucylcIiBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiIGxldC1jb2xJbmRleD1cImluZGV4XCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JDb250YWluZXJTaXplXT0nZ3JpZC51bnBpbm5lZFdpZHRoJyBbaWd4Rm9yVHJhY2tCeV09J2dyaWQudHJhY2tDb2x1bW5DaGFuZ2VzJyAjaWd4RGlyUmVmPlxuICAgIDxpZ3gtZ3JpZC1jZWxsIFtjb2x1bW5dPVwiY29sXCIgW3Jvd109XCJ0aGlzXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJjb2wud2lkdGhcIiBbdmFsdWVdPVwicm93RGF0YVtjb2wuZmllbGRdXCIgW2NlbGxUZW1wbGF0ZV09XCJjb2wuYm9keVRlbXBsYXRlXCI+PC9pZ3gtZ3JpZC1jZWxsPlxuPC9uZy10ZW1wbGF0ZT5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4Um93Q29tcG9uZW50PFQgZXh0ZW5kcyBJZ3hHcmlkQmFzZUNvbXBvbmVudD4gaW1wbGVtZW50cyBEb0NoZWNrIHtcblxuICAgIHByaXZhdGUgX3Jvd0RhdGE6IGFueTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgcGFzc2VkIHRvIHRoZSByb3cgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldCB0aGUgcm93IGRhdGEgZm9yIHRoZSBmaXJzdCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dEYXRhID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1swXS5yb3dEYXRhO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCByb3dEYXRhKCk6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLmluRWRpdE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yb3dEYXRhLCB0aGlzLmdyaWQudHJhbnNhY3Rpb25zLmdldEFnZ3JlZ2F0ZWRWYWx1ZSh0aGlzLnJvd0lELCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dEYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgcm93RGF0YSh2OiBhbnkpIHtcbiAgICAgICAgdGhpcy5fcm93RGF0YSA9IHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcm93LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHNlY29uZCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dJbmRleCA9IHRoaXMuZ3JpZC5zZWxlY3RlZFJvd3NbMV0uaW5kZXg7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBncmlkSUQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdpZ3hEaXJSZWYnLCB7IHJlYWQ6IElneEdyaWRGb3JPZkRpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyB2aXJ0RGlyUm93OiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKGZvcndhcmRSZWYoKCkgPT4gSWd4Q2hlY2tib3hDb21wb25lbnQpLCB7IHJlYWQ6IElneENoZWNrYm94Q29tcG9uZW50IH0pXG4gICAgcHVibGljIGNoZWNrYm94RWxlbWVudDogSWd4Q2hlY2tib3hDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZWQgY2VsbHMgaW4gdGhlIHJvdyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0IHRoZSBjZWxscyBvZiB0aGUgdGhpcmQgc2VsZWN0ZWQgcm93XG4gICAgICogbGV0IHNlbGVjdGVkUm93Q2VsbHMgPSB0aGlzLmdyaWQuc2VsZWN0ZWRSb3dzWzJdLmNlbGxzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hHcmlkQ2VsbENvbXBvbmVudCksIHsgcmVhZDogSWd4R3JpZENlbGxDb21wb25lbnQgfSlcbiAgICBwdWJsaWMgY2VsbHM6IFF1ZXJ5TGlzdDxJZ3hHcmlkQ2VsbENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3Jvdyc7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuZGF0YS1yb3dJbmRleCcpXG4gICAgZ2V0IGRhdGFSb3dJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGdldCBzdHlsZUNsYXNzZXMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUNsYXNzZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbnMoKTogSWd4Q29sdW1uQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnZpc2libGVDb2x1bW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcGlubmVkQ29sdW1ucygpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucGlubmVkQ29sdW1ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHVucGlubmVkQ29sdW1ucygpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQudW5waW5uZWRDb2x1bW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvd1NlbGVjdGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucm93U2VsZWN0YWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWQnKVxuICAgIHB1YmxpYyBpc1NlbGVjdGVkOiBib29sZWFuO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0IGRpcnR5KCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCByb3c6IFN0YXRlID0gdGhpcy5ncmlkLnRyYW5zYWN0aW9ucy5nZXRTdGF0ZSh0aGlzLnJvd0lEKTtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQUREIHx8IHJvdy50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBkZWxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Jvd0RlbGV0ZWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGluRWRpdE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQucm93RWRpdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRSb3dTdGF0ZSA9IHRoaXMuZ3JpZEFQSS5nZXRfZWRpdF9yb3dfc3RhdGUodGhpcy5ncmlkSUQpO1xuICAgICAgICAgICAgcmV0dXJuIChlZGl0Um93U3RhdGUgJiYgZWRpdFJvd1N0YXRlLnJvd0lEID09PSB0aGlzLnJvd0lEKSB8fCBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgZ3JpZCB0aGF0IGNvbnRhaW5zIHRoZSBzZWxlY3RlZCByb3cuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaGFuZGxlUm93U2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICogIC8vIHRoZSBncmlkIG9uIHdoaWNoIHRoZSBvblJvd1NlbGVjdGlvbkNoYW5nZSBldmVudCB3YXMgdHJpZ2dlcmVkXG4gICAgICogIGNvbnN0IGdyaWQgPSBldmVudC5yb3cuZ3JpZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtZ3JpZFxuICAgICAqICAgIFtkYXRhXT1cImRhdGFcIlxuICAgICAqICAgIChvblJvd1NlbGVjdGlvbkNoYW5nZSk9XCJoYW5kbGVSb3dTZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAqICA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBncmlkKCk6IFQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQVBJLmdldCh0aGlzLmdyaWRJRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm93SUQoKSB7XG4gICAgICAgIC8vIEEgcm93IGluIHRoZSBncmlkIGlzIGlkZW50aWZpZWQgZWl0aGVyIGJ5OlxuICAgICAgICAvLyBwcmltYXJ5S2V5IGRhdGEgdmFsdWUsXG4gICAgICAgIC8vIG9yIGlmIHRoZSBwcmltYXJ5S2V5IGlzIG9taXR0ZWQsIHRoZW4gdGhlIHdob2xlIHJvd0RhdGEgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBwcmltYXJ5S2V5ID0gdGhpcy5ncmlkLnByaW1hcnlLZXk7XG4gICAgICAgIHJldHVybiBwcmltYXJ5S2V5ID8gdGhpcy5fcm93RGF0YVtwcmltYXJ5S2V5XSA6IHRoaXMuX3Jvd0RhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHJvdy4gQ291bGQgYmUgbnVsbCBpbiBjZXJ0YWluIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXQgdGhlIG5hdGl2ZUVsZW1lbnQgb2YgdGhlIHNlY29uZCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dOYXRpdmVFbGVtZW50ID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1sxXS5uYXRpdmVFbGVtZW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBmb2N1c2VkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlZmF1bHRDc3NDbGFzcyA9ICdpZ3gtZ3JpZF9fdHInO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcm93U2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPFQ+LFxuICAgICAgICBwcml2YXRlIHNlbGVjdGlvbjogSWd4U2VsZWN0aW9uQVBJU2VydmljZSxcbiAgICAgICAgcHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoZWNrYm94Q2xpY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gKGV2ZW50LmNoZWNrZWQpID9cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZF9pdGVtKHRoaXMuZ3JpZElELCB0aGlzLnJvd0lEKSA6XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5kZWxldGVfaXRlbSh0aGlzLmdyaWRJRCwgdGhpcy5yb3dJRCk7XG4gICAgICAgIHRoaXMuZ3JpZC50cmlnZ2VyUm93U2VsZWN0aW9uQ2hhbmdlKG5ld1NlbGVjdGlvbiwgdGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCByb3cgb2JqZWN0IGFuZCB0aGUgZGF0YSBzb3VyY2UgcmVjb3JkIHdpdGggdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBlbWl0cyBgb25FZGl0RG9uZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdXBkYXRlIHRoZSBzZWNvbmQgc2VsZWN0ZWQgcm93J3MgdmFsdWVcbiAgICAgKiBsZXQgbmV3VmFsdWUgPSBcIkFwcGxlXCI7XG4gICAgICogdGhpcy5ncmlkLnNlbGVjdGVkUm93c1sxXS51cGRhdGUobmV3VmFsdWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGUodmFsdWU6IGFueSkge1xuICAgICAgICBjb25zdCBlZGl0YWJsZUNlbGwgPSB0aGlzLmdyaWRBUEkuZ2V0X2NlbGxfaW5FZGl0TW9kZSh0aGlzLmdyaWRJRCk7XG4gICAgICAgIGlmIChlZGl0YWJsZUNlbGwgJiYgZWRpdGFibGVDZWxsLmNlbGxJRC5yb3dJRCA9PT0gdGhpcy5yb3dJRCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmVuZEVkaXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZEFQSS51cGRhdGVfcm93KHZhbHVlLCB0aGlzLmdyaWRJRCwgdGhpcy5yb3dJRCk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmdyaWQucmVmcmVzaFNlYXJjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCByb3cgZnJvbSB0aGUgZ3JpZCdzIGRhdGEgc291cmNlLlxuICAgICAqIFRoaXMgbWV0aG9kIGVtaXRzIGBvblJvd0RlbGV0ZWRgIGV2ZW50LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGRlbGV0ZSB0aGUgdGhpcmQgc2VsZWN0ZWQgcm93IGZyb20gdGhlIGdyaWRcbiAgICAgKiB0aGlzLmdyaWQuc2VsZWN0ZWRSb3dzWzJdLmRlbGV0ZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5kZWxldGVSb3dCeUlkKHRoaXMucm93SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcm93Q2hlY2tib3hBcmlhTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJpbWFyeUtleSA/XG4gICAgICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPyAnRGVzZWxlY3Qgcm93IHdpdGgga2V5ICcgKyB0aGlzLnJvd0lEIDogJ1NlbGVjdCByb3cgd2l0aCBrZXkgJyArIHRoaXMucm93SUQgOlxuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGVkID8gJ0Rlc2VsZWN0IHJvdycgOiAnU2VsZWN0IHJvdyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRoaXMucm93U2VsZWN0YWJsZSA/XG4gICAgICAgICAgICB0aGlzLmdyaWQuYWxsUm93c1NlbGVjdGVkID8gdHJ1ZSA6IHRoaXMuc2VsZWN0aW9uLmlzX2l0ZW1fc2VsZWN0ZWQodGhpcy5ncmlkSUQsIHRoaXMucm93SUQpIDpcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmlzX2l0ZW1fc2VsZWN0ZWQodGhpcy5ncmlkSUQsIHRoaXMucm93SUQpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tib3hFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94RWxlbWVudC5jaGVja2VkID0gdGhpcy5pc1NlbGVjdGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5vdEdyb3VwcyhhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoYyA9PiAhYy5jb2x1bW5Hcm91cCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZXNvbHZlQ2xhc3NlcygpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBpbmRleENsYXNzID0gdGhpcy5pbmRleCAlIDIgPyB0aGlzLmdyaWQuZXZlblJvd0NTUyA6IHRoaXMuZ3JpZC5vZGRSb3dDU1M7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ2xhc3MgPSB0aGlzLmlzU2VsZWN0ZWQgPyAnaWd4LWdyaWRfX3RyLS1zZWxlY3RlZCcgOiAnJztcbiAgICAgICAgY29uc3QgZWRpdENsYXNzID0gdGhpcy5pbkVkaXRNb2RlID8gJ2lneC1ncmlkX190ci0tZWRpdCcgOiAnJztcbiAgICAgICAgY29uc3QgZGlydHlDbGFzcyA9IHRoaXMuZGlydHkgPyAnaWd4LWdyaWRfX3RyLS1lZGl0ZWQnIDogJyc7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWRDbGFzcyA9IHRoaXMuZGVsZXRlZCA/ICdpZ3gtZ3JpZF9fdHItLWRlbGV0ZWQnIDogJyc7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmRlZmF1bHRDc3NDbGFzc30gJHtpbmRleENsYXNzfSAke3NlbGVjdGVkQ2xhc3N9ICR7ZWRpdENsYXNzfSAke2RpcnR5Q2xhc3N9ICR7ZGVsZXRlZENsYXNzfWAudHJpbSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc1Jvd0RlbGV0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHN0YXRlOiBTdGF0ZSA9IHRoaXMuZ3JpZC50cmFuc2FjdGlvbnMuZ2V0U3RhdGUodGhpcy5yb3dJRCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl19