/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, Renderer, ViewChild } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
var /** @type {?} */ NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
var IgxNavigationDrawerComponent = /** @class */ (function () {
    function IgxNavigationDrawerComponent(elementRef, _state, 
    // private animate: AnimationBuilder, TODO
    renderer, _touchManager) {
        var _this = this;
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.cssClass = 'igx-nav-drawer';
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = "igx-nav-drawer-" + NEXT_ID++;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * State of the drawer.
         *
         * ```typescript
         * // get
         * let navDrawerIsOpen = this.navdrawer.isOpen;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
         * ```
         */
        this.isOpen = false;
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 60px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '60px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = function (evt) {
            var /** @type {?} */ windowWidth;
            if (_this.pinThreshold) {
                windowWidth = _this.getWindowWidth();
                if (evt && _this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                _this._widthCache.windowWidth = windowWidth;
                if (!_this.pin && windowWidth >= _this.pinThreshold) {
                    _this.pin = true;
                    _this.pinChange.emit(true);
                }
                else if (_this.pin && windowWidth < _this.pinThreshold) {
                    _this.pin = false;
                    _this.pinChange.emit(false);
                }
            }
        };
        this.swipe = function (evt) {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!_this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            var /** @type {?} */ deltaX;
            var /** @type {?} */ startPosition;
            if (_this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((_this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                _this.toggle();
            }
        };
        this.panstart = function (evt) {
            // TODO: test code
            if (!_this.enableGestures || _this.pin || evt.pointerType !== 'touch') {
                return;
            }
            var /** @type {?} */ startPosition = _this.position === 'right' ? _this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                _this._panning = true;
                _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                _this.renderer.setElementClass(_this.overlay, 'panning', true);
                _this.renderer.setElementClass(_this.drawer, 'panning', true);
            }
        };
        this.pan = function (evt) {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!_this._panning) {
                return;
            }
            var /** @type {?} */ right = _this.position === 'right';
            // when on the right use inverse of deltaX
            var /** @type {?} */ deltaX = right ? -evt.deltaX : evt.deltaX;
            var /** @type {?} */ visibleWidth;
            var /** @type {?} */ newX;
            var /** @type {?} */ percent;
            visibleWidth = _this._panStartWidth + deltaX;
            if (_this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panStartWidth;
                    newX = evt.deltaX;
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!_this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panLimit;
                    newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = function (evt) {
            if (_this._panning) {
                var /** @type {?} */ deltaX = _this.position === 'right' ? -evt.deltaX : evt.deltaX;
                var /** @type {?} */ visibleWidth = _this._panStartWidth + deltaX;
                _this.resetPan();
                // check if pan brought the drawer to 50%
                if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                    _this.close();
                }
                else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                    _this.open();
                }
                _this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleOpenedEvent, false);
            _this.opened.emit();
        };
        this.toggleClosedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleClosedEvent, false);
            _this.closed.emit();
        };
    }
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "element", {
        /**
         * Returns nativeElement of the component.
         *
         * @hidden
         */
        get: /**
         * Returns nativeElement of the component.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "template", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.miniTemplate && !this.isOpen) {
                return this.miniTemplate.template;
            }
            else if (this.contentTemplate) {
                return this.contentTemplate.template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "miniTemplate", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._miniTemplate;
        },
        set: /**
         * @hidden
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (!this.isOpen) {
                this.setDrawerWidth(v ? this.miniWidth : '');
            }
            this._miniTemplate = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "flexWidth", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (!this.pin) {
                return '0px';
            }
            if (this.isOpen) {
                return this.width;
            }
            if (this.miniTemplate && this.miniWidth) {
                return this.miniWidth;
            }
            return '0px';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isPinnedRight", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin && this.position === 'right' ? '1' : '0';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "drawer", {
        /**
          * @hidden
          */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._drawer.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "overlay", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._overlay.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "styleDummy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._styleDummy.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "hasAnimateWidth", {
        get: /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin || !!this.miniTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "maxEdgeZone", {
        get: /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._maxEdgeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedWidth", {
        get: /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedMiniWidth", {
        get: /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "touchManager", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._touchManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "state", {
        get: /**
         * Exposes optional navigation service
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    };
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes["enableGestures"] && changes["enableGestures"].currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes["pin"] && changes["pin"].currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes["pinThreshold"]) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes["width"] && this.isOpen) {
            this.setDrawerWidth(changes["width"].currentValue);
        }
        if (changes["miniWidth"]) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes["miniWidth"].currentValue);
            }
            this.updateEdgeZone();
        }
    };
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.toggle = /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    };
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.open = /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    };
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.close = /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.set_maxEdgeZone = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._maxEdgeZone = value;
    };
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param {?=} mini
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getExpectedWidth = /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param {?=} mini
     * @return {?}
     */
    function (mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                }
                return this._widthCache.width;
            }
        }
    };
    /**
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getWindowWidth = /**
     * @return {?}
     */
    function () {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    };
    /**
     * Sets the drawer width.
     * @param {?} width
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setDrawerWidth = /**
     * Sets the drawer width.
     * @param {?} width
     * @return {?}
     */
    function (width) {
        var _this = this;
        window.requestAnimationFrame(function () {
            if (_this.drawer) {
                _this.renderer.setElementStyle(_this.drawer, 'width', width);
            }
        });
    };
    /**
     * Get current Drawer width.
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getDrawerWidth = /**
     * Get current Drawer width.
     * @return {?}
     */
    function () {
        return this.drawer.offsetWidth;
    };
    /**
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ensureEvents = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(function () { return interval(150); }))
                .subscribe(function (value) {
                _this.checkPinThreshold(value);
            });
        }
    };
    /**
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.updateEdgeZone = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    };
    /**
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.resetPan = /**
     * @return {?}
     */
    function () {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    };
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setXSize = /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    function (x, opacity) {
        var _this = this;
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(function () {
            if (_this.hasAnimateWidth) {
                _this.renderer.setElementStyle(_this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                _this.renderer.setElementStyle(_this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                _this.renderer.setElementStyle(_this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                _this.renderer.setElementStyle(_this.overlay, 'opacity', opacity);
            }
        });
    };
    IgxNavigationDrawerComponent.decorators = [
        { type: Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-nav-drawer',
                    template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n"
                },] },
    ];
    /** @nocollapse */
    IgxNavigationDrawerComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] },] },
        { type: IgxNavigationService, decorators: [{ type: Optional },] },
        { type: Renderer, },
        { type: HammerGesturesManager, },
    ]; };
    IgxNavigationDrawerComponent.propDecorators = {
        "cssClass": [{ type: HostBinding, args: ['class',] },],
        "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
        "position": [{ type: Input },],
        "enableGestures": [{ type: Input },],
        "isOpen": [{ type: Input },],
        "pin": [{ type: Input },],
        "pinThreshold": [{ type: Input },],
        "width": [{ type: Input },],
        "miniWidth": [{ type: Input },],
        "pinChange": [{ type: Output },],
        "opening": [{ type: Output },],
        "opened": [{ type: Output },],
        "closing": [{ type: Output },],
        "closed": [{ type: Output },],
        "miniTemplate": [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] },],
        "contentTemplate": [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] },],
        "flexWidth": [{ type: HostBinding, args: ['style.flexBasis',] },],
        "isPinnedRight": [{ type: HostBinding, args: ['style.order',] },],
        "_drawer": [{ type: ViewChild, args: ['aside',] },],
        "_overlay": [{ type: ViewChild, args: ['overlay',] },],
        "_styleDummy": [{ type: ViewChild, args: ['dummy',] },],
    };
    return IgxNavigationDrawerComponent;
}());
export { IgxNavigationDrawerComponent };
function IgxNavigationDrawerComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxNavigationDrawerComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxNavigationDrawerComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxNavigationDrawerComponent.propDecorators;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.cssClass;
    /**
     * ID of the component
     *
     * ```typescript
     * // get
     * let myNavDrawerId = this.navdrawer.id;
     * ```
     *
     * ```html
     * <!--set-->
     *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.id;
    /**
     * Position of the Navigation Drawer. Can be "left"(default) or "right".
     *
     * ```typescript
     * // get
     * let myNavDrawerPosition = this.navdrawer.position;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.position;
    /**
     * Enables the use of touch gestures to manipulate the drawer:
     * - swipe/pan from edge to open, swipe-toggle and pan-drag.
     *
     * ```typescript
     * // get
     * let gesturesEnabled = this.navdrawer.enableGestures;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.enableGestures;
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.isOpen;
    /**
     * When pinned the drawer is relatively positioned instead of sitting above content.
     * May require additional layout styling.
     *
     * ```typescript
     * // get
     * let navDrawerIsPinned = this.navdrawer.pin;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pin;
    /**
     * Minimum device width required for automatic pin to be toggled.
     * Default is 1024, can be set to a falsy value to disable this behavior.
     *
     * ```typescript
     * // get
     * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinThreshold;
    /**
     * Width of the drawer in its open state. Defaults to "280px".
     *
     * ```typescript
     * // get
     * let navDrawerWidth = this.navdrawer.width;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.width;
    /**
     * Width of the drawer in its mini state. Defaults to 60px.
     *
     * ```typescript
     * // get
     * let navDrawerMiniWidth = this.navdrawer.miniWidth;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.miniWidth;
    /**
     * Pinned state change output for two-way binding.
     *
     * ```html
     * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinChange;
    /**
     * Event fired as the Navigation Drawer is about to open.
     *
     * ```html
     *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opening;
    /**
     * Event fired when the Navigation Drawer has opened.
     *
     * ```html
     * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opened;
    /**
     * Event fired as the Navigation Drawer is about to close.
     *
     * ```html
     * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closing;
    /**
     * Event fired when the Navigation Drawer has closed.
     *
     * ```html
     * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closed;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._miniTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.contentTemplate;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._gesturesAttached;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._widthCache;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._resizeObserver;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.css;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._drawer;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._overlay;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._styleDummy;
    /**
     * Pan animation properties
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype._panning;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._panStartWidth;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._panLimit;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._maxEdgeZone;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.checkPinThreshold;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.swipe;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.panstart;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.pan;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.panEnd;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.toggleOpenedEvent;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.toggleClosedEvent;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.elementRef;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._state;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.renderer;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._touchManager;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9uYXZpZ2F0aW9uLWRyYXdlci9uYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLE1BQU0sRUFDTixRQUFRLEVBR1IsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sb0JBQW9CLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRWxILHFCQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1WVosc0NBQ2dDLFlBQ1I7O0lBRVYsUUFBa0IsRUFDcEI7UUFMWixpQkFNQztRQUwrQixlQUFVLEdBQVYsVUFBVTtRQUNsQixXQUFNLEdBQU4sTUFBTTtRQUVoQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ3BCLGtCQUFhLEdBQWIsYUFBYTt3QkFsVmUsZ0JBQWdCOzs7Ozs7Ozs7Ozs7OztrQkFnQm5DLG9CQUFrQixPQUFPLEVBQUk7Ozs7Ozs7Ozs7Ozs7O3dCQWV2QixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7OEJBZ0JBLElBQUk7Ozs7Ozs7Ozs7Ozs7O3NCQWVaLEtBQUs7Ozs7Ozs7Ozs7Ozs7OzttQkFn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dCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcixcbiAgICBTaW1wbGVDaGFuZ2UsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi9jb3JlL3RvdWNoJztcbmltcG9ydCB7IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL25hdmlnYXRpb24tZHJhd2VyLmRpcmVjdGl2ZXMnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIE5hdmlnYXRpb24gRHJhd2VyKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL25hdmRyYXdlci5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYSBjb2xsYXBzaWJsZSBzaWRlIG5hdmlnYXRpb24gY29udGFpbmVyIGNvbW1vbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgTmF2YmFyLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LW5hdi1kcmF3ZXIgaWQ9XCJuYXZpZ2F0aW9uXCIgW2lzT3Blbl09XCJ0cnVlXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXI+XG4gKiAgICAgPG5hdj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gW2lzSGVhZGVyXT1cInRydWVcIj5FbWFpbDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPkluYm94PC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+RGVsZXRlZDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPlNlbnQ8L3NwYW4+XG4gKiAgICAgPC9uYXY+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2lneC1uYXYtZHJhd2VyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtbmF2LWRyYXdlcicsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgI2RlZmF1bHRJdGVtc1RlbXBsYXRlPlxuICAgIDxkaXYgaWd4RHJhd2VySXRlbSBbaXNIZWFkZXJdPVwidHJ1ZVwiPk5hdmlnYXRpb24gRHJhd2VyPC9kaXY+XG4gICAgPGRpdiBpZ3hEcmF3ZXJJdGVtPiBTdGFydCBieSBhZGRpbmc8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IDxjb2RlPiZsdDtuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXImZ3Q7PC9jb2RlPiA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IEFuZCBzb21lIGl0ZW1zIGluc2lkZSA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IFN0eWxlIHdpdGggaWd4RHJhd2VySXRlbSA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IGFuZCBpZ3hSaXBwbGUgZGlyZWN0aXZlczwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPGRpdiBbaGlkZGVuXT1cInBpblwiXG4gICAgY2xhc3M9XCJpZ3gtbmF2LWRyYXdlcl9fb3ZlcmxheVwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19vdmVybGF5LS1oaWRkZW5dPVwiIWlzT3BlblwiXG4gICAgKGNsaWNrKT1cImNsb3NlKClcIiAjb3ZlcmxheT5cbjwvZGl2PlxuPGFzaWRlIHJvbGU9XCJuYXZpZ2F0aW9uXCJcbiAgICBjbGFzcz1cImlneC1uYXYtZHJhd2VyX19hc2lkZVwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tY29sbGFwc2VkXT1cIiFtaW5pVGVtcGxhdGUgJiYgIWlzT3BlblwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tbWluaV09XCJtaW5pVGVtcGxhdGUgJiYgIWlzT3BlblwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tbm9ybWFsXT1cIiFtaW5pVGVtcGxhdGUgfHwgaXNPcGVuXCJcbiAgICBbY2xhc3MuaWd4LW5hdi1kcmF3ZXJfX2FzaWRlLS1waW5uZWRdPVwicGluXCJcbiAgICBbY2xhc3MuaWd4LW5hdi1kcmF3ZXJfX2FzaWRlLS1yaWdodF09XCJwb3NpdGlvbiA9PSAncmlnaHQnXCIgI2FzaWRlPlxuXG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlIHx8IGRlZmF1bHRJdGVtc1RlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG48L2FzaWRlPlxuPGRpdiBjbGFzcz1cImlneC1uYXYtZHJhd2VyX19zdHlsZS1kdW1teVwiICNkdW1teT48L2Rpdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4TmF2aWdhdGlvbkRyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzXG4gICAgSVRvZ2dsZVZpZXcsXG4gICAgT25Jbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uQ2hhbmdlcyB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcHVibGljIGNzc0NsYXNzID0gJ2lneC1uYXYtZHJhd2VyJztcblxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbXlOYXZEcmF3ZXJJZCA9IHRoaXMubmF2ZHJhd2VyLmlkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIGlkPSduYXZkcmF3ZXInPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKSBwdWJsaWMgaWQgPSBgaWd4LW5hdi1kcmF3ZXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gQ2FuIGJlIFwibGVmdFwiKGRlZmF1bHQpIG9yIFwicmlnaHRcIi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbXlOYXZEcmF3ZXJQb3NpdGlvbiA9IHRoaXMubmF2ZHJhd2VyLnBvc2l0aW9uO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3Bvc2l0aW9uXT1cIidsZWZ0J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgdXNlIG9mIHRvdWNoIGdlc3R1cmVzIHRvIG1hbmlwdWxhdGUgdGhlIGRyYXdlcjpcbiAgICAgKiAtIHN3aXBlL3BhbiBmcm9tIGVkZ2UgdG8gb3Blbiwgc3dpcGUtdG9nZ2xlIGFuZCBwYW4tZHJhZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgZ2VzdHVyZXNFbmFibGVkID0gdGhpcy5uYXZkcmF3ZXIuZW5hYmxlR2VzdHVyZXM7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbZW5hYmxlR2VzdHVyZXNdPSd0cnVlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBlbmFibGVHZXN0dXJlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgZHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJJc09wZW4gPSB0aGlzLm5hdmRyYXdlci5pc09wZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbaXNPcGVuXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGlzT3BlbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwaW5uZWQgdGhlIGRyYXdlciBpcyByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgaW5zdGVhZCBvZiBzaXR0aW5nIGFib3ZlIGNvbnRlbnQuXG4gICAgICogTWF5IHJlcXVpcmUgYWRkaXRpb25hbCBsYXlvdXQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNQaW5uZWQgPSB0aGlzLm5hdmRyYXdlci5waW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBkZXZpY2Ugd2lkdGggcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBwaW4gdG8gYmUgdG9nZ2xlZC5cbiAgICAgKiBEZWZhdWx0IGlzIDEwMjQsIGNhbiBiZSBzZXQgdG8gYSBmYWxzeSB2YWx1ZSB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlclBpblRyZXNob2xkID0gdGhpcy5uYXZkcmF3ZXIucGluVGhyZXNob2xkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3BpblRyZXNob2xkXT0nMTAyNCc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGluVGhyZXNob2xkID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlRWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIGRyYXdlciBpbiBpdHMgb3BlbiBzdGF0ZS4gRGVmYXVsdHMgdG8gXCIyODBweFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJXaWR0aCA9IHRoaXMubmF2ZHJhd2VyLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3dpZHRoXT1cIicyMjhweCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aCA9ICcyODBweCc7XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2MHB4LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJNaW5pV2lkdGggPSB0aGlzLm5hdmRyYXdlci5taW5pV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbbWluaVdpZHRoXT1cIiczNHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG1pbmlXaWR0aCA9ICc2MHB4JztcblxuICAgIC8qKlxuICAgICAqIFBpbm5lZCBzdGF0ZSBjaGFuZ2Ugb3V0cHV0IGZvciB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsocGluKV09J2lzUGlubmVkJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcGluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBhcyB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIChvcGVuaW5nKT0nb25PcGVuaW5nKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChvcGVuZWQpPSdvbk9wZW5lZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGFzIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NpbmcpPSdvbkNsb3NpbmcoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaGFzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NlZCk9J29uQ2xvc2VkKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX21pbmlUZW1wbGF0ZTogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbmlUZW1wbGF0ZSgpOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgc2V0IG1pbmlUZW1wbGF0ZSh2OiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh2ID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWluaVRlbXBsYXRlID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBjb250ZW50VGVtcGxhdGU6IElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleEJhc2lzJylcbiAgICBnZXQgZmxleFdpZHRoKCkge1xuICAgICAgICBpZiAoIXRoaXMucGluKSB7XG4gICAgICAgICAgICByZXR1cm4gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgdGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnMHB4JztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIGdldCBpc1Bpbm5lZFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gJiYgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICAnMScgOiAnMCc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2VzdHVyZXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3dpZHRoQ2FjaGU6IHsgd2lkdGg6IG51bWJlciwgbWluaVdpZHRoOiBudW1iZXIsIHdpbmRvd1dpZHRoOiBudW1iZXIgfSA9IHsgd2lkdGg6IG51bGwsIG1pbmlXaWR0aDogbnVsbCwgd2luZG93V2lkdGg6IG51bGwgfTtcbiAgICBwcml2YXRlIF9yZXNpemVPYnNlcnZlcjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgY3NzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7XG4gICAgICAgIGRyYXdlcjogJ2lneC1uYXYtZHJhd2VyX19hc2lkZScsXG4gICAgICAgIG1pbmk6ICdpZ3gtbmF2LWRyYXdlcl9fYXNpZGUtLW1pbmknLFxuICAgICAgICBvdmVybGF5OiAnaWd4LW5hdi1kcmF3ZXJfX292ZXJsYXknLFxuICAgICAgICBzdHlsZUR1bW15OiAnaWd4LW5hdi1kcmF3ZXJfX3N0eWxlLWR1bW15J1xuICAgIH07XG5cbiAgICBAVmlld0NoaWxkKCdhc2lkZScpIHByaXZhdGUgX2RyYXdlcjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JykgcHJpdmF0ZSBfb3ZlcmxheTogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdkdW1teScpIHByaXZhdGUgX3N0eWxlRHVtbXk6IEVsZW1lbnRSZWY7XG5cbiAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZHJhd2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd2VyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3R5bGVEdW1teSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRHVtbXkubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogUGFuIGFuaW1hdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgcHJpdmF0ZSBfcGFubmluZyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3BhblN0YXJ0V2lkdGg6IG51bWJlcjtcbiAgICBwcml2YXRlIF9wYW5MaW1pdDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY2hhbmdlIHdpZHRoIG9yIHRyYW5zbGF0ZSB0aGUgZHJhd2VyIGZyb20gcGFuIGdlc3R1cmUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNBbmltYXRlV2lkdGgoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbiB8fCAhIXRoaXMubWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21heEVkZ2Vab25lID0gNTA7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGFuZCBwYW4pLlxuICAgICAqIERlZmF1bHRzIHRvIDUwIChpbiBweCkgYW5kIGlzIGV4dGVuZGVkIHRvIGF0IGxlYXN0IDExMCUgb2YgdGhlIG1pbmkgdGVtcGxhdGUgd2lkdGggaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4RWRnZVpvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhFZGdlWm9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBlY3RlZFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciBtaW5pIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkTWluaVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VzIG9wdGlvbmFsIG5hdmlnYXRpb24gc2VydmljZVxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3N0YXRlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgLy8gcHJpdmF0ZSBhbmltYXRlOiBBbmltYXRpb25CdWlsZGVyLCBUT0RPXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIsXG4gICAgICAgIHByaXZhdGUgX3RvdWNoTWFuYWdlcjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgLy8gRE9NIGFuZCBASW5wdXQoKS1zIGluaXRpYWxpemVkXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHRoaXMuaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyB3YWl0IGZvciB0ZW1wbGF0ZSBhbmQgbmctY29udGVudCB0byBiZSByZWFkeVxuICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tQaW5UaHJlc2hvbGQoKTtcblxuICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFRPRE86IGFwcGx5IHBsYXRmb3JtLXNhZmUgUnVsZXIgZnJvbSBodHRwOi8vcGxua3IuY28vZWRpdC84MW5XRHlyZVlNemt1bmloZlJnWD9wPXByZXZpZXdcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY1MTUpLCBibG9ja2VkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5MDRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xuICAgICAgICAvLyBzaW1wbGUgc2V0dGluZ3MgY2FuIGNvbWUgZnJvbSBhdHRyaWJ1dGUgc2V0IChyYXRoZXIgdGhhbiBiaW5kaW5nKSwgbWFrZSBzdXJlIGJvb2xlYW4gcHJvcHMgYXJlIGNvbnZlcnRlZFxuICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVHZXN0dXJlcyAmJiBjaGFuZ2VzLmVuYWJsZUdlc3R1cmVzLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUdlc3R1cmVzID0gISEodGhpcy5lbmFibGVHZXN0dXJlcyAmJiB0aGlzLmVuYWJsZUdlc3R1cmVzLnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpbiAmJiBjaGFuZ2VzLnBpbi5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5waW4gPSAhISh0aGlzLnBpbiAmJiB0aGlzLnBpbi50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGluKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMud2lkdGggJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlcy53aWR0aC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMubWluaVdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aChjaGFuZ2VzLm1pbmlXaWR0aC5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVFZGdlWm9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBvcGVuIHN0YXRlIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIEhhcyBubyBlZmZlY3QgaWYgYWxyZWFkeSBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIub3BlbigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbmluZy5lbWl0KCk7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gYW5pbWF0ZSBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdmFyIGFuaW1hdGlvbkNzcyA9IHRoaXMuYW5pbWF0ZS5jc3MoKTtcbiAgICAgICAgLy8gICAgIGFuaW1hdGlvbkNzc1xuICAgICAgICAvLyAgICAgICAgIC5zZXRTdHlsZXMoeyd3aWR0aCc6JzUwcHgnfSwgeyd3aWR0aCc6JzQwMHB4J30pXG4gICAgICAgIC8vICAgICAgICAgLnN0YXJ0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgICAvLyAgICAgICAgIC5vbkNvbXBsZXRlKCgpID0+IGFuaW1hdGlvbkNzcy5zZXRUb1N0eWxlcyh7J3dpZHRoJzonYXV0byd9KS5zdGFydCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy53aWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NpbmcuZW1pdCgpO1xuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy5taW5pVGVtcGxhdGUgPyB0aGlzLm1pbmlXaWR0aCA6ICcnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNldF9tYXhFZGdlWm9uZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21heEVkZ2Vab25lID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gW21pbmldIC0gUmVxdWVzdCBtaW5pIHdpZHRoIGluc3RlYWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RXhwZWN0ZWRXaWR0aChtaW5pPzogYm9vbGVhbik6IG51bWJlciB7XG4gICAgICAgIGlmIChtaW5pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLm1pbmlXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmICghdGhpcy5pc09wZW4pIHsgLy8gVGhpcyBXT04nVCB3b3JrIGR1ZSB0byB0cmFuc2l0aW9uIHRpbWluZ3MuLi5cbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzFdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MubWluaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLm1pbmksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGUud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS53aWR0aCA9IHRoaXMuc3R5bGVEdW1teS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFdpbmRvd1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5pbm5lcldpZHRoID4gMCkgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHNjcmVlbi53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXREcmF3ZXJXaWR0aCh3aWR0aDogc3RyaW5nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgRHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RHJhd2VyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5zdXJlRXZlbnRzKCkge1xuICAgICAgICAvLyBzZXQgbGlzdGVuZXJzIGZvciBzd2lwZS9wYW4gb25seSBpZiBuZWVkZWQsIGJ1dCBqdXN0IG9uY2VcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2VzdHVyZXMgJiYgIXRoaXMucGluICYmICF0aGlzLl9nZXN0dXJlc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAvLyBCdWlsdC1pbiBtYW5hZ2VyIGhhbmRsZXIoTDIwODg3KSBjYXVzZXMgZW5kbGVzcyBsb29wIGFuZCBtYXggc3RhY2sgZXhjZXB0aW9uLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjk5M1xuICAgICAgICAgICAgLy8gVXNlIG91cnMgZm9yIG5vdyAodW50aWwgYmV0YS4xMCk6XG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJzd2lwZVwiLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdzd2lwZScsIHRoaXMuc3dpcGUpO1xuICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInBhbnN0YXJ0XCIsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwicGFuXCIsIHRoaXMucGFuKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5zdGFydCcsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3Bhbm1vdmUnLCB0aGlzLnBhbik7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFuZW5kJywgdGhpcy5wYW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTUwKSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUVkZ2Vab25lKCkge1xuICAgICAgICBsZXQgbWF4VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heEVkZ2Vab25lLCB0aGlzLmdldEV4cGVjdGVkV2lkdGgodHJ1ZSkgKiAxLjEpO1xuICAgICAgICAgICAgdGhpcy5zZXRfbWF4RWRnZVpvbmUobWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjaGVja1BpblRocmVzaG9sZCA9IChldnQ/OiBFdmVudCkgPT4ge1xuICAgICAgICBsZXQgd2luZG93V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgd2luZG93V2lkdGggPSB0aGlzLmdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgICAgICBpZiAoZXZ0ICYmIHRoaXMuX3dpZHRoQ2FjaGUud2luZG93V2lkdGggPT09IHdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS53aW5kb3dXaWR0aCA9IHdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBpbiAmJiB3aW5kb3dXaWR0aCA+PSB0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbkNoYW5nZS5lbWl0KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBpbiAmJiB3aW5kb3dXaWR0aCA8IHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbkNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3dpcGUgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBDb3VsZCBhbHNvIGZvcmNlIGlucHV0IHR5cGU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MTA4MDUyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVHZXN0dXJlcyB8fCBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbW1lckpTIHN3aXBlIGlzIGhvcml6b250YWwtb25seSBieSBkZWZhdWx0LCBkb24ndCBjaGVjayBkZWx0YVlcbiAgICAgICAgbGV0IGRlbHRhWDtcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyB3aGVuIG9uIHRoZSByaWdodCB1c2UgaW52ZXJzZSBvZiBkZWx0YVhcbiAgICAgICAgICAgIGRlbHRhWCA9IC1ldnQuZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuZ2V0V2luZG93V2lkdGgoKSAtIChldnQuY2VudGVyLnggKyBldnQuZGlzdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBldnQuY2VudGVyLnggLSBldnQuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBhY2NlcHQgY2xvc2luZyBzd2lwZSAoaWdub3JpbmcgbWluRWRnZVpvbmUpIHdoZW4gdGhlIGRyYXdlciBpcyBleHBhbmRlZDpcbiAgICAgICAgaWYgKCh0aGlzLmlzT3BlbiAmJiBkZWx0YVggPCAwKSB8fFxuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZGVsdGFYIGZyb20gdGhlIGVkZ2U6XG4gICAgICAgICAgICAoZGVsdGFYID4gMCAmJiBzdGFydFBvc2l0aW9uIDwgdGhpcy5tYXhFZGdlWm9uZSkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbnN0YXJ0ID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHsgLy8gVE9ETzogdGVzdCBjb2RlXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVHZXN0dXJlcyB8fCB0aGlzLnBpbiB8fCBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IHRoaXMuZ2V0V2luZG93V2lkdGgoKSAtIChldnQuY2VudGVyLnggKyBldnQuZGlzdGFuY2UpXG4gICAgICAgICAgICA6IGV2dC5jZW50ZXIueCAtIGV2dC5kaXN0YW5jZTtcblxuICAgICAgICAvLyBjYWNoZSB3aWR0aCBkdXJpbmcgYW5pbWF0aW9uLCBmbGFnIHRvIGFsbG93IGZ1cnRoZXIgaGFuZGxpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuIHx8IChzdGFydFBvc2l0aW9uIDwgdGhpcy5tYXhFZGdlWm9uZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcGFuU3RhcnRXaWR0aCA9IHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCghdGhpcy5pc09wZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGFuTGltaXQgPSB0aGlzLmdldEV4cGVjdGVkV2lkdGgodGhpcy5pc09wZW4pO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLm92ZXJsYXksICdwYW5uaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLmRyYXdlciwgJ3Bhbm5pbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgLy8gVE9ETzogaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgICAgIC8vIGdldCBhY3R1YWwgZGVsdGEgKG5vdCB0b3RhbCBzZXNzaW9uIG9uZSkgZnJvbSBldmVudD9cbiAgICAgICAgLy8gcGFuIFdJTEwgYWxzbyBmaXJlIGFmdGVyIGEgZnVsbCBzd2lwZSwgb25seSByZXNpemUgb24gZmxhZ1xuICAgICAgICBpZiAoIXRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodDogYm9vbGVhbiA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIC8vIHdoZW4gb24gdGhlIHJpZ2h0IHVzZSBpbnZlcnNlIG9mIGRlbHRhWFxuICAgICAgICBjb25zdCBkZWx0YVggPSByaWdodCA/IC1ldnQuZGVsdGFYIDogZXZ0LmRlbHRhWDtcbiAgICAgICAgbGV0IHZpc2libGVXaWR0aDtcbiAgICAgICAgbGV0IG5ld1g7XG4gICAgICAgIGxldCBwZXJjZW50O1xuXG4gICAgICAgIHZpc2libGVXaWR0aCA9IHRoaXMuX3BhblN0YXJ0V2lkdGggKyBkZWx0YVg7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZVdpZHRoIGhpdHMgbGltaXQgLSBzdG9wIGFuaW1hdGluZ1xuICAgICAgICAgICAgaWYgKHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5MaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICh2aXNpYmxlV2lkdGggLSB0aGlzLl9wYW5MaW1pdCkgLyAodGhpcy5fcGFuU3RhcnRXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuU3RhcnRXaWR0aDtcbiAgICAgICAgICAgICAgICBuZXdYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgZGVsdGFYID4gMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmxlV2lkdGggaGl0cyBsaW1pdCAtIHN0b3AgYW5pbWF0aW5nXG4gICAgICAgICAgICBpZiAodmlzaWJsZVdpZHRoID49IHRoaXMuX3BhbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZpc2libGVXaWR0aCAtIHRoaXMuX3BhblN0YXJ0V2lkdGgpIC8gKHRoaXMuX3BhbkxpbWl0IC0gdGhpcy5fcGFuU3RhcnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgbmV3WCA9IHZpc2libGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHZpc2libGVXaWR0aCAvIHRoaXMuX3BhbkxpbWl0O1xuICAgICAgICAgICAgICAgIG5ld1ggPSAodGhpcy5fcGFuTGltaXQgLSB2aXNpYmxlV2lkdGgpICogKHJpZ2h0ID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbkVuZCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gLWV2dC5kZWx0YVggOiBldnQuZGVsdGFYO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVdpZHRoOiBudW1iZXIgPSB0aGlzLl9wYW5TdGFydFdpZHRoICsgZGVsdGFYO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwYW4gYnJvdWdodCB0aGUgZHJhd2VyIHRvIDUwJVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5TdGFydFdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA+PSB0aGlzLl9wYW5MaW1pdCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhblN0YXJ0V2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldFBhbigpIHtcbiAgICAgICAgdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKiBzdHlsZXMgZmFpbCB0byBhcHBseSB3aGVuIHNldCBvbiBwYXJlbnQgZHVlIHRvIGV4dHJhIGF0dHJpYnV0ZXMsIHByb2IgbmcgYnVnICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMub3ZlcmxheSwgJ3Bhbm5pbmcnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuZHJhd2VyLCAncGFubmluZycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRYU2l6ZSgwLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb3Igd2lkdGggaW4gY2FzZSB0aGUgZHJhd2VyIGRvZXNuJ3QgY2hhbmdlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB4IHRoZSBudW1iZXIgcGl4ZWxzIHRvIHRyYW5zbGF0ZSBvbiB0aGUgWCBheGlzIG9yIHRoZSB3aWR0aCB0byBzZXQuIDAgd2lkdGggd2lsbCBjbGVhciB0aGUgc3R5bGUgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gb3BhY2l0eSBvcHRpb25hbCB2YWx1ZSB0byBhcHBseSB0byB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0WFNpemUoeDogbnVtYmVyLCBvcGFjaXR5Pzogc3RyaW5nKSB7XG4gICAgICAgIC8vIEFuZ3VsYXIgcG9seWZpbGxzIHBhdGNoZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgYnV0IHN3aXRjaCB0byBEb21BZGFwdGVyIEFQSSAoVE9ETylcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgJ3dpZHRoJywgeCA/IE1hdGguYWJzKHgpICsgJ3B4JyA6ICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd0cmFuc2Zvcm0nLCB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJycpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICAgICAgICAgICAgICAgICAgICB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMub3ZlcmxheSwgJ29wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVPcGVuZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMub3BlbmVkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUNsb3NlZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdCgpO1xuICAgIH1cbn1cbiJdfQ==