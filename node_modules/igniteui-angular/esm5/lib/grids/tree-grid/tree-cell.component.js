/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ChangeDetectorRef, ElementRef, ViewChild, Inject } from '@angular/core';
import { IgxGridCellComponent } from '../cell.component';
import { GridBaseAPIService } from '../api.service';
import { IgxSelectionAPIService } from '../../core/selection';
import { valToPxlsUsingRange } from '../../core/utils';
import { DOCUMENT } from '@angular/common';
var IgxTreeGridCellComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxTreeGridCellComponent, _super);
    function IgxTreeGridCellComponent(gridAPI, selection, cdr, element, document) {
        var _this = _super.call(this, gridAPI, selection, cdr, element) || this;
        _this.document = document;
        _this.treeGridAPI = /** @type {?} */ (gridAPI);
        return _this;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.resolveStyleClasses = /**
     * @hidden
     * @return {?}
     */
    function () {
        return _super.prototype.resolveStyleClasses.call(this) + ' igx-grid__td--tree-cell';
    };
    Object.defineProperty(IgxTreeGridCellComponent.prototype, "indentation", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.row.treeRow.level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridCellComponent.prototype, "hasChildren", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.row.treeRow.children && this.row.treeRow.children.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridCellComponent.prototype, "expanded", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.row.expanded;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.toggle = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.treeGridAPI.trigger_row_expansion_toggle(this.gridID, this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.onIndicatorFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.gridAPI.submit_value(this.gridID);
        this.onFocus(event);
    };
    /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.calculateSizeToFit = /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    function (range) {
        var /** @type {?} */ indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        var /** @type {?} */ indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        var /** @type {?} */ indicatorMargin = parseFloat(indicatorStyle.marginRight);
        var /** @type {?} */ leftPadding = 0;
        if (this.indentationDiv) {
            var /** @type {?} */ indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        var /** @type {?} */ largestWidth = Math.max.apply(Math, tslib_1.__spread(Array.from(this.nativeElement.children)
            .map(function (child) { return valToPxlsUsingRange(range, child); })));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    };
    IgxTreeGridCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tree-grid-cell',
                    template: "<ng-template #defaultCell igxTextHighlight [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : value\" [row]=\"rowIndex\" [column]=\"this.column.visibleIndex\" [page]=\"this.grid.page\" [containerClass]=\"'igx-grid__td-text'\">\n    <ng-container *ngIf=\"column.dataType === 'boolean' || column.dataType === 'string' || formatter; else default\" >\n        <div class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : value }}</div>\n    </ng-container>\n    <ng-template #default>\n        <div class=\"igx-grid__td-text\">{{ column.dataType === 'number' ? (value | igxdecimal) : (value | igxdate) }}</div>\n    </ng-template>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group>\n            <input igxInput [(ngModel)]=\"gridAPI.get_cell_inEditMode(gridID).cell.editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group>\n            <input igxInput [(ngModel)]=\"gridAPI.get_cell_inEditMode(gridID).cell.editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox [(ngModel)]=\"gridAPI.get_cell_inEditMode(gridID).cell.editValue\" [checked]=\"gridAPI.get_cell_inEditMode(gridID).cell.editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-datePicker [(ngModel)]=\"gridAPI.get_cell_inEditMode(gridID).cell.editValue\" [labelVisibility]=\"false\"></igx-datePicker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!inEditMode\">\n    <ng-container *ngIf=\"indentation > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{indentation}}\"></div>\n    </ng-container>\n    <div #indicator class=\"igx-grid__tree-grouping-indicator\" [ngStyle]=\"{'visibility': hasChildren ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus($event)\" tabindex=\"-1\">\n        <igx-icon *ngIf=\"!expanded\" fontSet=\"material\">chevron_right</igx-icon>\n        <igx-icon *ngIf=\"expanded\" fontSet=\"material\">expand_more</igx-icon>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n"
                },] },
    ];
    /** @nocollapse */
    IgxTreeGridCellComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
        { type: IgxSelectionAPIService, },
        { type: ChangeDetectorRef, },
        { type: ElementRef, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    IgxTreeGridCellComponent.propDecorators = {
        "indicator": [{ type: ViewChild, args: ['indicator', { read: ElementRef },] },],
        "indentationDiv": [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] },],
    };
    return IgxTreeGridCellComponent;
}(IgxGridCellComponent));
export { IgxTreeGridCellComponent };
function IgxTreeGridCellComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTreeGridCellComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTreeGridCellComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxTreeGridCellComponent.propDecorators;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.treeGridAPI;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indicator;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indentationDiv;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.document;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRXpELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7SUE4Q0csb0RBQW9CO0lBRzlELGtDQUFZLE9BQWlELEVBQ2pELFNBQWlDLEVBQ2pDLEdBQXNCLEVBQ3RCLE9BQW1CLEVBQ007UUFKckMsWUFLSSxrQkFBTSxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsU0FFMUM7UUFIb0MsY0FBUSxHQUFSLFFBQVE7UUFFekMsS0FBSSxDQUFDLFdBQVcscUJBQTBCLE9BQU8sQ0FBQSxDQUFDOztLQUNyRDtJQVFEOztPQUVHOzs7OztJQUNPLHNEQUFtQjs7OztJQUE3QjtRQUNJLE1BQU0sQ0FBQyxpQkFBTSxtQkFBbUIsV0FBRSxHQUFHLDBCQUEwQixDQUFDO0tBQ25FOzBCQUtVLGlEQUFXOzs7Ozs7WUFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQzs7Ozs7MEJBTXZCLGlEQUFXOzs7Ozs7WUFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7Ozs7SUFNN0Usc0JBQUksOENBQVE7UUFIWjs7V0FFRzs7Ozs7UUFDSDtZQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztTQUM1Qjs7O09BQUE7Ozs7OztJQUtNLHlDQUFNOzs7OztjQUFDLEtBQVk7UUFDdEIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsNEJBQTRCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7OztJQU05SCxtREFBZ0I7Ozs7O2NBQUMsS0FBWTtRQUNoQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzs7Ozs7OztJQU1qQixxREFBa0I7Ozs7O2NBQUMsS0FBVTtRQUNoQyxxQkFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUM7UUFDbEYscUJBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDaEcscUJBQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDL0QscUJBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztRQUNwQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUN0QixxQkFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3ZHLFdBQVcsR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDMUQ7UUFDRCxxQkFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsT0FBUixJQUFJLG1CQUFRLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7YUFDbkUsR0FBRyxDQUFDLFVBQUMsS0FBSyxJQUFLLE9BQUEsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFqQyxDQUFpQyxDQUFDLEVBQUMsQ0FBQztRQUN4RCxNQUFNLENBQUMsWUFBWSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsV0FBVyxDQUFDOzs7Z0JBdkg1RSxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsUUFBUSxFQUFFLG8rRUF1Q2I7aUJBQ0E7Ozs7Z0JBaERRLGtCQUFrQjtnQkFDbEIsc0JBQXNCO2dCQUpYLGlCQUFpQjtnQkFBRSxVQUFVO2dEQTJEaEMsTUFBTSxTQUFDLFFBQVE7Ozs4QkFLM0IsU0FBUyxTQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7bUNBRzNDLFNBQVMsU0FBQyxnQkFBZ0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7O21DQW5FckQ7RUFvRDhDLG9CQUFvQjtTQUFyRCx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBWaWV3Q2hpbGQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUcmVlR3JpZEFQSVNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZ3JpZC1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY29yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgdmFsVG9QeGxzVXNpbmdSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9ncmlkJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdHJlZS1ncmlkLWNlbGwnLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlICNkZWZhdWx0Q2VsbCBpZ3hUZXh0SGlnaGxpZ2h0IFtjc3NDbGFzc109XCJoaWdobGlnaHRDbGFzc1wiIFthY3RpdmVDc3NDbGFzc109XCJhY3RpdmVIaWdobGlnaHRDbGFzc1wiIFtncm91cE5hbWVdPVwiZ3JpZElEXCJcbiAgICAgICAgW3ZhbHVlXT1cImZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZVwiIFtyb3ddPVwicm93SW5kZXhcIiBbY29sdW1uXT1cInRoaXMuY29sdW1uLnZpc2libGVJbmRleFwiIFtwYWdlXT1cInRoaXMuZ3JpZC5wYWdlXCIgW2NvbnRhaW5lckNsYXNzXT1cIidpZ3gtZ3JpZF9fdGQtdGV4dCdcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmRhdGFUeXBlID09PSAnYm9vbGVhbicgfHwgY29sdW1uLmRhdGFUeXBlID09PSAnc3RyaW5nJyB8fCBmb3JtYXR0ZXI7IGVsc2UgZGVmYXVsdFwiID5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190ZC10ZXh0XCI+e3sgZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlIH19PC9kaXY+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RkLXRleHRcIj57eyBjb2x1bW4uZGF0YVR5cGUgPT09ICdudW1iZXInID8gKHZhbHVlIHwgaWd4ZGVjaW1hbCkgOiAodmFsdWUgfCBpZ3hkYXRlKSB9fTwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuPG5nLXRlbXBsYXRlICNpbmxpbmVFZGl0b3IgIGxldC1jZWxsPVwiY2VsbFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uZGF0YVR5cGUgPT09ICdzdHJpbmcnXCI+XG4gICAgICAgIDxpZ3gtaW5wdXQtZ3JvdXA+XG4gICAgICAgICAgICA8aW5wdXQgaWd4SW5wdXQgWyhuZ01vZGVsKV09XCJncmlkQVBJLmdldF9jZWxsX2luRWRpdE1vZGUoZ3JpZElEKS5jZWxsLmVkaXRWYWx1ZVwiIFtpZ3hGb2N1c109XCJmb2N1c2VkXCI+XG4gICAgICAgIDwvaWd4LWlucHV0LWdyb3VwPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uZGF0YVR5cGUgPT09ICdudW1iZXInXCI+XG4gICAgICAgIDxpZ3gtaW5wdXQtZ3JvdXA+XG4gICAgICAgICAgICA8aW5wdXQgaWd4SW5wdXQgWyhuZ01vZGVsKV09XCJncmlkQVBJLmdldF9jZWxsX2luRWRpdE1vZGUoZ3JpZElEKS5jZWxsLmVkaXRWYWx1ZVwiIFtpZ3hGb2N1c109XCJmb2N1c2VkXCIgIHR5cGU9XCJudW1iZXJcIj5cbiAgICAgICAgPC9pZ3gtaW5wdXQtZ3JvdXA+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImNvbHVtbi5kYXRhVHlwZSA9PT0gJ2Jvb2xlYW4nXCI+XG4gICAgICAgIDxpZ3gtY2hlY2tib3ggWyhuZ01vZGVsKV09XCJncmlkQVBJLmdldF9jZWxsX2luRWRpdE1vZGUoZ3JpZElEKS5jZWxsLmVkaXRWYWx1ZVwiIFtjaGVja2VkXT1cImdyaWRBUEkuZ2V0X2NlbGxfaW5FZGl0TW9kZShncmlkSUQpLmNlbGwuZWRpdFZhbHVlXCIgW2Rpc2FibGVSaXBwbGVdPVwidHJ1ZVwiPjwvaWd4LWNoZWNrYm94PlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uZGF0YVR5cGUgPT09ICdkYXRlJ1wiPlxuICAgICAgICA8aWd4LWRhdGVQaWNrZXIgWyhuZ01vZGVsKV09XCJncmlkQVBJLmdldF9jZWxsX2luRWRpdE1vZGUoZ3JpZElEKS5jZWxsLmVkaXRWYWx1ZVwiIFtsYWJlbFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1kYXRlUGlja2VyPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cbjxuZy1jb250YWluZXIgKm5nSWY9XCIhaW5FZGl0TW9kZVwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpbmRlbnRhdGlvbiA+IDBcIj5cbiAgICAgICAgPGRpdiAjaW5kZW50YXRpb25EaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJlZS1jZWxsLS1wYWRkaW5nLWxldmVsLXt7aW5kZW50YXRpb259fVwiPjwvZGl2PlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxkaXYgI2luZGljYXRvciBjbGFzcz1cImlneC1ncmlkX190cmVlLWdyb3VwaW5nLWluZGljYXRvclwiIFtuZ1N0eWxlXT1cInsndmlzaWJpbGl0eSc6IGhhc0NoaWxkcmVuID8gJ3Zpc2libGUnIDogJ2hpZGRlbid9XCJcbiAgICAgICAgIChjbGljayk9XCJ0b2dnbGUoJGV2ZW50KVwiIChmb2N1cyk9XCJvbkluZGljYXRvckZvY3VzKCRldmVudClcIiB0YWJpbmRleD1cIi0xXCI+XG4gICAgICAgIDxpZ3gtaWNvbiAqbmdJZj1cIiFleHBhbmRlZFwiIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmNoZXZyb25fcmlnaHQ8L2lneC1pY29uPlxuICAgICAgICA8aWd4LWljb24gKm5nSWY9XCJleHBhbmRlZFwiIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmV4cGFuZF9tb3JlPC9pZ3gtaWNvbj5cbiAgICA8L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlOyBjb250ZXh0OiBjb250ZXh0XCI+XG48L25nLWNvbnRhaW5lcj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRDZWxsQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZENlbGxDb21wb25lbnQge1xuICAgIHByaXZhdGUgdHJlZUdyaWRBUEk6IElneFRyZWVHcmlkQVBJU2VydmljZTtcblxuICAgIGNvbnN0cnVjdG9yKGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIoZ3JpZEFQSSwgc2VsZWN0aW9uLCBjZHIsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnRyZWVHcmlkQVBJID0gPElneFRyZWVHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIEBWaWV3Q2hpbGQoJ2luZGljYXRvcicsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICAgIHB1YmxpYyBpbmRpY2F0b3I6IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCdpbmRlbnRhdGlvbkRpdicsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICAgIHB1YmxpYyBpbmRlbnRhdGlvbkRpdjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZVN0eWxlQ2xhc3NlcygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVzb2x2ZVN0eWxlQ2xhc3NlcygpICsgJyBpZ3gtZ3JpZF9fdGQtLXRyZWUtY2VsbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdy50cmVlUm93LmxldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3cudHJlZVJvdy5jaGlsZHJlbiAmJiB0aGlzLnJvdy50cmVlUm93LmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93LmV4cGFuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKGV2ZW50OiBFdmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy50cmVlR3JpZEFQSS50cmlnZ2VyX3Jvd19leHBhbnNpb25fdG9nZ2xlKHRoaXMuZ3JpZElELCB0aGlzLnJvdy50cmVlUm93LCAhdGhpcy5yb3cuZXhwYW5kZWQsIGV2ZW50LCB0aGlzLnZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkluZGljYXRvckZvY3VzKGV2ZW50OiBFdmVudCkge1xuICAgICAgICB0aGlzLmdyaWRBUEkuc3VibWl0X3ZhbHVlKHRoaXMuZ3JpZElEKTtcbiAgICAgICAgdGhpcy5vbkZvY3VzKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZVNpemVUb0ZpdChyYW5nZTogYW55KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yV2lkdGggPSB0aGlzLmluZGljYXRvci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JTdHlsZSA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmluZGljYXRvci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yTWFyZ2luID0gcGFyc2VGbG9hdChpbmRpY2F0b3JTdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgICAgIGxldCBsZWZ0UGFkZGluZyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGVudGF0aW9uRGl2KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnRhdGlvblN0eWxlID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaW5kZW50YXRpb25EaXYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IHBhcnNlRmxvYXQoaW5kZW50YXRpb25TdHlsZS5wYWRkaW5nTGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh0aGlzLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAubWFwKChjaGlsZCkgPT4gdmFsVG9QeGxzVXNpbmdSYW5nZShyYW5nZSwgY2hpbGQpKSk7XG4gICAgICAgIHJldHVybiBsYXJnZXN0V2lkdGggKyBpbmRpY2F0b3JXaWR0aCArIGluZGljYXRvck1hcmdpbiArIGxlZnRQYWRkaW5nO1xuICAgIH1cbn1cbiJdfQ==