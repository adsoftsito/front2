/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, ChangeDetectorRef, ElementRef, ViewChild, Inject } from '@angular/core';
import { IgxGridCellComponent } from '../cell.component';
import { GridBaseAPIService } from '../api.service';
import { IgxSelectionAPIService } from '../../core/selection';
import { valToPxlsUsingRange } from '../../core/utils';
import { DOCUMENT } from '@angular/common';
export class IgxTreeGridCellComponent extends IgxGridCellComponent {
    /**
     * @param {?} gridAPI
     * @param {?} selection
     * @param {?} cdr
     * @param {?} element
     * @param {?} document
     */
    constructor(gridAPI, selection, cdr, element, document) {
        super(gridAPI, selection, cdr, element);
        this.document = document;
        this.treeGridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * @hidden
     * @return {?}
     */
    resolveStyleClasses() {
        return super.resolveStyleClasses() + ' igx-grid__td--tree-cell';
    }
    /**
     * @hidden
     * @return {?}
     */
    get indentation() {
        return this.row.treeRow.level;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hasChildren() {
        return this.row.treeRow.children && this.row.treeRow.children.length > 0;
    }
    /**
     * @hidden
     * @return {?}
     */
    get expanded() {
        return this.row.expanded;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.stopPropagation();
        this.treeGridAPI.trigger_row_expansion_toggle(this.gridID, this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onIndicatorFocus(event) {
        this.gridAPI.submit_value(this.gridID);
        this.onFocus(event);
    }
    /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    calculateSizeToFit(range) {
        const /** @type {?} */ indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const /** @type {?} */ indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const /** @type {?} */ indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let /** @type {?} */ leftPadding = 0;
        if (this.indentationDiv) {
            const /** @type {?} */ indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const /** @type {?} */ largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => valToPxlsUsingRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
}
IgxTreeGridCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tree-grid-cell',
                template: `<ng-template #defaultCell igxTextHighlight [cssClass]="highlightClass" [activeCssClass]="activeHighlightClass" [groupName]="gridID"
        [value]="formatter ? formatter(value) : value" [row]="rowIndex" [column]="this.column.visibleIndex" [page]="this.grid.page" [containerClass]="'igx-grid__td-text'">
    <ng-container *ngIf="column.dataType === 'boolean' || column.dataType === 'string' || formatter; else default" >
        <div class="igx-grid__td-text">{{ formatter ? formatter(value) : value }}</div>
    </ng-container>
    <ng-template #default>
        <div class="igx-grid__td-text">{{ column.dataType === 'number' ? (value | igxdecimal) : (value | igxdate) }}</div>
    </ng-template>
</ng-template>
<ng-template #inlineEditor  let-cell="cell">
    <ng-container *ngIf="column.dataType === 'string'">
        <igx-input-group>
            <input igxInput [(ngModel)]="gridAPI.get_cell_inEditMode(gridID).cell.editValue" [igxFocus]="focused">
        </igx-input-group>
    </ng-container>
    <ng-container *ngIf="column.dataType === 'number'">
        <igx-input-group>
            <input igxInput [(ngModel)]="gridAPI.get_cell_inEditMode(gridID).cell.editValue" [igxFocus]="focused"  type="number">
        </igx-input-group>
    </ng-container>
    <ng-container *ngIf="column.dataType === 'boolean'">
        <igx-checkbox [(ngModel)]="gridAPI.get_cell_inEditMode(gridID).cell.editValue" [checked]="gridAPI.get_cell_inEditMode(gridID).cell.editValue" [disableRipple]="true"></igx-checkbox>
    </ng-container>
    <ng-container *ngIf="column.dataType === 'date'">
        <igx-datePicker [(ngModel)]="gridAPI.get_cell_inEditMode(gridID).cell.editValue" [labelVisibility]="false"></igx-datePicker>
    </ng-container>
</ng-template>
<ng-container *ngIf="!inEditMode">
    <ng-container *ngIf="indentation > 0">
        <div #indentationDiv class="igx-grid__tree-cell--padding-level-{{indentation}}"></div>
    </ng-container>
    <div #indicator class="igx-grid__tree-grouping-indicator" [ngStyle]="{'visibility': hasChildren ? 'visible' : 'hidden'}"
         (click)="toggle($event)" (focus)="onIndicatorFocus($event)" tabindex="-1">
        <igx-icon *ngIf="!expanded" fontSet="material">chevron_right</igx-icon>
        <igx-icon *ngIf="expanded" fontSet="material">expand_more</igx-icon>
    </div>
</ng-container>
<ng-container *ngTemplateOutlet="template; context: context">
</ng-container>
`
            },] },
];
/** @nocollapse */
IgxTreeGridCellComponent.ctorParameters = () => [
    { type: GridBaseAPIService, },
    { type: IgxSelectionAPIService, },
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
];
IgxTreeGridCellComponent.propDecorators = {
    "indicator": [{ type: ViewChild, args: ['indicator', { read: ElementRef },] },],
    "indentationDiv": [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] },],
};
function IgxTreeGridCellComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTreeGridCellComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTreeGridCellComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxTreeGridCellComponent.propDecorators;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.treeGridAPI;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indicator;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indentationDiv;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.document;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFekQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBOEMzQyxNQUFNLCtCQUFnQyxTQUFRLG9CQUFvQjs7Ozs7Ozs7SUFHOUQsWUFBWSxPQUFpRCxFQUNqRCxTQUFpQyxFQUNqQyxHQUFzQixFQUN0QixPQUFtQixFQUNNO1FBQ2pDLEtBQUssQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQURQLGFBQVEsR0FBUixRQUFRO1FBRXpDLElBQUksQ0FBQyxXQUFXLHFCQUEwQixPQUFPLENBQUEsQ0FBQztLQUNyRDs7Ozs7SUFXUyxtQkFBbUI7UUFDekIsTUFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLDBCQUEwQixDQUFDO0tBQ25FOzs7OztRQUtVLFdBQVc7UUFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQzs7Ozs7O1FBTXZCLFdBQVc7UUFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7Ozs7O0lBTTdFLElBQUksUUFBUTtRQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztLQUM1Qjs7Ozs7O0lBS00sTUFBTSxDQUFDLEtBQVk7UUFDdEIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsNEJBQTRCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7OztJQU05SCxnQkFBZ0IsQ0FBQyxLQUFZO1FBQ2hDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7Ozs7O0lBTWpCLGtCQUFrQixDQUFDLEtBQVU7UUFDaEMsdUJBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxDQUFDO1FBQ2xGLHVCQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ2hHLHVCQUFNLGVBQWUsR0FBRyxVQUFVLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQy9ELHFCQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDcEIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsdUJBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUN2RyxXQUFXLEdBQUcsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQzFEO1FBQ0QsdUJBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO2FBQ25FLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RCxNQUFNLENBQUMsWUFBWSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsV0FBVyxDQUFDOzs7O1lBdkg1RSxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1Q2I7YUFDQTs7OztZQWhEUSxrQkFBa0I7WUFDbEIsc0JBQXNCO1lBSlgsaUJBQWlCO1lBQUUsVUFBVTs0Q0EyRGhDLE1BQU0sU0FBQyxRQUFROzs7MEJBSzNCLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFOytCQUczQyxTQUFTLFNBQUMsZ0JBQWdCLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgVmlld0NoaWxkLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWdyaWQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4U2VsZWN0aW9uQVBJU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvc2VsZWN0aW9uJztcbmltcG9ydCB7IHZhbFRvUHhsc1VzaW5nUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ3JpZCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZC1jZWxsJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZSAjZGVmYXVsdENlbGwgaWd4VGV4dEhpZ2hsaWdodCBbY3NzQ2xhc3NdPVwiaGlnaGxpZ2h0Q2xhc3NcIiBbYWN0aXZlQ3NzQ2xhc3NdPVwiYWN0aXZlSGlnaGxpZ2h0Q2xhc3NcIiBbZ3JvdXBOYW1lXT1cImdyaWRJRFwiXG4gICAgICAgIFt2YWx1ZV09XCJmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIodmFsdWUpIDogdmFsdWVcIiBbcm93XT1cInJvd0luZGV4XCIgW2NvbHVtbl09XCJ0aGlzLmNvbHVtbi52aXNpYmxlSW5kZXhcIiBbcGFnZV09XCJ0aGlzLmdyaWQucGFnZVwiIFtjb250YWluZXJDbGFzc109XCInaWd4LWdyaWRfX3RkLXRleHQnXCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImNvbHVtbi5kYXRhVHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IGNvbHVtbi5kYXRhVHlwZSA9PT0gJ3N0cmluZycgfHwgZm9ybWF0dGVyOyBlbHNlIGRlZmF1bHRcIiA+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGQtdGV4dFwiPnt7IGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSB9fTwvZGl2PlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190ZC10ZXh0XCI+e3sgY29sdW1uLmRhdGFUeXBlID09PSAnbnVtYmVyJyA/ICh2YWx1ZSB8IGlneGRlY2ltYWwpIDogKHZhbHVlIHwgaWd4ZGF0ZSkgfX08L2Rpdj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cbjxuZy10ZW1wbGF0ZSAjaW5saW5lRWRpdG9yICBsZXQtY2VsbD1cImNlbGxcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmRhdGFUeXBlID09PSAnc3RyaW5nJ1wiPlxuICAgICAgICA8aWd4LWlucHV0LWdyb3VwPlxuICAgICAgICAgICAgPGlucHV0IGlneElucHV0IFsobmdNb2RlbCldPVwiZ3JpZEFQSS5nZXRfY2VsbF9pbkVkaXRNb2RlKGdyaWRJRCkuY2VsbC5lZGl0VmFsdWVcIiBbaWd4Rm9jdXNdPVwiZm9jdXNlZFwiPlxuICAgICAgICA8L2lneC1pbnB1dC1ncm91cD5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmRhdGFUeXBlID09PSAnbnVtYmVyJ1wiPlxuICAgICAgICA8aWd4LWlucHV0LWdyb3VwPlxuICAgICAgICAgICAgPGlucHV0IGlneElucHV0IFsobmdNb2RlbCldPVwiZ3JpZEFQSS5nZXRfY2VsbF9pbkVkaXRNb2RlKGdyaWRJRCkuY2VsbC5lZGl0VmFsdWVcIiBbaWd4Rm9jdXNdPVwiZm9jdXNlZFwiICB0eXBlPVwibnVtYmVyXCI+XG4gICAgICAgIDwvaWd4LWlucHV0LWdyb3VwPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uZGF0YVR5cGUgPT09ICdib29sZWFuJ1wiPlxuICAgICAgICA8aWd4LWNoZWNrYm94IFsobmdNb2RlbCldPVwiZ3JpZEFQSS5nZXRfY2VsbF9pbkVkaXRNb2RlKGdyaWRJRCkuY2VsbC5lZGl0VmFsdWVcIiBbY2hlY2tlZF09XCJncmlkQVBJLmdldF9jZWxsX2luRWRpdE1vZGUoZ3JpZElEKS5jZWxsLmVkaXRWYWx1ZVwiIFtkaXNhYmxlUmlwcGxlXT1cInRydWVcIj48L2lneC1jaGVja2JveD5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmRhdGFUeXBlID09PSAnZGF0ZSdcIj5cbiAgICAgICAgPGlneC1kYXRlUGlja2VyIFsobmdNb2RlbCldPVwiZ3JpZEFQSS5nZXRfY2VsbF9pbkVkaXRNb2RlKGdyaWRJRCkuY2VsbC5lZGl0VmFsdWVcIiBbbGFiZWxWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtZGF0ZVBpY2tlcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG48bmctY29udGFpbmVyICpuZ0lmPVwiIWluRWRpdE1vZGVcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaW5kZW50YXRpb24gPiAwXCI+XG4gICAgICAgIDxkaXYgI2luZGVudGF0aW9uRGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyZWUtY2VsbC0tcGFkZGluZy1sZXZlbC17e2luZGVudGF0aW9ufX1cIj48L2Rpdj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8ZGl2ICNpbmRpY2F0b3IgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJlZS1ncm91cGluZy1pbmRpY2F0b3JcIiBbbmdTdHlsZV09XCJ7J3Zpc2liaWxpdHknOiBoYXNDaGlsZHJlbiA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nfVwiXG4gICAgICAgICAoY2xpY2spPVwidG9nZ2xlKCRldmVudClcIiAoZm9jdXMpPVwib25JbmRpY2F0b3JGb2N1cygkZXZlbnQpXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgICA8aWd4LWljb24gKm5nSWY9XCIhZXhwYW5kZWRcIiBmb250U2V0PVwibWF0ZXJpYWxcIj5jaGV2cm9uX3JpZ2h0PC9pZ3gtaWNvbj5cbiAgICAgICAgPGlneC1pY29uICpuZ0lmPVwiZXhwYW5kZWRcIiBmb250U2V0PVwibWF0ZXJpYWxcIj5leHBhbmRfbW9yZTwvaWd4LWljb24+XG4gICAgPC9kaXY+XG48L25nLWNvbnRhaW5lcj5cbjxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZTsgY29udGV4dDogY29udGV4dFwiPlxuPC9uZy1jb250YWluZXI+XG5gXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkQ2VsbENvbXBvbmVudCBleHRlbmRzIElneEdyaWRDZWxsQ29tcG9uZW50IHtcbiAgICBwcml2YXRlIHRyZWVHcmlkQVBJOiBJZ3hUcmVlR3JpZEFQSVNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQ+LFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogSWd4U2VsZWN0aW9uQVBJU2VydmljZSxcbiAgICAgICAgICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKGdyaWRBUEksIHNlbGVjdGlvbiwgY2RyLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy50cmVlR3JpZEFQSSA9IDxJZ3hUcmVlR3JpZEFQSVNlcnZpY2U+Z3JpZEFQSTtcbiAgICB9XG5cbiAgICBAVmlld0NoaWxkKCdpbmRpY2F0b3InLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgaW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZCgnaW5kZW50YXRpb25EaXYnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgaW5kZW50YXRpb25EaXY6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVTdHlsZUNsYXNzZXMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlc29sdmVTdHlsZUNsYXNzZXMoKSArICcgaWd4LWdyaWRfX3RkLS10cmVlLWNlbGwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGluZGVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3cudHJlZVJvdy5sZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93LnRyZWVSb3cuY2hpbGRyZW4gJiYgdGhpcy5yb3cudHJlZVJvdy5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdy5leHBhbmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZShldmVudDogRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMudHJlZUdyaWRBUEkudHJpZ2dlcl9yb3dfZXhwYW5zaW9uX3RvZ2dsZSh0aGlzLmdyaWRJRCwgdGhpcy5yb3cudHJlZVJvdywgIXRoaXMucm93LmV4cGFuZGVkLCBldmVudCwgdGhpcy52aXNpYmxlQ29sdW1uSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25JbmRpY2F0b3JGb2N1cyhldmVudDogRXZlbnQpIHtcbiAgICAgICAgdGhpcy5ncmlkQVBJLnN1Ym1pdF92YWx1ZSh0aGlzLmdyaWRJRCk7XG4gICAgICAgIHRoaXMub25Gb2N1cyhldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVTaXplVG9GaXQocmFuZ2U6IGFueSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGluZGljYXRvcldpZHRoID0gdGhpcy5pbmRpY2F0b3IubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yU3R5bGUgPSB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5pbmRpY2F0b3IubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGluZGljYXRvck1hcmdpbiA9IHBhcnNlRmxvYXQoaW5kaWNhdG9yU3R5bGUubWFyZ2luUmlnaHQpO1xuICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAwO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnRhdGlvbkRpdikge1xuICAgICAgICAgICAgY29uc3QgaW5kZW50YXRpb25TdHlsZSA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmluZGVudGF0aW9uRGl2Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgbGVmdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGluZGVudGF0aW9uU3R5bGUucGFkZGluZ0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KC4uLkFycmF5LmZyb20odGhpcy5uYXRpdmVFbGVtZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgLm1hcCgoY2hpbGQpID0+IHZhbFRvUHhsc1VzaW5nUmFuZ2UocmFuZ2UsIGNoaWxkKSkpO1xuICAgICAgICByZXR1cm4gbGFyZ2VzdFdpZHRoICsgaW5kaWNhdG9yV2lkdGggKyBpbmRpY2F0b3JNYXJnaW4gKyBsZWZ0UGFkZGluZztcbiAgICB9XG59XG4iXX0=