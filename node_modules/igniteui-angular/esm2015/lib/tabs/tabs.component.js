/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, forwardRef, HostBinding, HostListener, Input, NgModule, Output, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { IgxBadgeModule } from '../badge/badge.component';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxIconModule } from '../icon/index';
import { IgxTabItemComponent } from './tab-item.component';
import { IgxTabsGroupComponent } from './tabs-group.component';
import { IgxLeftButtonStyleDirective, IgxRightButtonStyleDirective, IgxTabItemTemplateDirective } from './tabs.directives';
/** @enum {string} */
const TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
export { TabsType };
export class IgxTabsComponent {
    /**
     * @param {?} _element
     */
    constructor(_element) {
        this._element = _element;
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * An \@Input property that sets the value of the `selectedIndex`.
         * Default value is 0.
         * ```html
         * <igx-tabs selectedIndex="1">
         * ```
         */
        this.selectedIndex = 0;
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
    }
    /**
     * @hidden
     * @return {?}
     */
    get class() {
        const /** @type {?} */ defaultStyle = `igx-tabs`;
        const /** @type {?} */ fixedStyle = `igx-tabs--fixed`;
        const /** @type {?} */ iconStyle = `igx-tabs--icons`;
        const /** @type {?} */ iconLabelFound = this.groups.find((group) => group.icon != null && group.label != null);
        let /** @type {?} */ css;
        switch (TabsType[this.tabsType.toUpperCase()]) {
            case TabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFound !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return css;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollLeft(event) {
        this._scroll(false);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    scrollRight(event) {
        this._scroll(true);
    }
    /**
     * @param {?} scrollRight
     * @return {?}
     */
    _scroll(scrollRight) {
        const /** @type {?} */ tabsArray = this.tabs.toArray();
        for (const /** @type {?} */ tab of tabsArray) {
            const /** @type {?} */ element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    scrollElement(element, scrollRight) {
        requestAnimationFrame(() => {
            const /** @type {?} */ viewPortWidth = this.viewPort.nativeElement.offsetWidth;
            this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
            this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
        });
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     * @return {?}
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => {
            if (this.selectedIndex <= 0 || this.selectedIndex >= this.groups.length) {
                // if nothing is selected - select the first tabs group
                this._selectGroupByIndex(0);
            }
            else {
                this._selectGroupByIndex(this.selectedIndex);
            }
        });
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    resetSelectionOnCollectionChanged() {
        setTimeout(() => {
            if (this.groups.toArray()[this.selectedIndex] !== undefined) {
                // persist the selected index and applied it to the new collection
                this._selectGroupByIndex(this.selectedIndex);
            }
            else {
                if (this.selectedIndex >= this.groups.length) {
                    // in case the selected index is no longer valid, select the last group in the new collection
                    this._selectGroupByIndex(this.groups.length - 1);
                }
            }
        }, 0);
    }
    /**
     * @param {?} selectedIndex
     * @return {?}
     */
    _selectGroupByIndex(selectedIndex) {
        const /** @type {?} */ selectableGroups = this.groups.filter((selectableGroup) => !selectableGroup.disabled);
        const /** @type {?} */ group = selectableGroups[selectedIndex];
        if (group) {
            group.select(0);
        }
    }
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    _selectedGroupHandler(args) {
        const /** @type {?} */ prevSelectedIndex = this.selectedIndex;
        if (prevSelectedIndex !== -1 && this.groups.toArray()[prevSelectedIndex] !== undefined) {
            this.onTabItemDeselected.emit({
                tab: this.groups.toArray()[prevSelectedIndex].relatedTab,
                group: this.groups.toArray()[prevSelectedIndex]
            });
        }
        this.selectedIndex = args.group.index;
        this.groups.forEach((p) => {
            if (p.index !== this.selectedIndex) {
                this._deselectGroup(p);
            }
        });
    }
    /**
     * @param {?} group
     * @return {?}
     */
    _deselectGroup(group) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (group.disabled || this.selectedTabItem.index === group.index) {
            return;
        }
        group.isSelected = false;
        group.relatedTab.tabindex = -1;
    }
}
IgxTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tabs',
                template: `<!-- TODO Remove tab container from here -->
<div #tabsContainer>
    <div class="igx-tabs__header" #headerContainer>
        <button igxRipple class="igx-tabs__header-button" igxButton="icon" (click)="scrollLeft($event)" igxLeftButtonStyle>
            <igx-icon fontSet="material">navigate_before</igx-icon>
        </button>
        <div class="igx-tabs__header-wrapper-fixed" #viewPort>
            <div #itemsContainer class="igx-tabs__header-wrapper-fluid">
                <igx-tab-item igxRipple *ngFor="let group of groups" [id]="'igx-tab-item-' + group.index" [attr.aria-label]="group.label"
                    [attr.aria-disabled]="group.disabled" [attr.aria-selected]="group.isSelected" [attr.aria-controls]="'igx-tab-item-group-'+ group.index"
                    [ngClass]="{
                'igx-tabs__header-menu-item': !group.isSelected && !group.disabled,
                'igx-tabs__header-menu-item--selected': group.isSelected,
                'igx-tabs__header-menu-item--disabled': group.disabled }" [relatedGroup]="group" role="tab">
                </igx-tab-item>
                <div #selectedIndicator *ngIf="groups.length > 0" class="igx-tabs__header-menu-item-indicator"></div>
            </div>
        </div>
        <button igxRipple class="igx-tabs__header-button" igxButton="icon" (click)="scrollRight($event)" igxRightButtonStyle>
            <igx-icon fontSet="material">navigate_next</igx-icon>
        </button>
    </div>
    <div class="igx-tabs__content-fixed">
        <div #contentsContainer class="igx-tabs__content-fluid">
            <ng-content></ng-content>
        </div>
    </div>
</div>`
            },] },
];
/** @nocollapse */
IgxTabsComponent.ctorParameters = () => [
    { type: ElementRef, },
];
IgxTabsComponent.propDecorators = {
    "tabs": [{ type: ViewChildren, args: [forwardRef(() => IgxTabItemComponent),] },],
    "groups": [{ type: ContentChildren, args: [forwardRef(() => IgxTabsGroupComponent),] },],
    "tabsType": [{ type: Input, args: ['tabsType',] },],
    "selectedIndex": [{ type: Input },],
    "onTabItemSelected": [{ type: Output },],
    "onTabItemDeselected": [{ type: Output },],
    "tabsContainer": [{ type: ViewChild, args: ['tabsContainer',] },],
    "headerContainer": [{ type: ViewChild, args: ['headerContainer',] },],
    "itemsContainer": [{ type: ViewChild, args: ['itemsContainer',] },],
    "contentsContainer": [{ type: ViewChild, args: ['contentsContainer',] },],
    "selectedIndicator": [{ type: ViewChild, args: ['selectedIndicator',] },],
    "viewPort": [{ type: ViewChild, args: ['viewPort',] },],
    "class": [{ type: HostBinding, args: ['attr.class',] },],
    "_selectedGroupHandler": [{ type: HostListener, args: ['onTabItemSelected', ['$event'],] },],
};
function IgxTabsComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTabsComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTabsComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxTabsComponent.propDecorators;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.tabs;
    /**
     * Provides an observable collection of all `IgxTabsGroupComponent`s.
     * ```typescript
     * const groupItems = this.myTabComponent.tabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.groups;
    /**
     * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
     * By default the header sizing mode is `contentfit`.
     * ```html
     * <igx-tabs tabsType="fixed">
     *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
     * </igx-tabs>
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsType;
    /**
     * An \@Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndex;
    /**
     * Emitted when a tab item is selected.
     * ```html
     * <igx-tabs (onTabItemSelected)="itemSelected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemSelected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemSelected;
    /**
     * Emitted when a tab item is deselected.
     * ```html
     * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemDeselected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemDeselected;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.headerContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.itemsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.contentsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndicator;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.viewPort;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.calculatedWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.visibleItemsWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.offset;
    /** @type {?} */
    IgxTabsComponent.prototype._groupChanges$;
    /** @type {?} */
    IgxTabsComponent.prototype._element;
}
/**
 * The IgxTabsModule provides the {\@link IgxTabsComponent}, {\@link IgxTabsGroupComponent},
 * {\@link IgxTabItemComponent}, {\@link IgxTabItemTemplateDirective}, {\@link IgxRightButtonStyleDirective}
 * and {\@link IgxLeftButtonStyleDirective} inside your application.
 */
export class IgxTabsModule {
}
IgxTabsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            },] },
];
function IgxTabsModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTabsModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTabsModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3RhYnMvdGFicy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBRUgsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUVmLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5QyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsNEJBQTRCLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7O1dBRy9HLE9BQU87Z0JBQ0YsWUFBWTs7O0FBbUM3QixNQUFNOzs7O0lBdU5GLFlBQW9CLFFBQW9CO1FBQXBCLGFBQVEsR0FBUixRQUFRLENBQVk7Ozs7Ozs7Ozs7d0JBekxILFlBQVk7Ozs7Ozs7OzZCQVUxQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O2lDQWlCYSxJQUFJLFlBQVksRUFBRTs7Ozs7Ozs7Ozs7Ozs7OzttQ0FpQmhCLElBQUksWUFBWSxFQUFFOzs7O3NCQWdGekMsQ0FBQztLQThEaEI7Ozs7O1FBcEdVLEtBQUs7UUFDWix1QkFBTSxZQUFZLEdBQUcsVUFBVSxD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LENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURqRCxNQUFNOzs7WUFoQkwsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRSxDQUFDLGdCQUFnQjtvQkFDM0IscUJBQXFCO29CQUNyQixtQkFBbUI7b0JBQ25CLDJCQUEyQjtvQkFDM0IsNEJBQTRCO29CQUM1QiwyQkFBMkIsQ0FBQztnQkFDaEMsT0FBTyxFQUFFLENBQUMsZ0JBQWdCO29CQUN0QixxQkFBcUI7b0JBQ3JCLG1CQUFtQjtvQkFDbkIsMkJBQTJCO29CQUMzQiw0QkFBNEI7b0JBQzVCLDJCQUEyQixDQUFDO2dCQUNoQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBRSxlQUFlLENBQUM7YUFDMUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0NoaWxkcmVuLFxuICAgIE9uRGVzdHJveVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSWd4QmFkZ2VNb2R1bGUgfSBmcm9tICcuLi9iYWRnZS9iYWRnZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UmlwcGxlTW9kdWxlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9yaXBwbGUvcmlwcGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9pbmRleCc7XG5pbXBvcnQgeyBJZ3hUYWJJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi90YWItaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VGFic0dyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi90YWJzLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmUsIElneFJpZ2h0QnV0dG9uU3R5bGVEaXJlY3RpdmUsIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vdGFicy5kaXJlY3RpdmVzJztcblxuZXhwb3J0IGVudW0gVGFic1R5cGUge1xuICAgIEZJWEVEID0gJ2ZpeGVkJyxcbiAgICBDT05URU5URklUID0gJ2NvbnRlbnRmaXQnXG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRhYnMnLFxuICAgIHRlbXBsYXRlOiBgPCEtLSBUT0RPIFJlbW92ZSB0YWIgY29udGFpbmVyIGZyb20gaGVyZSAtLT5cbjxkaXYgI3RhYnNDb250YWluZXI+XG4gICAgPGRpdiBjbGFzcz1cImlneC10YWJzX19oZWFkZXJcIiAjaGVhZGVyQ29udGFpbmVyPlxuICAgICAgICA8YnV0dG9uIGlneFJpcHBsZSBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYnV0dG9uXCIgaWd4QnV0dG9uPVwiaWNvblwiIChjbGljayk9XCJzY3JvbGxMZWZ0KCRldmVudClcIiBpZ3hMZWZ0QnV0dG9uU3R5bGU+XG4gICAgICAgICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+bmF2aWdhdGVfYmVmb3JlPC9pZ3gtaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLXdyYXBwZXItZml4ZWRcIiAjdmlld1BvcnQ+XG4gICAgICAgICAgICA8ZGl2ICNpdGVtc0NvbnRhaW5lciBjbGFzcz1cImlneC10YWJzX19oZWFkZXItd3JhcHBlci1mbHVpZFwiPlxuICAgICAgICAgICAgICAgIDxpZ3gtdGFiLWl0ZW0gaWd4UmlwcGxlICpuZ0Zvcj1cImxldCBncm91cCBvZiBncm91cHNcIiBbaWRdPVwiJ2lneC10YWItaXRlbS0nICsgZ3JvdXAuaW5kZXhcIiBbYXR0ci5hcmlhLWxhYmVsXT1cImdyb3VwLmxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJncm91cC5kaXNhYmxlZFwiIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiZ3JvdXAuaXNTZWxlY3RlZFwiIFthdHRyLmFyaWEtY29udHJvbHNdPVwiJ2lneC10YWItaXRlbS1ncm91cC0nKyBncm91cC5pbmRleFwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1tZW51LWl0ZW0nOiAhZ3JvdXAuaXNTZWxlY3RlZCAmJiAhZ3JvdXAuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItbWVudS1pdGVtLS1zZWxlY3RlZCc6IGdyb3VwLmlzU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItbWVudS1pdGVtLS1kaXNhYmxlZCc6IGdyb3VwLmRpc2FibGVkIH1cIiBbcmVsYXRlZEdyb3VwXT1cImdyb3VwXCIgcm9sZT1cInRhYlwiPlxuICAgICAgICAgICAgICAgIDwvaWd4LXRhYi1pdGVtPlxuICAgICAgICAgICAgICAgIDxkaXYgI3NlbGVjdGVkSW5kaWNhdG9yICpuZ0lmPVwiZ3JvdXBzLmxlbmd0aCA+IDBcIiBjbGFzcz1cImlneC10YWJzX19oZWFkZXItbWVudS1pdGVtLWluZGljYXRvclwiPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uIGlneFJpcHBsZSBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYnV0dG9uXCIgaWd4QnV0dG9uPVwiaWNvblwiIChjbGljayk9XCJzY3JvbGxSaWdodCgkZXZlbnQpXCIgaWd4UmlnaHRCdXR0b25TdHlsZT5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5uYXZpZ2F0ZV9uZXh0PC9pZ3gtaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC10YWJzX19jb250ZW50LWZpeGVkXCI+XG4gICAgICAgIDxkaXYgI2NvbnRlbnRzQ29udGFpbmVyIGNsYXNzPVwiaWd4LXRhYnNfX2NvbnRlbnQtZmx1aWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4VGFic0NvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgYWxsIGBJZ3hUYWJJdGVtQ29tcG9uZW50YHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC50YWJzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJJdGVtQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgdGFiczogUXVlcnlMaXN0PElneFRhYkl0ZW1Db21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFic0dyb3VwQ29tcG9uZW50YHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50LnRhYnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IElneFRhYnNHcm91cENvbXBvbmVudCkpXG4gICAgcHVibGljIGdyb3VwczogUXVlcnlMaXN0PElneFRhYnNHcm91cENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0YWIgaGVhZGVyIHNpemluZyBtb2RlLiBZb3UgY2FuIGNob29zZSBiZXR3ZWVuIGBjb250ZW50Zml0YCBvciBgZml4ZWRgLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGhlYWRlciBzaXppbmcgbW9kZSBpcyBgY29udGVudGZpdGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdGFicyB0YWJzVHlwZT1cImZpeGVkXCI+XG4gICAgICogICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIkhPTUVcIj5Ib21lPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiA8L2lneC10YWJzPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgndGFic1R5cGUnKVxuICAgIHB1YmxpYyB0YWJzVHlwZTogc3RyaW5nIHwgVGFic1R5cGUgPSAnY29udGVudGZpdCc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHNlbGVjdGVkSW5kZXhgLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIHNlbGVjdGVkSW5kZXg9XCIxXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWRJbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSB0YWIgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIChvblRhYkl0ZW1TZWxlY3RlZCk9XCJpdGVtU2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDFcIj5UaGlzIGlzIFRhYiAxIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAyXCI+VGhpcyBpcyBUYWIgMiBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogPC9pZ3gtdGFicz5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaXRlbVNlbGVjdGVkKGUpe1xuICAgICAqICAgICAgY29uc3QgdGFiR3JvdXAgPSBlLmdyb3VwO1xuICAgICAqICAgICAgY29uc3QgdGFiSXRlbSA9IGUudGFiO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIG9uVGFiSXRlbVNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgdGFiIGl0ZW0gaXMgZGVzZWxlY3RlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIChvblRhYkl0ZW1EZXNlbGVjdGVkKT1cIml0ZW1EZXNlbGVjdGVkKCRldmVudClcIj5cbiAgICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAxXCI+VGhpcyBpcyBUYWIgMSBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMlwiPlRoaXMgaXMgVGFiIDIgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICAqIDwvaWd4LXRhYnM+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGl0ZW1EZXNlbGVjdGVkKGUpe1xuICAgICAqICAgICAgY29uc3QgdGFiR3JvdXAgPSBlLmdyb3VwO1xuICAgICAqICAgICAgY29uc3QgdGFiSXRlbSA9IGUudGFiO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIG9uVGFiSXRlbURlc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgndGFic0NvbnRhaW5lcicpXG4gICAgcHVibGljIHRhYnNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaGVhZGVyQ29udGFpbmVyJylcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zQ29udGFpbmVyJylcbiAgICBwdWJsaWMgaXRlbXNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnY29udGVudHNDb250YWluZXInKVxuICAgIHB1YmxpYyBjb250ZW50c0NvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzZWxlY3RlZEluZGljYXRvcicpXG4gICAgcHVibGljIHNlbGVjdGVkSW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JylcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmNsYXNzJylcbiAgICBwdWJsaWMgZ2V0IGNsYXNzKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBgaWd4LXRhYnNgO1xuICAgICAgICBjb25zdCBmaXhlZFN0eWxlID0gYGlneC10YWJzLS1maXhlZGA7XG4gICAgICAgIGNvbnN0IGljb25TdHlsZSA9IGBpZ3gtdGFicy0taWNvbnNgO1xuICAgICAgICBjb25zdCBpY29uTGFiZWxGb3VuZCA9IHRoaXMuZ3JvdXBzLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pY29uICE9IG51bGwgJiYgZ3JvdXAubGFiZWwgIT0gbnVsbCk7XG4gICAgICAgIGxldCBjc3M7XG4gICAgICAgIHN3aXRjaCAoVGFic1R5cGVbdGhpcy50YWJzVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgICAgY2FzZSBUYWJzVHlwZS5GSVhFRDoge1xuICAgICAgICAgICAgICAgIGNzcyA9IGZpeGVkU3R5bGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY3NzID0gZGVmYXVsdFN0eWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGF5b3V0IGZpeCBmb3IgaXRlbXMgd2l0aCBpY29uc1xuICAgICAgICBpZiAoaWNvbkxhYmVsRm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3NzID0gYCR7Y3NzfSAke2ljb25TdHlsZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB2aXNpYmxlSXRlbXNXaWR0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBDaGFuZ2VzJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxMZWZ0KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxSaWdodChldmVudCkge1xuICAgICAgICB0aGlzLl9zY3JvbGwodHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2Nyb2xsKHNjcm9sbFJpZ2h0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhYnNBcnJheSA9IHRoaXMudGFicy50b0FycmF5KCk7XG4gICAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnNBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRhYi5uYXRpdmVUYWJJdGVtLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCA+IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbGVtZW50LCBzY3JvbGxSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyBlbGVtZW50Lm9mZnNldExlZnQgPj0gdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGVsZW1lbnQsIHNjcm9sbFJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbEVsZW1lbnQoZWxlbWVudDogYW55LCBzY3JvbGxSaWdodDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsUmlnaHQpID8gZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdQb3J0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICB0aGlzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkey10aGlzLm9mZnNldH1weClgO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZWxlY3RlZCBgSWd4VGFiSXRlbUNvbXBvbmVudGAuXG4gICAgICogYGBgXG4gICAgICogY29uc3Qgc2VsZWN0ZWRJdGVtID0gdGhpcy5teVRhYkNvbXBvbmVudC5zZWxlY3RlZFRhYkl0ZW07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkVGFiSXRlbSgpOiBJZ3hUYWJJdGVtQ29tcG9uZW50IHtcbiAgICAgICAgaWYgKHRoaXMudGFicyAmJiB0aGlzLnNlbGVjdGVkSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFicy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDw9IDAgfHwgdGhpcy5zZWxlY3RlZEluZGV4ID49IHRoaXMuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWQgLSBzZWxlY3QgdGhlIGZpcnN0IHRhYnMgZ3JvdXBcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RHcm91cEJ5SW5kZXgoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEdyb3VwQnlJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ncm91cENoYW5nZXMkID0gdGhpcy5ncm91cHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk9uQ29sbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwQ2hhbmdlcyQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25PbkNvbGxlY3Rpb25DaGFuZ2VkKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3Vwcy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVyc2lzdCB0aGUgc2VsZWN0ZWQgaW5kZXggYW5kIGFwcGxpZWQgaXQgdG8gdGhlIG5ldyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0R3JvdXBCeUluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHNlbGVjdGVkIGluZGV4IGlzIG5vIGxvbmdlciB2YWxpZCwgc2VsZWN0IHRoZSBsYXN0IGdyb3VwIGluIHRoZSBuZXcgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RHcm91cEJ5SW5kZXgodGhpcy5ncm91cHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZWxlY3RHcm91cEJ5SW5kZXgoc2VsZWN0ZWRJbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGVHcm91cHMgPSB0aGlzLmdyb3Vwcy5maWx0ZXIoKHNlbGVjdGFibGVHcm91cCkgPT4gIXNlbGVjdGFibGVHcm91cC5kaXNhYmxlZCk7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gc2VsZWN0YWJsZUdyb3Vwc1tzZWxlY3RlZEluZGV4XTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLnNlbGVjdCgwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdvblRhYkl0ZW1TZWxlY3RlZCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIF9zZWxlY3RlZEdyb3VwSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICBpZiAocHJldlNlbGVjdGVkSW5kZXggIT09IC0xICYmIHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtwcmV2U2VsZWN0ZWRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vblRhYkl0ZW1EZXNlbGVjdGVkLmVtaXQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YWI6IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtwcmV2U2VsZWN0ZWRJbmRleF0ucmVsYXRlZFRhYixcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtwcmV2U2VsZWN0ZWRJbmRleF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGFyZ3MuZ3JvdXAuaW5kZXg7XG4gICAgICAgIHRoaXMuZ3JvdXBzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICAgIGlmIChwLmluZGV4ICE9PSB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNlbGVjdEdyb3VwKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kZXNlbGVjdEdyb3VwKGdyb3VwOiBJZ3hUYWJzR3JvdXBDb21wb25lbnQpIHtcbiAgICAgICAgLy8gQ2Fubm90IGRlc2VsZWN0IHRoZSBzZWxlY3RlZCB0YWIgLSB0aGlzIHdpbGwgbWVhbiB0aGF0IHRoZXJlIHdpbGwgYmUgbm90IHNlbGVjdGVkIHRhYiBsZWZ0XG4gICAgICAgIGlmIChncm91cC5kaXNhYmxlZCB8fCB0aGlzLnNlbGVjdGVkVGFiSXRlbS5pbmRleCA9PT0gZ3JvdXAuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZ3JvdXAucmVsYXRlZFRhYi50YWJpbmRleCA9IC0xO1xuICAgIH1cbn1cblxuLyoqXG4qIFRoZSBJZ3hUYWJzTW9kdWxlIHByb3ZpZGVzIHRoZSB7QGxpbmsgSWd4VGFic0NvbXBvbmVudH0sIHtAbGluayBJZ3hUYWJzR3JvdXBDb21wb25lbnR9LFxuKntAbGluayBJZ3hUYWJJdGVtQ29tcG9uZW50fSwge0BsaW5rIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZX0sIHtAbGluayBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlfVxuKiBhbmQge0BsaW5rIElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZX0gaW5zaWRlIHlvdXIgYXBwbGljYXRpb24uXG4qL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hUYWJzQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJzR3JvdXBDb21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1Db21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4TGVmdEJ1dHRvblN0eWxlRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4VGFic0NvbXBvbmVudCxcbiAgICAgICAgSWd4VGFic0dyb3VwQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFJpZ2h0QnV0dG9uU3R5bGVEaXJlY3RpdmUsXG4gICAgICAgIElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZV0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgSWd4QmFkZ2VNb2R1bGUsIElneEljb25Nb2R1bGUsIElneFJpcHBsZU1vZHVsZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hUYWJzTW9kdWxlIHtcbn1cbiJdfQ==