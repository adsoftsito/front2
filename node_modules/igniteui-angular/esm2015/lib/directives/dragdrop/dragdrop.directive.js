/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, Output, Renderer2, ChangeDetectorRef } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
/** @enum {number} */
const RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
export { RestrictDrag };
RestrictDrag[RestrictDrag.VERTICALLY] = "VERTICALLY";
RestrictDrag[RestrictDrag.HORIZONTALLY] = "HORIZONTALLY";
RestrictDrag[RestrictDrag.NONE] = "NONE";
export class IgxDragCustomEventDetails {
}
function IgxDragCustomEventDetails_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.owner;
}
export class IgxDropEnterEventArgs {
}
function IgxDropEnterEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.dragData;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.startX;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.startY;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.pageX;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.pageY;
}
export class IgxDropLeaveEventArgs {
}
function IgxDropLeaveEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.dragData;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.startX;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.startY;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.pageX;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.pageY;
}
export class IgxDropEventArgs {
}
function IgxDropEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragBaseEventArgs() { }
function IDragBaseEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IDragBaseEventArgs.prototype.originalEvent;
    /** @type {?} */
    IDragBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function IDragStartEventArgs() { }
function IDragStartEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IDragStartEventArgs.prototype.cancel;
}
export class IgxDragDirective {
    /**
     * @param {?} cdr
     * @param {?} element
     * @param {?} zone
     * @param {?} renderer
     */
    constructor(cdr, element, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * An \@Input property that indicates when the drag should start
         * By default the drag starts after the draggable element is moved by 5px
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragTolerance = 5;
        /**
         * Sets a custom class that will be added to the `dragGhost` element.
         * ```html
         * <div igxDrag [ghostImageClass]="'dragGhost'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.ghostImageClass = '';
        /**
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.hideBaseOnDrag = false;
        /**
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         */
        this.returnMoveEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragClicked(){
         *      alert("The elemented has been clicked!");
         * }
         * ```
         */
        this.dragClicked = new EventEmitter();
        /**
         * @hidden
         */
        this.touch = 'none';
        /**
         * @hidden
         */
        this.transitionProperty = 'top, left';
        /**
         * @hidden
         */
        this.top1 = 0;
        /**
         * @hidden
         */
        this.left1 = 0;
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this._startX = 0;
        /**
         * @hidden
         */
        this._startY = 0;
        /**
         * @hidden
         */
        this._dragStarted = false;
        /**
         * @hidden
         */
        this._pointerDownId = null;
        /**
         * @hidden
         */
        this._clicked = false;
        /**
         * @hidden
         */
        this._lastDropArea = null;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        /**
         * @hidden
         */
        this._removeOnDestroy = true;
    }
    /**
     * Sets the visibility of the draggable element.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     this.myDrag.visible = false;
     * }
     * ```
     * @param {?} bVisible
     * @return {?}
     */
    set visible(bVisible) {
        this._visibility = bVisible ? 'visible' : 'hidden';
        this.cdr.detectChanges();
    }
    /**
     * Returns the visibility state of the draggable element.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let dragVisibilty = this.myDrag.visible;
     * }
     * ```
     * @return {?}
     */
    get visible() {
        return this._visibility === 'visible';
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    set left(val) {
        requestAnimationFrame(() => {
            if (this._dragGhost) {
                this._dragGhost.style.left = val + 'px';
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    get left() {
        return parseInt(this._dragGhost.style.left, 10);
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    set top(val) {
        requestAnimationFrame(() => {
            if (this._dragGhost) {
                this._dragGhost.style.top = val + 'px';
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    get top() {
        return parseInt(this._dragGhost.style.top, 10);
    }
    /**
     * Returns if the browser supports pointer events.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let pointerEvents = this.myDrag.pointerEventsEnabled;
     * }
     * ```
     * @return {?}
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * Returns if the browser supports touch events.
     * ```typescript
     * \@ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let touchEvents = this.myDrag.pointerEventsEnabled;
     * }
     * ```
     * @return {?}
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            if (this.pointerEventsEnabled) {
                fromEvent(this.element.nativeElement, 'pointerdown').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerDown(res));
                fromEvent(this.element.nativeElement, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(this.element.nativeElement, 'pointerup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (this.touchEventsEnabled) {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(this.element.nativeElement, 'touchstart').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerDown(res));
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(this.element.nativeElement, 'mousedown').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerDown(res));
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this._dragGhost && this._removeOnDestroy) {
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
        }
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    onPointerDown(event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        // Take margins because getBoundingClientRect() doesn't include margins of the element
        const /** @type {?} */ marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        const /** @type {?} */ marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._dragOffsetX = (this._startX - this.element.nativeElement.getBoundingClientRect().left) + marginLeft;
        this._dragOffsetY = (this._startY - this.element.nativeElement.getBoundingClientRect().top) + marginTop;
        this._dragStartX = this._startX - this._dragOffsetX;
        this._dragStartY = this._startY - this._dragOffsetY;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until dragGhost is created.
        if (this.pointerEventsEnabled) {
            this.element.nativeElement.setPointerCapture(this._pointerDownId);
        }
        else {
            this.element.nativeElement.focus();
            event.preventDefault();
        }
    }
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    onPointerMove(event) {
        if (this._clicked) {
            const /** @type {?} */ dragStartArgs = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            let /** @type {?} */ pageX, /** @type {?} */ pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const /** @type {?} */ totalMovedX = pageX - this._startX;
            const /** @type {?} */ totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    // We moved enough so dragGhost can be rendered and actual dragging to start.
                    this.createDragGhost(event);
                }
                return;
            }
            else if (!this._dragStarted) {
                return;
            }
            this.left = this._dragStartX + totalMovedX;
            this.top = this._dragStartY + totalMovedY;
            this.dispatchDragEvents(pageX, pageY);
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        const /** @type {?} */ eventArgs = {
            originalEvent: event,
            owner: this
        };
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                if (!this.animateOnRelease) {
                    this.onTransitionEnd(null);
                }
                // dragging ended over a drop area. Call this after transition because onDrop might remove the element.
                this.dispatchDropEvent(event.pageX, event.pageY);
                // else the drop directive needs to call the dropFinished() method so the animation can perform
            }
            else if (this.animateOnRelease &&
                (this.left !== Math.floor(this._dragStartX) || this.top !== Math.floor(this._dragStartY))) {
                // If the start positions are the same as the current the transition will not execute.
                // return the ghost to start position before removing it. See onTransitionEnd.
                this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
                this.left = this._dragStartX;
                this.top = this._dragStartY;
            }
            else {
                this.onTransitionEnd(null);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
        }
        else {
            this.zone.run(() => {
                this.dragClicked.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Create dragGhost element - copy of the base element. Bind all needed events.
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @return {?}
     */
    createDragGhost(event) {
        this._dragGhost = this.element.nativeElement.cloneNode(true);
        this._dragGhost.style.transitionDuration = '0.0s';
        this._dragGhost.style.position = 'absolute';
        this._dragGhost.style.top = this._dragStartY + 'px';
        this._dragGhost.style.left = this._dragStartX + 'px';
        if (this.ghostImageClass) {
            this.renderer.addClass(this._dragGhost, this.ghostImageClass);
        }
        document.body.appendChild(this._dragGhost);
        if (this.pointerEventsEnabled) {
            // The dragGhost takes control for moving and dragging after it has been shown.
            this._dragGhost.setPointerCapture(this._pointerDownId);
            this._dragGhost.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this._dragGhost.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
        }
        if (this.animateOnRelease) {
            // Transition animation when the dragGhost is released and it returns to it's original position.
            this._dragGhost.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        }
        // Hide the base after the dragGhost is created, because otherwise the dragGhost will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    dispatchDragEvents(pageX, pageY) {
        let /** @type {?} */ topDropArea;
        const /** @type {?} */ eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this
        };
        const /** @type {?} */ elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (let /** @type {?} */ i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' && elementsFromPoint[i] !== this._dragGhost) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', eventArgs);
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', eventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    dispatchDropEvent(pageX, pageY) {
        const /** @type {?} */ eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    updateDragRelativePos() {
        if (!this._dragGhost) {
            return;
        }
        // Calculate the new dragGhost position to remain where the mouse is, so it doesn't jump
        const /** @type {?} */ totalDraggedX = this.left - this._dragStartX;
        const /** @type {?} */ totalDraggedY = this.top - this._dragStartY;
        const /** @type {?} */ newPosX = this.element.nativeElement.getBoundingClientRect().left;
        const /** @type {?} */ newPosY = this.element.nativeElement.getBoundingClientRect().top;
        const /** @type {?} */ diffStartX = this._dragStartX - newPosX;
        const /** @type {?} */ diffStartY = this._dragStartY - newPosY;
        this.top = newPosX + totalDraggedX - diffStartX;
        this.left = newPosY + totalDraggedY - diffStartY;
    }
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    dropFinished() {
        if (this.animateOnRelease && this._dragGhost) {
            this.updateDragRelativePos();
            // Return the dragged element to the start. See onTransitionEnd next.
            // Take margins becuase getBoundingClientRect() doesn't include margins
            const /** @type {?} */ marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
            const /** @type {?} */ marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
            const /** @type {?} */ newPosX = this.element.nativeElement.getBoundingClientRect().left;
            const /** @type {?} */ newPosY = this.element.nativeElement.getBoundingClientRect().top;
            this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
            this.left = newPosX - marginLeft;
            this.top = newPosY - marginTop;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onTransitionEnd(event) {
        if (this._dragStarted && !this._clicked) {
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this._dragStarted = false;
            this.zone.run(() => {
                this.returnMoveEnd.emit({
                    originalEvent: event,
                    owner: this
                });
            });
        }
    }
    /**
     * @hidden
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint conider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const /** @type {?} */ viewPortX = pageX - window.pageXOffset;
        const /** @type {?} */ viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            return document['msElementsFromPoint'](viewPortX, viewPortY);
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const /** @type {?} */ dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Othersie can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
}
IgxDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDrag]'
            },] },
];
/** @nocollapse */
IgxDragDirective.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
];
IgxDragDirective.propDecorators = {
    "data": [{ type: Input, args: ['igxDrag',] },],
    "dragTolerance": [{ type: Input },],
    "ghostImageClass": [{ type: Input },],
    "hideBaseOnDrag": [{ type: Input },],
    "animateOnRelease": [{ type: Input },],
    "dragStart": [{ type: Output },],
    "dragEnd": [{ type: Output },],
    "returnMoveEnd": [{ type: Output },],
    "dragClicked": [{ type: Output },],
    "touch": [{ type: HostBinding, args: ['style.touchAction',] },],
    "transitionProperty": [{ type: HostBinding, args: ['style.transitionProperty',] },],
    "top1": [{ type: HostBinding, args: ['style.top.px',] },],
    "left1": [{ type: HostBinding, args: ['style.left.px',] },],
    "_visibility": [{ type: HostBinding, args: ['style.visibility',] },],
};
function IgxDragDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDragDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDragDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxDragDirective.propDecorators;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.data;
    /**
     * An \@Input property that indicates when the drag should start
     * By default the drag starts after the draggable element is moved by 5px
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragTolerance;
    /**
     * Sets a custom class that will be added to the `dragGhost` element.
     * ```html
     * <div igxDrag [ghostImageClass]="'dragGhost'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.ghostImageClass;
    /**
     * An \@Input property that hides the draggable element.
     * By default it's set to false.
     * ```html
     * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.hideBaseOnDrag;
    /**
     * An \@Input property that enables/disables the draggable element animation
     * when the element is released.
     * By default it's set to false.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.animateOnRelease;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragStart;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragEnd;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.returnMoveEnd;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public dragClicked(){
     *      alert("The elemented has been clicked!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragClicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.touch;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.transitionProperty;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.top1;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.left1;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._visibility;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.defaultReturnDuration;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._startX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._startY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragGhost;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStarted;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragOffsetX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragOffsetY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStartX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStartY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._pointerDownId;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._clicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._lastDropArea;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._destroy;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._removeOnDestroy;
    /** @type {?} */
    IgxDragDirective.prototype.cdr;
    /** @type {?} */
    IgxDragDirective.prototype.element;
    /** @type {?} */
    IgxDragDirective.prototype.zone;
    /** @type {?} */
    IgxDragDirective.prototype.renderer;
}
export class IgxDropDirective {
    /**
     * @param {?} element
     * @param {?} _renderer
     * @param {?} _zone
     */
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable elemente has entered the chip area!");
         * }
         * ```
         */
        this.onEnter = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable elemente has left the chip area!");
         * }
         * ```
         */
        this.onLeave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable elemente has been dropped in the chip area!");
         * }
         * ```
         */
        this.onDrop = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(/** @type {?} */ (res)));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) { }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragEnter(event) {
        this.dragover = true;
        const /** @type {?} */ eventArgs = {
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY
        };
        this._zone.run(() => {
            this.onEnter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragLeave(event) {
        this.dragover = false;
        const /** @type {?} */ eventArgs = {
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY
        };
        this._zone.run(() => {
            this.onLeave.emit();
        });
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onDragDrop(event) {
        const /** @type {?} */ args = {
            owner: this,
            drag: event.detail.owner,
            cancel: false
        };
        this._zone.run(() => {
            this.onDrop.emit(args);
        });
        if (!args.cancel) {
            // To do for generic scenario
            this._renderer.removeChild(event.detail.owner.element.nativeElement.parentNode, event.detail.owner.element.nativeElement);
            this._renderer.appendChild(this.element.nativeElement, event.detail.owner.element.nativeElement);
            setTimeout(() => {
                event.detail.owner.dropFinished();
            }, 0);
        }
    }
}
IgxDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxDrop]'
            },] },
];
/** @nocollapse */
IgxDropDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: NgZone, },
];
IgxDropDirective.propDecorators = {
    "data": [{ type: Input, args: ['igxDrop',] },],
    "onEnter": [{ type: Output },],
    "onLeave": [{ type: Output },],
    "onDrop": [{ type: Output },],
    "droppable": [{ type: HostBinding, args: ['attr.droppable',] },],
    "dragover": [{ type: HostBinding, args: ['class.dragOver',] },],
    "onDragDrop": [{ type: HostListener, args: ['igxDrop', ['$event'],] },],
};
function IgxDropDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDropDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDropDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxDropDirective.propDecorators;
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.data;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable elemente has entered the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onEnter;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable elemente has left the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onLeave;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable elemente has been dropped in the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onDrop;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.droppable;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.dragover;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype._destroy;
    /** @type {?} */
    IgxDropDirective.prototype.element;
    /** @type {?} */
    IgxDropDirective.prototype._renderer;
    /** @type {?} */
    IgxDropDirective.prototype._zone;
}
/**
 * The IgxDragDropModule provides the {\@link IgxDragDirective}, {\@link IgxDropDirective} inside your application.
 */
export class IgxDragDropModule {
}
IgxDragDropModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxDragDirective, IgxDropDirective],
                exports: [IgxDragDirective, IgxDropDirective]
            },] },
];
function IgxDragDropModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDragDropModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDragDropModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2Ryb3AuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kaXJlY3RpdmVzL2RyYWdkcm9wL2RyYWdkcm9wLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBRVosS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBR04sTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7O0FBUXJELE1BQU07Q0FNTDs7Ozs7Ozs7Ozs7OztBQUVELE1BQU07Q0FRTDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxNQUFNO0NBUUw7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsTUFBTTtDQUlMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhRCxNQUFNOzs7Ozs7O0lBb1RGLFlBQW1CLEdBQXNCLEVBQVMsT0FBbUIsRUFBUyxJQUFZLEVBQVMsUUFBbUI7UUFBbkcsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFBUyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFTLGFBQVEsR0FBUixRQUFRLENBQVc7Ozs7Ozs7Ozs7NkJBL1IvRixDQUFDOzs7Ozs7Ozs7K0JBV0MsRUFBRTs7Ozs7Ozs7Ozs4QkFZSCxLQUFLOzs7Ozs7Ozs7OztnQ0FhSCxLQUFLOzs7Ozs7Ozs7Ozs7Ozt5QkFnQlosSUFBSSxZQUFZLEVBQXVCOzs7Ozs7Ozs7Ozs7Ozt1QkFnQnpDLElBQUksWUFBWSxFQUFz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RyxFQUFFO2dCQUNaLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3JDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDVDs7OztZQTlKUixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFdBQVc7YUFDeEI7Ozs7WUEzd0JHLFVBQVU7WUFXVixTQUFTO1lBSlQsTUFBTTs7O3FCQTZ3QkwsS0FBSyxTQUFDLFNBQVM7d0JBY2YsTUFBTTt3QkFjTixNQUFNO3VCQWdCTixNQUFNOzBCQU1OLFdBQVcsU0FBQyxnQkFBZ0I7eUJBTTVCLFdBQVcsU0FBQyxnQkFBZ0I7MkJBd0U1QixZQUFZLFNBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCdkMsTUFBTTs7O1lBSkwsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDO2dCQUNsRCxPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQzthQUNoRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgTmdab25lLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBDaGFuZ2VEZXRlY3RvclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBmcm9tRXZlbnQsIGludGVydmFsLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRocm90dGxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgZW51bSBSZXN0cmljdERyYWcge1xuICAgIFZFUlRJQ0FMTFksXG4gICAgSE9SSVpPTlRBTExZLFxuICAgIE5PTkVcbn1cblxuZXhwb3J0IGNsYXNzIElneERyYWdDdXN0b21FdmVudERldGFpbHMge1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgcGFnZVk6IG51bWJlcjtcbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbn1cblxuZXhwb3J0IGNsYXNzIElneERyb3BFbnRlckV2ZW50QXJncyB7XG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgZHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICBkcmFnRGF0YTogYW55O1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgcGFnZVk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIElneERyb3BMZWF2ZUV2ZW50QXJncyB7XG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgZHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICBkcmFnRGF0YTogYW55O1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgcGFnZVk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIElneERyb3BFdmVudEFyZ3Mge1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnQmFzZUV2ZW50QXJncyB7XG4gICAgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IHwgTW91c2VFdmVudCB8IFRvdWNoRXZlbnQ7XG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG59XG5leHBvcnQgaW50ZXJmYWNlIElEcmFnU3RhcnRFdmVudEFyZ3MgZXh0ZW5kcyBJRHJhZ0Jhc2VFdmVudEFyZ3Mge1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcmFnYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyYWdgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyYWddPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcmFnJylcbiAgICBwdWJsaWMgZGF0YTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHdoZW4gdGhlIGRyYWcgc2hvdWxkIHN0YXJ0XG4gICAgICogQnkgZGVmYXVsdCB0aGUgZHJhZyBzdGFydHMgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIG1vdmVkIGJ5IDVweFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcmFnVG9sZXJhbmNlID0gNTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjdXN0b20gY2xhc3MgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBgZHJhZ0dob3N0YCBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0SW1hZ2VDbGFzc109XCInZHJhZ0dob3N0J1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RJbWFnZUNsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBoaWRlcyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnVG9sZXJhbmNlXT1cIjEwMFwiIFtoaWRlQmFzZU9uRHJhZ109XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhpZGVCYXNlT25EcmFnID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBlbmFibGVzL2Rpc2FibGVzIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBhbmltYXRpb25cbiAgICAgKiB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbGVhc2VkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGVPblJlbGVhc2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBkcmFnIHN0YXJ0cy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFthbmltYXRlT25SZWxlYXNlXT1cIid0cnVlJ1wiIChkcmFnU3RhcnQpPVwib25EcmFnU3RhcnQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdTdGFydCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgc3RhcmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdTdGFydEV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFthbmltYXRlT25SZWxlYXNlXT1cIid0cnVlJ1wiIChkcmFnRW5kKT1cIm9uRHJhZ0VuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ0VuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZCBhbmQgYWZ0ZXIgaXRzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIiAocmV0dXJuTW92ZUVuZCk9XCJvbk1vdmVFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbk1vdmVFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIG1vdmUgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJldHVybk1vdmVFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBjbGlja2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2FuaW1hdGVPblJlbGVhc2VdPVwiJ3RydWUnXCIgKGRyYWdDbGlja2VkKT1cImRyYWdDbGlja2VkKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0NsaWNrZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGVsZW1lbnRlZCBoYXMgYmVlbiBjbGlja2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdDbGlja2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS50b3VjaEFjdGlvbicpXG4gICAgcHVibGljIHRvdWNoID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudHJhbnNpdGlvblByb3BlcnR5JylcbiAgICBwdWJsaWMgdHJhbnNpdGlvblByb3BlcnR5ID0gJ3RvcCwgbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS50b3AucHgnKVxuICAgIHB1YmxpYyB0b3AxID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmxlZnQucHgnKVxuICAgIHB1YmxpYyBsZWZ0MSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS52aXNpYmlsaXR5JylcbiAgICBwdWJsaWMgX3Zpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIm15RHJhZ1wiICx7cmVhZDogSWd4RHJhZ0RpcmVjdGl2ZX0pXG4gICAgICogcHVibGljIG15RHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgdGhpcy5teURyYWcudmlzaWJsZSA9IGZhbHNlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHZpc2libGUoYlZpc2libGUpIHtcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eSA9IGJWaXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIm15RHJhZ1wiICx7cmVhZDogSWd4RHJhZ0RpcmVjdGl2ZX0pXG4gICAgICogcHVibGljIG15RHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGRyYWdWaXNpYmlsdHkgPSB0aGlzLm15RHJhZy52aXNpYmxlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmlsaXR5ID09PSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbGVmdCh2YWw6IG51bWJlcikge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdHaG9zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gdmFsICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2RyYWdHaG9zdC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdG9wKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRvcCA9IHZhbCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50b3AsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgcG9pbnRlckV2ZW50cyA9IHRoaXMubXlEcmFnLnBvaW50ZXJFdmVudHNFbmFibGVkO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBvaW50ZXJFdmVudHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCB0b3VjaEV2ZW50cyA9IHRoaXMubXlEcmFnLnBvaW50ZXJFdmVudHNFbmFibGVkO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHRSZXR1cm5EdXJhdGlvbiA9ICcwLjVzJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WCA9IDA7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc3RhcnRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdHaG9zdDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdPZmZzZXRYO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdPZmZzZXRZO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydFg7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0WTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9wb2ludGVyRG93bklkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NsaWNrZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9sYXN0RHJvcEFyZWEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9yZW1vdmVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgem9uZTogTmdab25lLCBwdWJsaWMgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAncG9pbnRlcmRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAncG9pbnRlcnVwJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJVcChyZXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuIFVzZSB0aGVuIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd0b3VjaHN0YXJ0JykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaG1vdmUnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLFxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlck1vdmUocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaGVuZCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy4gVXNlIHRoZW4gbW91c2UgZXZlbnRzLlxuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2Vtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2V1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RyYWdHaG9zdCAmJiB0aGlzLl9yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2RyYWdHaG9zdCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCBib3VuZCB0byB0aGUgUG9pbnRlckRvd24gZXZlbnQgb2YgdGhlIGJhc2UgZWxlbWVudCBpZ3hEcmFnIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyRG93biBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wb2ludGVyRG93bklkID0gZXZlbnQucG9pbnRlcklkO1xuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRha2UgbWFyZ2lucyBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGRvZXNuJ3QgaW5jbHVkZSBtYXJnaW5zIG9mIHRoZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IG1hcmdpblRvcCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpWydtYXJnaW4tdG9wJ10sIDEwKTtcbiAgICAgICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpWydtYXJnaW4tbGVmdCddLCAxMCk7XG5cbiAgICAgICAgdGhpcy5fZHJhZ09mZnNldFggPSAodGhpcy5fc3RhcnRYIC0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBtYXJnaW5MZWZ0O1xuICAgICAgICB0aGlzLl9kcmFnT2Zmc2V0WSA9ICh0aGlzLl9zdGFydFkgLSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApICsgbWFyZ2luVG9wO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRYID0gdGhpcy5fc3RhcnRYIC0gdGhpcy5fZHJhZ09mZnNldFg7XG4gICAgICAgIHRoaXMuX2RyYWdTdGFydFkgPSB0aGlzLl9zdGFydFkgLSB0aGlzLl9kcmFnT2Zmc2V0WTtcblxuICAgICAgICAvLyBTZXQgcG9pbnRlciBjYXB0dXJlIHNvIHdlIGRldGVjdCBwb2ludGVybW92ZSBldmVuIGlmIG1vdXNlIGlzIG91dCBvZiBib3VuZHMgdW50aWwgZHJhZ0dob3N0IGlzIGNyZWF0ZWQuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSh0aGlzLl9wb2ludGVyRG93bklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZtb3JtIGRyYWcgbW92ZSBsb2dpYyB3aGVuIGRyYWdnaW5nIGFuZCBkaXNwYXRjaGluZyBldmVudHMgaWYgdGhlcmUgaXMgaWd4RHJvcCB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGRyYWdHaG9zdCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgdG8gdGhlIGRyYWdHaG9zdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlck1vdmUgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ1N0YXJ0QXJnczogSURyYWdTdGFydEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBhZ2VYLCBwYWdlWTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gdG91Y2ggd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0b3RhbE1vdmVkWCA9IHBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlZFkgPSBwYWdlWSAtIHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZHJhZ1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModG90YWxNb3ZlZFgpID4gdGhpcy5kcmFnVG9sZXJhbmNlIHx8IE1hdGguYWJzKHRvdGFsTW92ZWRZKSA+IHRoaXMuZHJhZ1RvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQuZW1pdChkcmFnU3RhcnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtb3ZlZCBlbm91Z2ggc28gZHJhZ0dob3N0IGNhbiBiZSByZW5kZXJlZCBhbmQgYWN0dWFsIGRyYWdnaW5nIHRvIHN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZURyYWdHaG9zdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLl9kcmFnU3RhcnRYICsgdG90YWxNb3ZlZFg7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuX2RyYWdTdGFydFkgKyB0b3RhbE1vdmVkWTtcblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaERyYWdFdmVudHMocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBQZXJmb3JtIGRyYWcgZW5kIGxvZ2ljIHdoZW4gcmVsZWFzaW5nIHRoZSBkcmFnR2hvc3QgYW5kIGRpc3BhdGNoaW5kIGRyb3AgZXZlbnQgaWYgaWd4RHJvcCBpcyB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGRyYWdHaG9zdCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgdG8gdGhlIGRyYWdHaG9zdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlclVwIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGVPblJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmcgZW5kZWQgb3ZlciBhIGRyb3AgYXJlYS4gQ2FsbCB0aGlzIGFmdGVyIHRyYW5zaXRpb24gYmVjYXVzZSBvbkRyb3AgbWlnaHQgcmVtb3ZlIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hEcm9wRXZlbnQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAvLyBlbHNlIHRoZSBkcm9wIGRpcmVjdGl2ZSBuZWVkcyB0byBjYWxsIHRoZSBkcm9wRmluaXNoZWQoKSBtZXRob2Qgc28gdGhlIGFuaW1hdGlvbiBjYW4gcGVyZm9ybVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMubGVmdCAhPT0gTWF0aC5mbG9vcih0aGlzLl9kcmFnU3RhcnRYKSB8fCB0aGlzLnRvcCAhPT0gTWF0aC5mbG9vcih0aGlzLl9kcmFnU3RhcnRZKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgcG9zaXRpb25zIGFyZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB0aGUgdHJhbnNpdGlvbiB3aWxsIG5vdCBleGVjdXRlLlxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZ2hvc3QgdG8gc3RhcnQgcG9zaXRpb24gYmVmb3JlIHJlbW92aW5nIGl0LiBTZWUgb25UcmFuc2l0aW9uRW5kLlxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0aGlzLmRlZmF1bHRSZXR1cm5EdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLl9kcmFnU3RhcnRYO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5fZHJhZ1N0YXJ0WTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0NsaWNrZWQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ3JlYXRlIGRyYWdHaG9zdCBlbGVtZW50IC0gY29weSBvZiB0aGUgYmFzZSBlbGVtZW50LiBCaW5kIGFsbCBuZWVkZWQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyIGV2ZW50IHJlcXVpcmVkIHdoZW4gdGhlIGRyYWdHaG9zdCBpcyBiZWluZyBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlRHJhZ0dob3N0KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRvcCA9IHRoaXMuX2RyYWdTdGFydFkgKyAncHgnO1xuICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc3R5bGUubGVmdCA9IHRoaXMuX2RyYWdTdGFydFggKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLmdob3N0SW1hZ2VDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9kcmFnR2hvc3QsIHRoaXMuZ2hvc3RJbWFnZUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZHJhZ0dob3N0KTtcblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGRyYWdHaG9zdCB0YWtlcyBjb250cm9sIGZvciBtb3ZpbmcgYW5kIGRyYWdnaW5nIGFmdGVyIGl0IGhhcyBiZWVuIHNob3duLlxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnNldFBvaW50ZXJDYXB0dXJlKHRoaXMuX3BvaW50ZXJEb3duSWQpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gYW5pbWF0aW9uIHdoZW4gdGhlIGRyYWdHaG9zdCBpcyByZWxlYXNlZCBhbmQgaXQgcmV0dXJucyB0byBpdCdzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIHRoZSBiYXNlIGFmdGVyIHRoZSBkcmFnR2hvc3QgaXMgY3JlYXRlZCwgYmVjYXVzZSBvdGhlcndpc2UgdGhlIGRyYWdHaG9zdCB3aWxsIGJlIG5vdCB2aXNpYmxlLlxuICAgICAgICBpZiAodGhpcy5oaWRlQmFzZU9uRHJhZykge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyYWdFbnRlci9pZ3hEcmFnTGVhdmUgZXZlbnRzIGJhc2VkIG9uIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgaWYgZHJvcCBhcmVhIGlzIHVuZGVyLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaERyYWdFdmVudHMocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgICAgICBsZXQgdG9wRHJvcEFyZWE7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyA9IHtcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogcGFnZVksXG4gICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzRnJvbVBvaW50ID0gdGhpcy5nZXRFbGVtZW50c0F0UG9pbnQocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50c0Zyb21Qb2ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzRnJvbVBvaW50W2ldLmdldEF0dHJpYnV0ZSgnZHJvcHBhYmxlJykgPT09ICd0cnVlJyAmJiBlbGVtZW50c0Zyb21Qb2ludFtpXSAhPT0gdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICAgICAgdG9wRHJvcEFyZWEgPSBlbGVtZW50c0Zyb21Qb2ludFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRvcERyb3BBcmVhLCAnaWd4RHJhZ092ZXInLCBldmVudEFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERyb3BBcmVhICYmXG4gICAgICAgICAgICAoIXRoaXMuX2xhc3REcm9wQXJlYSB8fCAodGhpcy5fbGFzdERyb3BBcmVhICYmIHRoaXMuX2xhc3REcm9wQXJlYSAhPT0gdG9wRHJvcEFyZWEpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSB0b3BEcm9wQXJlYTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnRW50ZXInLCBldmVudEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0b3BEcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJvcCBldmVudCBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gaWYgdGhlcmUgaXMgbGFzdCByZWNvcmRlciBkcm9wIGFyZWEgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogTGFzdCByZWNvcmRlciBkcm9wIGFyZWEgaXMgdXBkYXRlZCBpbiBAZGlzcGF0Y2hEcmFnRXZlbnRzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcm9wRXZlbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMgPSB7XG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJvcCcsIGV2ZW50QXJncyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBVcGRhdGUgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZURyYWdSZWxhdGl2ZVBvcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kcmFnR2hvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGRyYWdHaG9zdCBwb3NpdGlvbiB0byByZW1haW4gd2hlcmUgdGhlIG1vdXNlIGlzLCBzbyBpdCBkb2Vzbid0IGp1bXBcbiAgICAgICAgY29uc3QgdG90YWxEcmFnZ2VkWCA9IHRoaXMubGVmdCAtIHRoaXMuX2RyYWdTdGFydFg7XG4gICAgICAgIGNvbnN0IHRvdGFsRHJhZ2dlZFkgPSB0aGlzLnRvcCAtIHRoaXMuX2RyYWdTdGFydFk7XG4gICAgICAgIGNvbnN0IG5ld1Bvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBjb25zdCBuZXdQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBjb25zdCBkaWZmU3RhcnRYID0gdGhpcy5fZHJhZ1N0YXJ0WCAtIG5ld1Bvc1g7XG4gICAgICAgIGNvbnN0IGRpZmZTdGFydFkgPSB0aGlzLl9kcmFnU3RhcnRZIC0gbmV3UG9zWTtcbiAgICAgICAgdGhpcy50b3AgPSBuZXdQb3NYICsgdG90YWxEcmFnZ2VkWCAtIGRpZmZTdGFydFg7XG4gICAgICAgIHRoaXMubGVmdCA9IG5ld1Bvc1kgKyB0b3RhbERyYWdnZWRZIC0gZGlmZlN0YXJ0WTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmZvcm1zIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlIHRoYXQgaXQgaGFzIGJlZW4gZHJvcHBlZC9yZWxlYXNlZC5cbiAgICAgKiBUaGlzIHNob3VsZCB1c3VsbHkgYmUgY2FsbGVkIHdoZW4gYGFuaW1hdGVPblJlbGVhc2VgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICogV2hlbiBjYW5jZWxpbmcgb3IgZGVmaW5pbmcgY3VzdG9tIGRyb3AgbG9naWMgdGhpcyB0ZWxscyB0aGUgaWd4RHJhZyB0byB1cGRhdGUgaXQncyBwb3NpdGlvbnMgYW5kXG4gICAgICogYW5pbWF0ZSBjb3JyZWN0bHkgdG8gdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJvcEVsZW0oZXZlbnQpIHtcbiAgICAgKiAgICAgLy8gRnVuY3Rpb24gYm91bmQgdG8gdGhlIGlneERyb3AgZGlyZWN0aXZlIGV2ZW50IGBvbkRyb3BgXG4gICAgICogICAgIC8vIFRoaXMgY2FuY2VscyB0aGUgZGVmYXVsdCBkcm9wIGxvZ2ljIG9mIHRoZSBgaWd4RHJvcGBcbiAgICAgKiAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgKiAgICAgZXZlbnQuZHJhZy5kcm9wRmluaXNoZWQoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGRyb3BGaW5pc2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZU9uUmVsZWFzZSAmJiB0aGlzLl9kcmFnR2hvc3QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ1JlbGF0aXZlUG9zKCk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZHJhZ2dlZCBlbGVtZW50IHRvIHRoZSBzdGFydC4gU2VlIG9uVHJhbnNpdGlvbkVuZCBuZXh0LlxuICAgICAgICAgICAgLy8gVGFrZSBtYXJnaW5zIGJlY3Vhc2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgZG9lc24ndCBpbmNsdWRlIG1hcmdpbnNcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpblRvcCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpWydtYXJnaW4tdG9wJ10sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbmV3UG9zWCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXdQb3NYIC0gbWFyZ2luTGVmdDtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3UG9zWSAtIG1hcmdpblRvcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCAmJiAhdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZUJhc2VPbkRyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9kcmFnR2hvc3QpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0ID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzAuMHMnO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuTW92ZUVuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICAgICAgLy8gY29ycmVjdCB0aGUgY29vcmRpbmF0ZXMgd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2VcbiAgICAgICAgLy8gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQgY29uaWRlciBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICAgICAgLy8gd2luZG93LnBhZ2VYT2Zmc2V0ID09IHdpbmRvdy5zY3JvbGxYOyAvLyBhbHdheXMgdHJ1ZVxuICAgICAgICAvLyB1c2luZyB3aW5kb3cucGFnZVhPZmZzZXQgZm9yIElFOSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0WCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBjb25zdCB2aWV3UG9ydFkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgaWYgKGRvY3VtZW50Wydtc0VsZW1lbnRzRnJvbVBvaW50J10pIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgYW5kIElFIHNwZWNpYWwgc25vd2ZsYWtlc1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50Wydtc0VsZW1lbnRzRnJvbVBvaW50J10odmlld1BvcnRYLCB2aWV3UG9ydFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXIgYnJvd3NlcnMgbGlrZSBDaHJvbWUsIEZpcmVmb3gsIE9wZXJhXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodmlld1BvcnRYLCB2aWV3UG9ydFkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaEV2ZW50KHRhcmdldCwgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscykge1xuICAgICAgICAvLyBUaGlzIHdheSBpcyBJRTExIGNvbXBhdGlibGUuXG4gICAgICAgIGNvbnN0IGRyYWdMZWF2ZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGRyYWdMZWF2ZUV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIGZhbHNlLCBmYWxzZSwgZXZlbnRBcmdzKTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZHJhZ0xlYXZlRXZlbnQpO1xuICAgICAgICAvLyBPdGhlcnNpZSBjYW4gYmUgdXNlZCBgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcmdzKSk7YFxuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RHJvcF0nXG59KVxuZXhwb3J0IGNsYXNzIElneERyb3BEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcm9wYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyb3BgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyb3BdPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcm9wJylcbiAgICBwdWJsaWMgZGF0YTogYW55O1xuXG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBlbnRlcnMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKG9uRW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudGUgaGFzIGVudGVyZWQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkVudGVyID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hEcm9wRW50ZXJFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGxlYXZlcyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAob25MZWF2ZSk9XCJkcmFnTGVhdmUoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnTGVhdmUoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50ZSBoYXMgbGVmdCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyPElneERyb3BMZWF2ZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZCBpbiB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBTaW5jZSB0aGUgYGlneERyb3BgIGhhcyBkZWZhdWx0IGxvZ2ljIHRoYXQgYXBwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IGFzIGEgY2hpbGQsIGl0IGNhbiBiZSBjYW5jZWxlZCBoZXJlLlxuICAgICAqIFRvIGNhbmNlbCB0aGUgZGVmYXVsdCBsb2dpYyB0aGUgYGNhbmNlbGAgcHJvcGVydHkgb2YgdGhlIGV2ZW50IG5lZWRzIHRvIGJlIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChvbkRyb3ApPVwiZHJhZ0Ryb3AoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnRHJvcCgpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnRlIGhhcyBiZWVuIGRyb3BwZWQgaW4gdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkRyb3AgPSBuZXcgRXZlbnRFbWl0dGVyPElneERyb3BFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmRyb3BwYWJsZScpXG4gICAgcHVibGljIGRyb3BwYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kcmFnT3ZlcicpXG4gICAgcHVibGljIGRyYWdvdmVyID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kZXN0cm95ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdpZ3hEcmFnRW50ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnRW50ZXIocmVzIGFzIEN1c3RvbUV2ZW50PElneERyYWdDdXN0b21FdmVudERldGFpbHM+KSk7XG5cbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdMZWF2ZScpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdMZWF2ZShyZXMpKTtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdPdmVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ092ZXIocmVzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95Lm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uRHJhZ092ZXIoZXZlbnQpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pIHtcbiAgICAgICAgdGhpcy5kcmFnb3ZlciA9IHRydWU7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSWd4RHJvcEVudGVyRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXIuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uRHJhZ0xlYXZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ292ZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJZ3hEcm9wTGVhdmVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25MZWF2ZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdpZ3hEcm9wJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25EcmFnRHJvcChldmVudCkge1xuICAgICAgICBjb25zdCBhcmdzOiBJZ3hEcm9wRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Ecm9wLmVtaXQoYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIC8vIFRvIGRvIGZvciBnZW5lcmljIHNjZW5hcmlvXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDaGlsZChldmVudC5kZXRhaWwub3duZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUsIGV2ZW50LmRldGFpbC5vd25lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGV2ZW50LmRldGFpbC5vd25lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwub3duZXIuZHJvcEZpbmlzaGVkKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIFRoZSBJZ3hEcmFnRHJvcE1vZHVsZSBwcm92aWRlcyB0aGUge0BsaW5rIElneERyYWdEaXJlY3RpdmV9LCB7QGxpbmsgSWd4RHJvcERpcmVjdGl2ZX0gaW5zaWRlIHlvdXIgYXBwbGljYXRpb24uXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneERyYWdEaXJlY3RpdmUsIElneERyb3BEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEcm9wTW9kdWxlIHsgfVxuIl19