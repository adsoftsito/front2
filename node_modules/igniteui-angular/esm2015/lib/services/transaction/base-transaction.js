/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { EventEmitter, Injectable } from '@angular/core';
import { isObject, mergeObjects, cloneValue } from '../../core/utils';
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template T, S
 */
export class IgxBaseTransactionService {
    constructor() {
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        this.onStateUpdate = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get canRedo() {
        return false;
    }
    /**
     * @return {?}
     */
    get canUndo() {
        return false;
    }
    /**
     * @return {?}
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    getTransactionLog(id) { return []; }
    /**
     * @return {?}
     */
    undo() { }
    /**
     * @return {?}
     */
    redo() { }
    /**
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedChanges(mergeChanges) {
        const /** @type {?} */ result = [];
        this._pendingStates.forEach((state, key) => {
            const /** @type {?} */ value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push(/** @type {?} */ ({ id: key, newValue: value, type: state.type }));
        });
        return result;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    getAggregatedValue(id, mergeChanges) {
        const /** @type {?} */ state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    commit(data) { }
    /**
     * @return {?}
     */
    clear() {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * @return {?}
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * @param {?} commit
     * @return {?}
     */
    endPending(commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    updateState(states, transaction, recordRef) {
        let /** @type {?} */ state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = /** @type {?} */ ({ value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type });
            states.set(transaction.id, state);
        }
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @param {?} state State to update value for
     * @return {?} updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @template U
     * @param {?} first Value to merge into
     * @param {?} second Value to merge
     * @return {?}
     */
    mergeValues(first, second) {
        let /** @type {?} */ result;
        if (isObject(first) || isObject(second)) {
            result = mergeObjects(mergeObjects({}, first), second);
        }
        else {
            result = second ? second : first;
        }
        return result;
    }
}
IgxBaseTransactionService.decorators = [
    { type: Injectable },
];
function IgxBaseTransactionService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxBaseTransactionService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxBaseTransactionService.ctorParameters;
    /** @type {?} */
    IgxBaseTransactionService.prototype._isPending;
    /** @type {?} */
    IgxBaseTransactionService.prototype._pendingTransactions;
    /** @type {?} */
    IgxBaseTransactionService.prototype._pendingStates;
    /** @type {?} */
    IgxBaseTransactionService.prototype.onStateUpdate;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS10cmFuc2FjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvdHJhbnNhY3Rpb24vYmFzZS10cmFuc2FjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekQsT0FBTyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7OztBQUd0RSxNQUFNOzswQkFDcUIsS0FBSztvQ0FDVSxFQUFFOzhCQUNBLElBQUksR0FBRyxFQUFFOzZCQVcxQixJQUFJLFlBQVksRUFBUTs7Ozs7UUFWcEMsT0FBTztRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUM7Ozs7O1FBRU4sT0FBTztRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUM7Ozs7O1FBRU4sT0FBTztRQUNkLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDOzs7Ozs7O0lBS3BCLEdBQUcsQ0FBQyxXQUFjLEVBQUUsU0FBZTtRQUN0QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNsQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzlELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDL0M7Ozs7OztJQUdMLGlCQUFpQixDQUFDLEVBQVEsSUFBUyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7Ozs7SUFFL0MsSUFBSSxNQUFZOzs7O0lBRWhCLElBQUksTUFBWTs7Ozs7SUFFaEIsb0JBQW9CLENBQUMsWUFBcUI7UUFDdEMsdUJBQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxD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QyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxNQUFNLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDMUQ7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNKLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1NBQ3BDO1FBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQztLQUNqQjs7O1lBbkhKLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2FjdGlvblNlcnZpY2UsIFRyYW5zYWN0aW9uLCBTdGF0ZSB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc09iamVjdCwgbWVyZ2VPYmplY3RzLCBjbG9uZVZhbHVlIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hCYXNlVHJhbnNhY3Rpb25TZXJ2aWNlPFQgZXh0ZW5kcyBUcmFuc2FjdGlvbiwgUyBleHRlbmRzIFN0YXRlPiBpbXBsZW1lbnRzIFRyYW5zYWN0aW9uU2VydmljZTxULCBTPiB7XG4gICAgcHJvdGVjdGVkIF9pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX3BlbmRpbmdUcmFuc2FjdGlvbnM6IFRbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBfcGVuZGluZ1N0YXRlczogTWFwPGFueSwgUz4gPSBuZXcgTWFwKCk7XG4gICAgcHVibGljIGdldCBjYW5SZWRvKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgY2FuVW5kbygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BlbmRpbmc7XG4gICAgfVxuXG4gICAgcHVibGljIG9uU3RhdGVVcGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBwdWJsaWMgYWRkKHRyYW5zYWN0aW9uOiBULCByZWNvcmRSZWY/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLl9wZW5kaW5nU3RhdGVzLCB0cmFuc2FjdGlvbiwgcmVjb3JkUmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnMucHVzaCh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRUcmFuc2FjdGlvbkxvZyhpZD86IGFueSk6IFRbXSB7IHJldHVybiBbXTsgfVxuXG4gICAgdW5kbygpOiB2b2lkIHsgfVxuXG4gICAgcmVkbygpOiB2b2lkIHsgfVxuXG4gICAgZ2V0QWdncmVnYXRlZENoYW5nZXMobWVyZ2VDaGFuZ2VzOiBib29sZWFuKTogVFtdIHtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBUW10gPSBbXTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlcy5mb3JFYWNoKChzdGF0ZTogUywga2V5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWVyZ2VDaGFuZ2VzID8gdGhpcy5nZXRBZ2dyZWdhdGVkVmFsdWUoa2V5LCBtZXJnZUNoYW5nZXMpIDogc3RhdGUudmFsdWU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGlkOiBrZXksIG5ld1ZhbHVlOiB2YWx1ZSwgdHlwZTogc3RhdGUudHlwZSB9IGFzIFQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3RhdGUoaWQ6IGFueSk6IFMge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ1N0YXRlcy5nZXQoaWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRBZ2dyZWdhdGVkVmFsdWUoaWQ6IGFueSwgbWVyZ2VDaGFuZ2VzOiBib29sZWFuKTogYW55IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGVzLmdldChpZCk7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZhbHVlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUudmFsdWU7XG4gICAgfVxuXG4gICAgY29tbWl0KGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zID0gW107XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXJ0UGVuZGluZygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZW5kUGVuZGluZyhjb21taXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9ucyA9IFtdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgc3RhdGVzIGNvbGxlY3Rpb24gYWNjb3JkaW5nIHRvIHBhc3NlZCB0cmFuc2FjdGlvbiBhbmQgcmVjb3JkUmVmXG4gICAgICogQHBhcmFtIHN0YXRlcyBTdGF0ZXMgY29sbGVjdGlvbiB0byBhcHBseSB0aGUgdXBkYXRlIHRvXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGFwcGx5IHRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICogQHBhcmFtIHJlY29yZFJlZiBSZWZlcmVuY2UgdG8gdGhlIHZhbHVlIG9mIHRoZSByZWNvcmQgaW4gZGF0YSBzb3VyY2UsIGlmIGFueSwgd2hlcmUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlU3RhdGUoc3RhdGVzOiBNYXA8YW55LCBTPiwgdHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgc3RhdGUgPSBzdGF0ZXMuZ2V0KHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3RhdGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VPYmplY3RzKHN0YXRlLnZhbHVlLCB0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gdHJhbnNhY3Rpb24ubmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHsgdmFsdWU6IGNsb25lVmFsdWUodHJhbnNhY3Rpb24ubmV3VmFsdWUpLCByZWNvcmRSZWY6IHJlY29yZFJlZiwgdHlwZTogdHJhbnNhY3Rpb24udHlwZSB9IGFzIFM7XG4gICAgICAgICAgICBzdGF0ZXMuc2V0KHRyYW5zYWN0aW9uLmlkLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZWNvcmRSZWYgb2YgdGhlIHByb3ZpZGVkIHN0YXRlIHdpdGggYWxsIHRoZSBjaGFuZ2VzIGluIHRoZSBzdGF0ZS4gQWNjZXB0cyBwcmltaXRpdmUgYW5kIG9iamVjdCB2YWx1ZSB0eXBlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSBTdGF0ZSB0byB1cGRhdGUgdmFsdWUgZm9yXG4gICAgICogQHJldHVybnMgdXBkYXRlZCB2YWx1ZSBpbmNsdWRpbmcgYWxsIHRoZSBjaGFuZ2VzIGluIHByb3ZpZGVkIHN0YXRlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVZhbHVlKHN0YXRlOiBTKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlVmFsdWVzKHN0YXRlLnJlY29yZFJlZiwgc3RhdGUudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBzZWNvbmQgdmFsdWVzIGluIGZpcnN0IHZhbHVlIGFuZCB0aGUgcmVzdWx0IGluIGVtcHR5IG9iamVjdC4gSWYgdmFsdWVzIGFyZSBwcmltaXRpdmUgdHlwZVxuICAgICAqIHJldHVybnMgc2Vjb25kIHZhbHVlIGlmIGV4aXN0cywgb3IgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGZpcnN0IFZhbHVlIHRvIG1lcmdlIGludG9cbiAgICAgKiBAcGFyYW0gc2Vjb25kIFZhbHVlIHRvIG1lcmdlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG1lcmdlVmFsdWVzPFU+KGZpcnN0OiBVLCBzZWNvbmQ6IFUpOiBVIHtcbiAgICAgICAgbGV0IHJlc3VsdDogVTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGZpcnN0KSB8fCBpc09iamVjdChzZWNvbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZU9iamVjdHMobWVyZ2VPYmplY3RzKHt9LCBmaXJzdCksIHNlY29uZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWNvbmQgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdfQ==