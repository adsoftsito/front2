/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Pipe } from '@angular/core';
import { cloneArray } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { GridBaseAPIService } from '../api.service';
/**
 * @hidden
 */
var IgxGridSortingPipe = /** @class */ (function () {
    function IgxGridSortingPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridSortingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expressions, id, pipeTrigger) {
        var /** @type {?} */ strategy;
        var /** @type {?} */ state = { expressions: [], strategy: strategy };
        state.expressions = this.gridAPI.get(id).sortingExpressions;
        if (!state.expressions.length) {
            return collection;
        }
        // DataUtil.sort needs a sorting strategy to start with, so it makes sense to start with the strategy from the first expression
        // sorting-strategy.ts, sortDataRecursive method then takes care and use the corresponding strategy for each expression
        strategy = expressions[0].strategy;
        state.strategy = strategy;
        return DataUtil.sort(cloneArray(collection), state);
    };
    IgxGridSortingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridSort',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxGridSortingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
    ]; };
    return IgxGridSortingPipe;
}());
export { IgxGridSortingPipe };
function IgxGridSortingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridSortingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridSortingPipe.ctorParameters;
    /** @type {?} */
    IgxGridSortingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
var IgxGridPreGroupingPipe = /** @class */ (function () {
    function IgxGridPreGroupingPipe(gridAPI) {
        this.gridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridPreGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expression, expansion, defaultExpanded, id, pipeTrigger) {
        var /** @type {?} */ state = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
        var /** @type {?} */ grid = this.gridAPI.get(id);
        state.expressions = grid.groupingExpressions;
        if (!state.expressions.length) {
            return {
                data: collection,
                metadata: collection
            };
        }
        state.expansion = grid.groupingExpansionState;
        state.defaultExpanded = grid.groupsExpanded;
        return DataUtil.group(cloneArray(collection), state);
    };
    IgxGridPreGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPreGroupBy',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxGridPreGroupingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
    ]; };
    return IgxGridPreGroupingPipe;
}());
export { IgxGridPreGroupingPipe };
function IgxGridPreGroupingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPreGroupingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPreGroupingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPreGroupingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
var IgxGridPostGroupingPipe = /** @class */ (function () {
    function IgxGridPostGroupingPipe(gridAPI) {
        this.gridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridPostGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        var /** @type {?} */ state = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
        var /** @type {?} */ grid = this.gridAPI.get(id);
        state.expressions = grid.groupingExpressions;
        if (!state.expressions.length) {
            return collection.data;
        }
        state.expansion = grid.groupingExpansionState;
        state.defaultExpanded = grid.groupsExpanded;
        return DataUtil.restoreGroups({
            data: cloneArray(collection.data),
            metadata: cloneArray(collection.metadata)
        }, state, groupsRecords);
    };
    IgxGridPostGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPostGroupBy',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxGridPostGroupingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
    ]; };
    return IgxGridPostGroupingPipe;
}());
export { IgxGridPostGroupingPipe };
function IgxGridPostGroupingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPostGroupingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPostGroupingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPostGroupingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
var IgxGridPagingPipe = /** @class */ (function () {
    function IgxGridPagingPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    IgxGridPagingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    function (collection, page, perPage, id, pipeTrigger) {
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = 15; }
        if (!this.gridAPI.get(id).paging) {
            return collection;
        }
        var /** @type {?} */ state = {
            index: page,
            recordsPerPage: perPage
        };
        var /** @type {?} */ result = {
            data: DataUtil.page(cloneArray(collection.data), state),
            metadata: DataUtil.page(cloneArray(collection.metadata), state)
        };
        this.gridAPI.get(id).pagingState = state;
        return result;
    };
    IgxGridPagingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPaging',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxGridPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
    ]; };
    return IgxGridPagingPipe;
}());
export { IgxGridPagingPipe };
function IgxGridPagingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPagingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPagingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPagingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
var IgxGridFilteringPipe = /** @class */ (function () {
    function IgxGridFilteringPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridFilteringPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expressionsTree, id, pipeTrigger) {
        var /** @type {?} */ grid = this.gridAPI.get(id);
        var /** @type {?} */ state = { expressionsTree: expressionsTree };
        if (!state.expressionsTree ||
            !state.expressionsTree.filteringOperands ||
            state.expressionsTree.filteringOperands.length === 0) {
            return collection;
        }
        var /** @type {?} */ result = DataUtil.filter(cloneArray(collection), state);
        grid.filteredData = result;
        return result;
    };
    IgxGridFilteringPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridFiltering',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    IgxGridFilteringPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
    ]; };
    return IgxGridFilteringPipe;
}());
export { IgxGridFilteringPipe };
function IgxGridFilteringPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridFilteringPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridFilteringPipe.ctorParameters;
    /** @type {?} */
    IgxGridFilteringPipe.prototype.gridAPI;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC9ncmlkLnBpcGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDOUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBTzNELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztJQVloRCw0QkFBb0IsT0FBaUQ7UUFBakQsWUFBTyxHQUFQLE9BQU8sQ0FBMEM7S0FBSzs7Ozs7Ozs7SUFFbkUsc0NBQVM7Ozs7Ozs7Y0FBQyxVQUFpQixFQUFFLFdBQXNELEVBQ3RGLEVBQVUsRUFBRSxXQUFtQjtRQUMvQixxQkFBSSxRQUEwQixDQUFDO1FBQy9CLHFCQUFNLEtBQUssR0FBRyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsUUFBUSxVQUFBLEVBQUUsQ0FBQztRQUM1QyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGtCQUFrQixDQUFDO1FBRTVELEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzVCLE1BQU0sQ0FBQyxVQUFVLENBQUM7U0FDckI7OztRQUlELFFBQVEsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQ25DLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBRTFCLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQzs7O2dCQXZCM0QsSUFBSSxTQUFDO29CQUNG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Q0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2xDLHFCQUFNLEtBQUssR0FBRyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsQ0FBQztRQUVuRCxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlO1lBQ3RCLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxpQkFBaUI7WUFDeEMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RCxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQ3JCO1FBRUQscUJBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzlELElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxNQUFNLENBQUM7OztnQkFyQnJCLElBQUksU0FBQztvQkFDRixJQUFJLEVBQUUsZUFBZTtvQkFDckIsSUFBSSxFQUFFLElBQUk7aUJBQ2I7Ozs7Z0JBOUlRLGtCQUFrQjs7K0JBVDNCOztTQXdKYSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjbG9uZUFycmF5IH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEYXRhVXRpbCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9kYXRhLXV0aWwnO1xuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZXN1bHQsIElTb3J0aW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRDb21wb25lbnQgfSBmcm9tICcuL2dyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vZ3JpZC1hcGkuc2VydmljZSc7XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZ3JpZFNvcnQnLFxuICAgIHB1cmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZFNvcnRpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4pIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbiB8IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBpZDogc3RyaW5nLCBwaXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuICAgICAgICBsZXQgc3RyYXRlZ3k6IElTb3J0aW5nU3RyYXRlZ3k7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBleHByZXNzaW9uczogW10sIHN0cmF0ZWd5IH07XG4gICAgICAgIHN0YXRlLmV4cHJlc3Npb25zID0gdGhpcy5ncmlkQVBJLmdldChpZCkuc29ydGluZ0V4cHJlc3Npb25zO1xuXG4gICAgICAgIGlmICghc3RhdGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERhdGFVdGlsLnNvcnQgbmVlZHMgYSBzb3J0aW5nIHN0cmF0ZWd5IHRvIHN0YXJ0IHdpdGgsIHNvIGl0IG1ha2VzIHNlbnNlIHRvIHN0YXJ0IHdpdGggdGhlIHN0cmF0ZWd5IGZyb20gdGhlIGZpcnN0IGV4cHJlc3Npb25cbiAgICAgICAgLy8gc29ydGluZy1zdHJhdGVneS50cywgc29ydERhdGFSZWN1cnNpdmUgbWV0aG9kIHRoZW4gdGFrZXMgY2FyZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHN0cmF0ZWd5IGZvciBlYWNoIGV4cHJlc3Npb25cbiAgICAgICAgc3RyYXRlZ3kgPSBleHByZXNzaW9uc1swXS5zdHJhdGVneTtcbiAgICAgICAgc3RhdGUuc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICAgICAgICByZXR1cm4gRGF0YVV0aWwuc29ydChjbG9uZUFycmF5KGNvbGxlY3Rpb24pLCBzdGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2dyaWRQcmVHcm91cEJ5JyxcbiAgICBwdXJlOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRQcmVHcm91cGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwcml2YXRlIGdyaWRBUEk6IElneEdyaWRBUElTZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50Pikge1xuICAgICAgICB0aGlzLmdyaWRBUEkgPSA8SWd4R3JpZEFQSVNlcnZpY2U+Z3JpZEFQSTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IGFueVtdLCBleHByZXNzaW9uOiBJU29ydGluZ0V4cHJlc3Npb24gfCBJU29ydGluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgZXhwYW5zaW9uOiBJR3JvdXBCeUV4cGFuZFN0YXRlIHwgSUdyb3VwQnlFeHBhbmRTdGF0ZVtdLCBkZWZhdWx0RXhwYW5kZWQ6IGJvb2xlYW4sXG4gICAgICAgIGlkOiBzdHJpbmcsIHBpcGVUcmlnZ2VyOiBudW1iZXIpOiBJR3JvdXBCeVJlc3VsdCB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGV4cHJlc3Npb25zOiBbXSwgZXhwYW5zaW9uOiBbXSwgZGVmYXVsdEV4cGFuZGVkIH07XG4gICAgICAgIGNvbnN0IGdyaWQ6IElneEdyaWRDb21wb25lbnQgPSB0aGlzLmdyaWRBUEkuZ2V0KGlkKTtcbiAgICAgICAgc3RhdGUuZXhwcmVzc2lvbnMgPSBncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogY29sbGVjdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmV4cGFuc2lvbiA9IGdyaWQuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZTtcbiAgICAgICAgc3RhdGUuZGVmYXVsdEV4cGFuZGVkID0gZ3JpZC5ncm91cHNFeHBhbmRlZDtcblxuICAgICAgICByZXR1cm4gRGF0YVV0aWwuZ3JvdXAoY2xvbmVBcnJheShjb2xsZWN0aW9uKSwgc3RhdGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdncmlkUG9zdEdyb3VwQnknLFxuICAgIHB1cmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZFBvc3RHcm91cGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwcml2YXRlIGdyaWRBUEk6IElneEdyaWRBUElTZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50Pikge1xuICAgICAgICB0aGlzLmdyaWRBUEkgPSA8SWd4R3JpZEFQSVNlcnZpY2U+Z3JpZEFQSTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IElHcm91cEJ5UmVzdWx0LCBleHByZXNzaW9uOiBJU29ydGluZ0V4cHJlc3Npb24gfCBJU29ydGluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgZXhwYW5zaW9uOiBJR3JvdXBCeUV4cGFuZFN0YXRlIHwgSUdyb3VwQnlFeHBhbmRTdGF0ZVtdLCBkZWZhdWx0RXhwYW5kZWQ6IGJvb2xlYW4sXG4gICAgICAgIGlkOiBzdHJpbmcsIGdyb3Vwc1JlY29yZHM6IGFueVtdLCBwaXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBleHByZXNzaW9uczogW10sIGV4cGFuc2lvbjogW10sIGRlZmF1bHRFeHBhbmRlZCB9O1xuICAgICAgICBjb25zdCBncmlkOiBJZ3hHcmlkQ29tcG9uZW50ID0gdGhpcy5ncmlkQVBJLmdldChpZCk7XG4gICAgICAgIHN0YXRlLmV4cHJlc3Npb25zID0gZ3JpZC5ncm91cGluZ0V4cHJlc3Npb25zO1xuXG4gICAgICAgIGlmICghc3RhdGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZXhwYW5zaW9uID0gZ3JpZC5ncm91cGluZ0V4cGFuc2lvblN0YXRlO1xuICAgICAgICBzdGF0ZS5kZWZhdWx0RXhwYW5kZWQgPSBncmlkLmdyb3Vwc0V4cGFuZGVkO1xuXG4gICAgICAgIHJldHVybiBEYXRhVXRpbC5yZXN0b3JlR3JvdXBzKHtcbiAgICAgICAgICAgIGRhdGE6IGNsb25lQXJyYXkoY29sbGVjdGlvbi5kYXRhKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjbG9uZUFycmF5KGNvbGxlY3Rpb24ubWV0YWRhdGEpXG4gICAgICAgIH0sIHN0YXRlLCBncm91cHNSZWNvcmRzKTtcbiAgICB9XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZ3JpZFBhZ2luZycsXG4gICAgcHVyZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkUGFnaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQ+KSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogSUdyb3VwQnlSZXN1bHQsIHBhZ2UgPSAwLCBwZXJQYWdlID0gMTUsIGlkOiBzdHJpbmcsIHBpcGVUcmlnZ2VyOiBudW1iZXIpOiBJR3JvdXBCeVJlc3VsdCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdyaWRBUEkuZ2V0KGlkKS5wYWdpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBpbmRleDogcGFnZSxcbiAgICAgICAgICAgIHJlY29yZHNQZXJQYWdlOiBwZXJQYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBJR3JvdXBCeVJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IERhdGFVdGlsLnBhZ2UoY2xvbmVBcnJheShjb2xsZWN0aW9uLmRhdGEpLCBzdGF0ZSksXG4gICAgICAgICAgICBtZXRhZGF0YTogRGF0YVV0aWwucGFnZShjbG9uZUFycmF5KGNvbGxlY3Rpb24ubWV0YWRhdGEpLCBzdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmlkQVBJLmdldChpZCkucGFnaW5nU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZ3JpZEZpbHRlcmluZycsXG4gICAgcHVyZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRmlsdGVyaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQ+KSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogYW55W10sIGV4cHJlc3Npb25zVHJlZTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSxcbiAgICAgICAgaWQ6IHN0cmluZywgcGlwZVRyaWdnZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5ncmlkQVBJLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBleHByZXNzaW9uc1RyZWU6IGV4cHJlc3Npb25zVHJlZSB9O1xuXG4gICAgICAgIGlmICghc3RhdGUuZXhwcmVzc2lvbnNUcmVlIHx8XG4gICAgICAgICAgICAhc3RhdGUuZXhwcmVzc2lvbnNUcmVlLmZpbHRlcmluZ09wZXJhbmRzIHx8XG4gICAgICAgICAgICBzdGF0ZS5leHByZXNzaW9uc1RyZWUuZmlsdGVyaW5nT3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IERhdGFVdGlsLmZpbHRlcihjbG9uZUFycmF5KGNvbGxlY3Rpb24pLCBzdGF0ZSk7XG4gICAgICAgIGdyaWQuZmlsdGVyZWREYXRhID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdfQ==