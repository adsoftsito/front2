/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, ElementRef, TemplateRef, NgZone, ChangeDetectorRef, ComponentFactoryResolver, IterableDiffers, ViewContainerRef, Inject, HostBinding, forwardRef } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseComponent, IgxGridTransaction } from '../grid-base.component';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxTextHighlightDirective } from '../../directives/text-highlight/text-highlight.directive';
import { IgxGroupByRowTemplateDirective } from './grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { DataUtil } from '../../data-operations/data-util';
import { IgxSelectionAPIService } from '../../core/selection';
import { DOCUMENT } from '@angular/common';
import { IgxGridSortingPipe } from './grid.pipes';
import { takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
var /** @type {?} */ NEXT_ID = 0;
/**
 * @record
 */
export function IGridFocusChangeEventArgs() { }
function IGridFocusChangeEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IGridFocusChangeEventArgs.prototype.groupRow;
}
/**
 * @record
 */
export function IGroupingDoneEventArgs() { }
function IGroupingDoneEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.expressions;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.groupedColumns;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.ungroupedColumns;
}
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
var IgxGridComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxGridComponent, _super);
    function IgxGridComponent(gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService) {
        var _this = _super.call(this, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService) || this;
        _this.document = document;
        _this._id = "igx-grid-" + NEXT_ID++;
        /**
         * @hidden
         */
        _this._groupingExpressions = [];
        /**
         * @hidden
         */
        _this._groupingExpandState = [];
        _this._hideGroupedColumns = false;
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsRecords = [];
        /**
         * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.dropAreaMessage = 'Drag a column header and drop it here to group by that column.';
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onGroupingDone = new EventEmitter();
        _this.onFocusChange = new EventEmitter();
        _this._gridAPI = /** @type {?} */ (gridAPI);
        return _this;
    }
    Object.defineProperty(IgxGridComponent.prototype, "id", {
        get: /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._id !== value) {
                var /** @type {?} */ oldId = this._id;
                this._id = value;
                this._gridAPI.reset(oldId, this._id);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpressions", {
        get: /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpressions;
        },
        /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (value && value.length > 10) {
                throw Error('Maximum amount of grouped columns is 10.');
            }
            var /** @type {?} */ oldExpressions = this.groupingExpressions;
            var /** @type {?} */ newExpressions = value;
            this._groupingExpressions = cloneArray(value);
            this.chipsGoupingExpressions = cloneArray(value);
            if (this._gridAPI.get(this.id)) {
                this._gridAPI.arrange_sorting_expressions(this.id);
                /* grouping should work in conjunction with sorting
                            and without overriding separate sorting expressions */
                this._applyGrouping();
                this.cdr.markForCheck();
            }
            else {
                // setter called before grid is registered in grid API service
                this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
            }
            if (JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
                var /** @type {?} */ groupedCols_1 = [];
                var /** @type {?} */ ungroupedCols_1 = [];
                var /** @type {?} */ groupedColsArr = newExpressions.filter(function (obj) {
                    return !oldExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                groupedColsArr.forEach(function (elem) {
                    groupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                var /** @type {?} */ ungroupedColsArr = oldExpressions.filter(function (obj) {
                    return !newExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                ungroupedColsArr.forEach(function (elem) {
                    ungroupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                var /** @type {?} */ groupingDoneArgs = {
                    expressions: newExpressions,
                    groupedColumns: groupedCols_1,
                    ungroupedColumns: ungroupedCols_1
                };
                this.onGroupingDone.emit(groupingDoneArgs);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpansionState", {
        get: /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpandState;
        },
        /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var /** @type {?} */ activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
            var /** @type {?} */ highlightItem = null;
            if (this.collapsedHighlightedItem) {
                highlightItem = this.collapsedHighlightedItem.item;
            }
            else if (this.lastSearchInfo.matchInfoCache.length) {
                highlightItem = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex].item;
            }
            this._groupingExpandState = cloneArray(value);
            this.refreshSearch();
            if (highlightItem !== null && this.groupingExpressions.length) {
                var /** @type {?} */ index = this.filteredSortedData.indexOf(highlightItem);
                var /** @type {?} */ groupRow = this.getGroupByRecords()[index];
                if (!this.isExpandedGroup(groupRow)) {
                    IgxTextHighlightDirective.clearActiveHighlight(this.id);
                    this.collapsedHighlightedItem = {
                        info: activeInfo,
                        item: highlightItem
                    };
                }
                else if (this.collapsedHighlightedItem !== null) {
                    var /** @type {?} */ collapsedInfo = this.collapsedHighlightedItem.info;
                    IgxTextHighlightDirective.setActiveHighlight(this.id, {
                        columnIndex: collapsedInfo.columnIndex,
                        rowIndex: collapsedInfo.rowIndex,
                        index: collapsedInfo.index,
                        page: collapsedInfo.page
                    });
                }
            }
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "hideGroupedColumns", {
        get: /**
         * An \@Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._hideGroupedColumns;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
            }
            else {
                this.groupingDiffer = null;
            }
            if (this.columnList && this.groupingExpressions) {
                this._setGroupColsVisibility(value);
            }
            this._hideGroupedColumns = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupsRowList", {
        get: /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            var /** @type {?} */ res = new QueryList();
            if (!this._groupsRowList) {
                return res;
            }
            var /** @type {?} */ rList = this._groupsRowList.filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            });
            res.reset(rList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaHostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            switch (this.displayDensity) {
                case "cosy" /* cosy */:
                    return 'igx-drop-area--cosy';
                case "compact" /* compact */:
                    return 'igx-drop-area--compact';
                default:
                    return 'igx-drop-area';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupRowTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupRowTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupRowTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupAreaTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupAreaTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {...?} rest
     * @return {?}
     */
    IgxGridComponent.prototype.groupBy = /**
     * @param {...?} rest
     * @return {?}
     */
    function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        this.endEdit(true);
        this._gridAPI.submit_value(this.id);
        if (rest.length === 1 && rest[0] instanceof Array) {
            this._groupByMultiple(rest[0]);
        }
        else {
            this._groupBy(rest[0]);
        }
        this.cdr.detectChanges();
        this.calculateGridSizes();
        this.restoreHighlight();
    };
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    IgxGridComponent.prototype.clearGrouping = /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        this._gridAPI.clear_groupby(this.id, name);
        this.calculateGridSizes();
        this.restoreHighlight();
    };
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    IgxGridComponent.prototype.isExpandedGroup = /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    function (group) {
        var /** @type {?} */ state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    };
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype.toggleGroup = /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._toggleGroup(groupRow);
    };
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxGridComponent.prototype.isGroupByRecord = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    };
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    IgxGridComponent.prototype.toggleAllGroupRows = /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    function () {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.cdr.detectChanges();
    };
    Object.defineProperty(IgxGridComponent.prototype, "hasGroupableColumns", {
        /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.groupable; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    IgxGridComponent.prototype._setGroupColsVisibility = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.groupingExpressions.forEach(function (expr) {
            var /** @type {?} */ col = _this.getColumnByName(expr.fieldName);
            col.hidden = value;
        });
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaVisible", {
        get: /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return (this.draggedColumn && this.draggedColumn.groupable) ||
                !this.chipsGoupingExpressions.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    IgxGridComponent.prototype._groupBy = /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        this._gridAPI.groupBy(this.id, expression.fieldName, expression.dir, expression.ignoreCase, expression.strategy);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} expressions
     * @return {?}
     */
    IgxGridComponent.prototype._groupByMultiple = /**
     * @hidden
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        this._gridAPI.groupBy_multiple(this.id, expressions);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._getStateForGroupRow = /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(this.id, groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._toggleGroup = /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._gridAPI.groupBy_toggle_group(this.id, groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype._applyGrouping = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._gridAPI.sort_multiple(this.id, this._groupingExpressions);
    };
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    IgxGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        return {
            $implicit: rowData,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : 'dataRow'
        };
    };
    // This method's idea is to get by how much each data row is offset by the group by rows before it.
    /**
    * @hidden
    */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupIncrementData = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.groupingExpressions && this.groupingExpressions.length) {
            var /** @type {?} */ groupsRecords = this.getGroupByRecords();
            var /** @type {?} */ groupByIncrements_1 = [];
            var /** @type {?} */ values_1 = [];
            var /** @type {?} */ prevHierarchy_1 = null;
            var /** @type {?} */ increment_1 = 0;
            groupsRecords.forEach(function (gbr) {
                if (values_1.indexOf(gbr) === -1) {
                    var /** @type {?} */ levelIncrement = 1;
                    if (prevHierarchy_1 !== null) {
                        levelIncrement += _this.getLevelIncrement(0, gbr.groupParent, prevHierarchy_1.groupParent);
                    }
                    else {
                        // This is the first level we stumble upon, so we haven't accounted for any of its parents
                        levelIncrement += gbr.level;
                    }
                    increment_1 += levelIncrement;
                    prevHierarchy_1 = gbr;
                    values_1.push(gbr);
                }
                groupByIncrements_1.push(increment_1);
            });
            return groupByIncrements_1;
        }
        else {
            return null;
        }
    };
    /**
     * @param {?} currentIncrement
     * @param {?} currentHierarchy
     * @param {?} prevHierarchy
     * @return {?}
     */
    IgxGridComponent.prototype.getLevelIncrement = /**
     * @param {?} currentIncrement
     * @param {?} currentHierarchy
     * @param {?} prevHierarchy
     * @return {?}
     */
    function (currentIncrement, currentHierarchy, prevHierarchy) {
        if (currentHierarchy !== prevHierarchy && !!prevHierarchy && !!currentHierarchy) {
            return this.getLevelIncrement(++currentIncrement, currentHierarchy.groupParent, prevHierarchy.groupParent);
        }
        else {
            return currentIncrement;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupByRecords = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.groupingExpressions && this.groupingExpressions.length) {
            var /** @type {?} */ state = {
                expressions: this.groupingExpressions,
                expansion: this.groupingExpansionState,
                defaultExpanded: this.groupsExpanded
            };
            return DataUtil.group(cloneArray(this.filteredSortedData), state).metadata;
        }
        else {
            return null;
        }
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipRemoved = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.clearGrouping(event.owner.id);
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.chipsOrderChanged = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ newGrouping = [];
        var _loop_1 = function (i) {
            var /** @type {?} */ expr = this_1.groupingExpressions.filter(function (item) {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this_1.getColumnByName(expr.fieldName).groupable) {
                return { value: void 0 };
            }
            newGrouping.push(expr);
        };
        var this_1 = this;
        for (var /** @type {?} */ i = 0; i < event.chipsArray.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.markForCheck();
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.chipsMovingEnded = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.markForCheck();
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipClicked = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ sortingExpr = this.sortingExpressions;
        var /** @type {?} */ columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.markForCheck();
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipKeyDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            var /** @type {?} */ sortingExpr = this.sortingExpressions;
            var /** @type {?} */ columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.markForCheck();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupAreaHeight = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    };
    /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    IgxGridComponent.prototype.getPinnedWidth = /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    function (takeHidden) {
        if (takeHidden === void 0) { takeHidden = false; }
        var /** @type {?} */ sum = _super.prototype.getPinnedWidth.call(this, takeHidden);
        if (this.groupingExpressions.length > 0 && this.headerGroupContainer) {
            sum += this.headerGroupContainer.nativeElement.clientWidth;
        }
        return sum;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} row
     * @param {?} column
     * @param {?} page
     * @param {?=} groupByRecord
     * @return {?}
     */
    IgxGridComponent.prototype.scrollTo = /**
     * @hidden
     * @param {?} row
     * @param {?} column
     * @param {?} page
     * @param {?=} groupByRecord
     * @return {?}
     */
    function (row, column, page, groupByRecord) {
        if (groupByRecord && !this.isExpandedGroup(groupByRecord)) {
            this.toggleGroup(groupByRecord);
        }
        _super.prototype.scrollTo.call(this, row, column, page, groupByRecord);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.resolveFilteredSortedData = /**
     * @hidden
     * @return {?}
     */
    function () {
        var /** @type {?} */ data = _super.prototype.resolveFilteredSortedData.call(this);
        if (this.sortingExpressions &&
            this.sortingExpressions.length > 0) {
            var /** @type {?} */ sortingPipe = new IgxGridSortingPipe(this._gridAPI);
            data = sortingPipe.transform(data, this.sortingExpressions, this.id, -1);
        }
        return data;
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaTemplateResolved", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.dropAreaTemplate) {
                return this.dropAreaTemplate;
            }
            else {
                return this.defaultDropAreaTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        _super.prototype.ngAfterContentInit.call(this);
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe(function () { return _this.endEdit(true); });
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.groupingDiffer) {
            var /** @type {?} */ changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem(function (rec) {
                    var /** @type {?} */ col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem(function (rec) {
                    var /** @type {?} */ col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    };
    IgxGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    providers: [IgxGridNavigationService,
                        { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxGridComponent; }) },
                        IgxFilteringService
                    ],
                    selector: 'igx-grid',
                    template: "<igx-grid-toolbar role=\"rowgroup\" [style.width.px]=\"calcWidth\" *ngIf=\"shouldShowToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div [style.width.px]='calcWidth' class=\"igx-grid__grouparea\" *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [removable]=\"getColumnByName(expr.fieldName).groupable\" [draggable]=\"getColumnByName(expr.fieldName).groupable\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\" (onClick)=\"getColumnByName(expr.fieldName).groupable ? onChipClicked($event): null\" [disabled]='!getColumnByName(expr.fieldName).groupable'>\n                    <span>{{ getColumnByName(expr.fieldName).header || expr.fieldName }}</span>\n                    <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\" >arrow_forward</igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\">\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n    <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-container *ngIf=\"groupingExpressions.length > 0\">\n            <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\" #headerGroupContainer>\n                <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\" (click)=\"toggleAllGroupRows()\">reorder</igx-icon>\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"rowSelectable\">\n            <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer>\n                <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"pinnedColumns.length > 0\">\n            <ng-template ngFor let-col [ngForOf]=\"onlyTopLevel(pinnedColumns)\">\n                <div class=\"igx-grid__thead-item igx-grid__th--pinned\">\n                    <igx-grid-header [igxColumnMovingDrag]=\"col\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"col\" [gridID]=\"id\"\n                        [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\" [style.max-width.px]='col.width'></igx-grid-header>\n                    <igx-grid-filtering-cell *ngIf=\"allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col\"\n                        [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>\n                </div>\n            </ng-template>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"onlyTopLevel(unpinnedColumns)\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n            [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #headerContainer>\n            <div class=\"igx-grid__thead-item\">\n                <igx-grid-header [igxColumnMovingDrag]=\"col\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"col\" [gridID]=\"id\" [column]=\"col\"\n                    [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-header>\n                <igx-grid-filtering-cell *ngIf=\"allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col\" [column]=\"col\"\n                    [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>\n            </div>\n        </ng-template>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    </div>\n    <igx-grid-filtering-row *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n</div>\n\n<div class=\"igx-grid__tbody\" role=\"rowgroup\" [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)' (wheel)=\"wheelHandler()\">\n    <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n    <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-template igxGridFor let-rowData [igxGridForOf]=\"data | gridTransaction:id:pipeTrigger\n    | gridFiltering:filteringExpressionsTree:id:pipeTrigger\n    | gridSort:sortingExpressions:id:pipeTrigger\n    | gridPreGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:pipeTrigger\n    | gridPaging:page:perPage:id:pipeTrigger\n    | gridPostGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\"\n    let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"\n    [igxForContainerSize]='calcHeight' [igxForItemSize]=\"rowHeight\" #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n        <ng-template #record_template>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-container *igxTemplateOutlet=\"isGroupByRecord(rowData) ? group_template : record_template; context: getContext(rowData) \"></ng-container>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.width.px]='calcWidth' #tfoot>\n    <div *ngIf=\"hasSummarizedColumns\" class=\"igx-grid__summaries\" [style.height.px]=\"summariesHeight\" role=\"row\" #summaries>\n        <ng-container *ngIf=\"groupingExpressions.length > 0\">\n            <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n        </ng-container>\n        <ng-container *ngIf=\"summariesMargin\">\n            <div\n            class=\"igx-grid__summaries-patch\"\n            [style.min-width.px]=\"summariesMargin\"\n            [style.flex-basis.px]=\"summariesMargin\"\n            ></div>\n        </ng-container>\n        <ng-container *ngIf=\"pinnedColumns.length > 0\">\n            <igx-grid-summary [gridID]=\"id\" *ngFor=\"let col of notGroups(pinnedColumns)\"  [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width'></igx-grid-summary>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"notGroups(unpinnedColumns)\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\" [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #summaryContainer>\n            <igx-grid-summary [gridID]=\"id\" [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width'></igx-grid-summary>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\"></ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\"></ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
                },] },
    ];
    /** @nocollapse */
    IgxGridComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
        { type: IgxSelectionAPIService, },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] },] },
        { type: ElementRef, },
        { type: NgZone, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: ChangeDetectorRef, },
        { type: ComponentFactoryResolver, },
        { type: IterableDiffers, },
        { type: ViewContainerRef, },
        { type: IgxGridNavigationService, },
        { type: IgxFilteringService, },
    ]; };
    IgxGridComponent.propDecorators = {
        "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
        "groupingExpressions": [{ type: Input },],
        "groupingExpansionState": [{ type: Input },],
        "groupsExpanded": [{ type: Input },],
        "hideGroupedColumns": [{ type: Input },],
        "dropAreaMessage": [{ type: Input },],
        "dropAreaTemplate": [{ type: Input },],
        "onGroupingDone": [{ type: Output },],
        "onFocusChange": [{ type: Output },],
        "groupTemplate": [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] },],
        "_groupsRowList": [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] },],
        "defaultDropAreaTemplate": [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef },] },],
        "groupArea": [{ type: ViewChild, args: ['groupArea',] },],
    };
    return IgxGridComponent;
}(IgxGridBaseComponent));
export { IgxGridComponent };
function IgxGridComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxGridComponent.propDecorators;
    /** @type {?} */
    IgxGridComponent.prototype._id;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupingExpressions;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupingExpandState;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupRowTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupingDiffer;
    /** @type {?} */
    IgxGridComponent.prototype._hideGroupedColumns;
    /** @type {?} */
    IgxGridComponent.prototype._gridAPI;
    /**
     * An \@Input property that determines whether created groups are rendered expanded or collapsed.
     * The default rendered state is expanded.
     * ```html
     * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsExpanded;
    /**
     * A hierarchical representation of the group by records.
     * ```typescript
     * let groupRecords = this.grid.groupsRecords;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsRecords;
    /**
     * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaMessage;
    /**
     * An \@Input property that sets the template that will be rendered as a GroupBy drop area.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid [dropAreaTemplate]="dropAreaRef">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     *
     * <ng-template #myDropArea>
     *      <span> Custom drop area! </span>
     * </ng-template>
     * ```
     * ```ts
     * \@ViewChild('myDropArea', { read: TemplateRef })
     * public dropAreaRef: TemplateRef<any>;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaTemplate;
    /**
     * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
     * grouped/ungrouped at once by using the Group By API.
     * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
     * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
     * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
     * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
     * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
     * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
     * columns.
     * ```typescript
     * groupingDone(event: IGroupingDoneEventArgs){
     *     const expressions = event.expressions;
     *     //the newly grouped columns
     *     const groupedColumns = event.groupedColumns;
     *     //the newly ungrouped columns
     *     const ungroupedColumns = event.ungroupedColumns;
     * }
     * ```
     * ```html
     * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.onGroupingDone;
    /** @type {?} */
    IgxGridComponent.prototype.onFocusChange;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupTemplate;
    /** @type {?} */
    IgxGridComponent.prototype._groupsRowList;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.defaultDropAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupArea;
    /** @type {?} */
    IgxGridComponent.prototype.document;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLHVCQUF1QixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQ2hHLFNBQVMsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBVyxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsd0JBQXdCLEVBQzNHLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLEVBQW9CLFdBQVcsRUFBRSxVQUFVLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDeEgsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUF5QixNQUFNLHdCQUF3QixDQUFDO0FBQ3pHLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXZELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSwwREFBMEQsQ0FBQztBQUVyRyxPQUFPLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUtyRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0QsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFB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bUI7cUJBQ3RCO29CQUNELFFBQVEsRUFBRSxVQUFVO29CQUNwQixRQUFRLEVBQUUsdXhZQWtMYjtpQkFDQTs7OztnQkEvT1Esa0JBQWtCO2dCQWVsQixzQkFBc0I7Z0RBa1J0QixNQUFNLFNBQUMsa0JBQWtCO2dCQW5TUixVQUFVO2dCQUF3QixNQUFNO2dEQXNTekQsTUFBTSxTQUFDLFFBQVE7Z0JBdFM0QyxpQkFBaUI7Z0JBQUUsd0JBQXdCO2dCQUMzRyxlQUFlO2dCQUFFLGdCQUFnQjtnQkFHNUIsd0JBQXdCO2dCQW9CeEIsbUJBQW1COzs7dUJBeVB2QixXQUFXLFNBQUMsU0FBUyxjQUNyQixLQUFLO3dDQXVDTCxLQUFLOzJDQXdFTCxLQUFLO21DQTZETCxLQUFLO3VDQW9CTCxLQUFLO29DQTRCTCxLQUFLO3FDQXFCTCxLQUFLO21DQTJCTCxNQUFNO2tDQUdOLE1BQU07a0NBTU4sWUFBWSxTQUFDLDhCQUE4QixFQUFFLEVBQUUsSUFBSSxFQUFFLDhCQUE4QixFQUFFO21DQUdyRixZQUFZLFNBQUMsMEJBQTBCLEVBQUUsRUFBRSxJQUFJLEVBQUUsMEJBQTBCLEVBQUU7NENBTTdFLFNBQVMsU0FBQyxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7OEJBeUJsRCxTQUFTLFNBQUMsV0FBVzs7MkJBMWtCMUI7RUFtUHNDLG9CQUFvQjtTQUE3QyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENvbnRlbnRDaGlsZCwgVmlld0NoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdCwgVmlld0NoaWxkLCBFbGVtZW50UmVmLCBUZW1wbGF0ZVJlZiwgRG9DaGVjaywgTmdab25lLCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycywgVmlld0NvbnRhaW5lclJlZiwgSW5qZWN0LCBBZnRlckNvbnRlbnRJbml0LCBIb3N0QmluZGluZywgZm9yd2FyZFJlZiwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgSWd4R3JpZFRyYW5zYWN0aW9uLCBJRm9jdXNDaGFuZ2VFdmVudEFyZ3MgfSBmcm9tICcuLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi9ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IGNsb25lQXJyYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneFRleHRIaWdobGlnaHREaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3RleHQtaGlnaGxpZ2h0L3RleHQtaGlnaGxpZ2h0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9ncmlkLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSBmcm9tICcuL2dyb3VwYnktcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eSB9IGZyb20gJy4uLy4uL2NvcmUvZGlzcGxheURlbnNpdHknO1xuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUJhc2VDaGlwRXZlbnRBcmdzLCBJQ2hpcENsaWNrRXZlbnRBcmdzLCBJQ2hpcEtleURvd25FdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJQ2hpcHNBcmVhUmVvcmRlckV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXBzLWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7IERhdGFVdGlsIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQgeyBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY29yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TZXJ2aWNlLCBUcmFuc2FjdGlvbiwgU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hHcmlkQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRTb3J0aW5nUGlwZSB9IGZyb20gJy4vZ3JpZC5waXBlcyc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuLi9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneEZpbHRlcmluZ1NlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmcuc2VydmljZSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBJR3JpZEZvY3VzQ2hhbmdlRXZlbnRBcmdzIGV4dGVuZHMgSUZvY3VzQ2hhbmdlRXZlbnRBcmdzIHtcbiAgICBncm91cFJvdzogSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIElHcm91cGluZ0RvbmVFdmVudEFyZ3Mge1xuICAgIGV4cHJlc3Npb25zOiBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+IHwgSVNvcnRpbmdFeHByZXNzaW9uO1xuICAgIGdyb3VwZWRDb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIHVuZ3JvdXBlZENvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQ7XG59XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgR3JpZCoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBHcmlkIGlzIHVzZWQgZm9yIHByZXNlbnRpbmcgYW5kIG1hbmlwdWxhdGluZyB0YWJ1bGFyIGRhdGEgaW4gdGhlIHNpbXBsZXN0IHdheSBwb3NzaWJsZS4gIE9uY2UgZGF0YVxuICogaGFzIGJlZW4gYm91bmQsIGl0IGNhbiBiZSBtYW5pcHVsYXRlZCB0aHJvdWdoIGZpbHRlcmluZywgc29ydGluZyAmIGVkaXRpbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIGF1dG9HZW5lcmF0ZT1cImZhbHNlXCI+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwiZmlyc3RcIiBoZWFkZXI9XCJGaXJzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImxhc3RcIiBoZWFkZXI9XCJMYXN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwicm9sZVwiIGhlYWRlcj1cIlJvbGVcIj48L2lneC1jb2x1bW4+XG4gKiA8L2lneC1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHByb3ZpZGVyczogW0lneEdyaWROYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBHcmlkQmFzZUFQSVNlcnZpY2UsIHVzZUNsYXNzOiBJZ3hHcmlkQVBJU2VydmljZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWRCYXNlQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJZ3hHcmlkQ29tcG9uZW50KSB9LFxuICAgICAgICBJZ3hGaWx0ZXJpbmdTZXJ2aWNlXG4gICAgXSxcbiAgICBzZWxlY3RvcjogJ2lneC1ncmlkJyxcbiAgICB0ZW1wbGF0ZTogYDxpZ3gtZ3JpZC10b29sYmFyIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS53aWR0aC5weF09XCJjYWxjV2lkdGhcIiAqbmdJZj1cInNob3VsZFNob3dUb29sYmFyXCIgW2dyaWRJRF09XCJpZFwiIFtkaXNwbGF5RGVuc2l0eV09XCJkaXNwbGF5RGVuc2l0eVwiICN0b29sYmFyPlxuPC9pZ3gtZ3JpZC10b29sYmFyPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRQYWdlciBsZXQtYXBpPlxuICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImFwaS5pc0ZpcnN0UGFnZVwiIChjbGljayk9XCJhcGkucGFnaW5hdGUoMClcIiBpZ3hCdXR0b249XCJpY29uXCIgaWd4UmlwcGxlIGlneFJpcHBsZUNlbnRlcmVkPVwidHJ1ZVwiPlxuICAgICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+Zmlyc3RfcGFnZTwvaWd4LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiYXBpLmlzRmlyc3RQYWdlXCIgKGNsaWNrKT1cImFwaS5wcmV2aW91c1BhZ2UoKVwiIGlneEJ1dHRvbj1cImljb25cIiBpZ3hSaXBwbGUgaWd4UmlwcGxlQ2VudGVyZWQ9XCJ0cnVlXCI+XG4gICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5jaGV2cm9uX2xlZnQ8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxzcGFuPnt7IGFwaS5wYWdlICsgMSB9fSBvZiB7eyBhcGkudG90YWxQYWdlcyB9fTwvc3Bhbj5cbiAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCJhcGkuaXNMYXN0UGFnZVwiIChjbGljayk9XCJhcGkubmV4dFBhZ2UoKVwiIGlneFJpcHBsZSBpZ3hSaXBwbGVDZW50ZXJlZD1cInRydWVcIiBpZ3hCdXR0b249XCJpY29uXCI+XG4gICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5jaGV2cm9uX3JpZ2h0PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiYXBpLmlzTGFzdFBhZ2VcIiAoY2xpY2spPVwiYXBpLnBhZ2luYXRlKGFwaS50b3RhbFBhZ2VzIC0gMSlcIiBpZ3hCdXR0b249XCJpY29uXCIgaWd4UmlwcGxlIGlneFJpcHBsZUNlbnRlcmVkPVwidHJ1ZVwiPlxuICAgICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+bGFzdF9wYWdlPC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8c2VsZWN0IHN0eWxlPVwibWFyZ2luLWxlZnQ6IDFyZW07XCIgKGNoYW5nZSk9XCJhcGkucGVyUGFnZSA9ICRldmVudC50YXJnZXQudmFsdWVcIj5cbiAgICAgICAgICAgIDxvcHRpb24gW3ZhbHVlXT1cInZhbFwiIFtzZWxlY3RlZF09XCJhcGkucGVyUGFnZSA9PSB2YWxcIiAqbmdGb3I9XCJsZXQgdmFsIG9mIFs1LCAxMCwgMTUsIDI1LCA1MCwgMTAwLCA1MDBdXCI+e3sgdmFsIH19PC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG48L25nLXRlbXBsYXRlPlxuXG48ZGl2IFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgY2xhc3M9XCJpZ3gtZ3JpZF9fZ3JvdXBhcmVhXCIgKm5nSWY9XCJncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDAgfHwgaGFzR3JvdXBhYmxlQ29sdW1uc1wiICNncm91cEFyZWE+XG4gICAgPGlneC1jaGlwcy1hcmVhIChvblJlb3JkZXIpPVwiY2hpcHNPcmRlckNoYW5nZWQoJGV2ZW50KVwiIChvbk1vdmVFbmQpPVwiY2hpcHNNb3ZpbmdFbmRlZCgpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGV4cHIgb2YgY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgIDxpZ3gtY2hpcCBbaWRdPVwiZXhwci5maWVsZE5hbWVcIiBbcmVtb3ZhYmxlXT1cImdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSkuZ3JvdXBhYmxlXCIgW2RyYWdnYWJsZV09XCJnZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmdyb3VwYWJsZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJkaXNwbGF5RGVuc2l0eVwiXG4gICAgICAgICAgICAgICAgKG9uS2V5RG93bik9XCJvbkNoaXBLZXlEb3duKCRldmVudClcIiAob25SZW1vdmUpPVwib25DaGlwUmVtb3ZlZCgkZXZlbnQpXCIgKG9uQ2xpY2spPVwiZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKS5ncm91cGFibGUgPyBvbkNoaXBDbGlja2VkKCRldmVudCk6IG51bGxcIiBbZGlzYWJsZWRdPSchZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKS5ncm91cGFibGUnPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyBnZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmhlYWRlciB8fCBleHByLmZpZWxkTmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uIGlneFN1ZmZpeD57eyBleHByLmRpciA9PSAxID8gJ2Fycm93X3Vwd2FyZCcgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX19ncm91cGFyZWEtY29ubmVjdG9yXCI+XG4gICAgICAgICAgICAgICAgPGlneC1pY29uIFtzdHlsZS52aXNpYmlsaXR5XT1cIighbGFzdCB8fCBkcm9wQXJlYVZpc2libGUpID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcIiA+YXJyb3dfZm9yd2FyZDwvaWd4LWljb24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2IGlneEdyb3VwQXJlYURyb3AgW3N0eWxlLnZpc2liaWxpdHldPVwiZHJvcEFyZWFWaXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcIiBbY2xhc3NdPVwiZ3JvdXBBcmVhSG9zdENsYXNzXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHJvcEFyZWFUZW1wbGF0ZVJlc29sdmVkXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvaWd4LWNoaXBzLWFyZWE+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX190aGVhZFwiIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgI3RoZWFkUm93PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJcIiBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnIHJvbGU9XCJyb3dcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoIDw9IDBcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1sZWZ0XCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW4gJiYgcGlubmVkQ29sdW1ucy5sZW5ndGggPiAwXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJsZWZ0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcGlubmVkXCIgW3N0eWxlLmxlZnQucHhdPVwicGlubmVkV2lkdGhcIj48L3NwYW4+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9faGVhZGVyLWluZGVudGF0aW9uIGlneC1ncmlkX19yb3ctaW5kZW50YXRpb24tLWxldmVsLXt7Z3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGh9fVwiICNoZWFkZXJHcm91cENvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8aWd4LWljb24gcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwiaWd4LWdyaWRfX2dyb3VwLWV4cGFuZC1idG5cIiAoY2xpY2spPVwidG9nZ2xlQWxsR3JvdXBSb3dzKClcIj5yZW9yZGVyPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInJvd1NlbGVjdGFibGVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fY2J4LXNlbGVjdGlvblwiICNoZWFkZXJDaGVja2JveENvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8aWd4LWNoZWNrYm94IFtjaGVja2VkXT1cImFsbFJvd3NTZWxlY3RlZFwiIChjaGFuZ2UpPVwib25IZWFkZXJDaGVja2JveENsaWNrKCRldmVudClcIiBkaXNhYmxlUmlwcGxlPVwidHJ1ZVwiIFthcmlhLWxhYmVsXT1cImhlYWRlckNoZWNrYm94QXJpYUxhYmVsXCIgI2hlYWRlckNoZWNrYm94PjwvaWd4LWNoZWNrYm94PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1ucy5sZW5ndGggPiAwXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XCJvbmx5VG9wTGV2ZWwocGlubmVkQ29sdW1ucylcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RoZWFkLWl0ZW0gaWd4LWdyaWRfX3RoLS1waW5uZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlciBbaWd4Q29sdW1uTW92aW5nRHJhZ109XCJjb2xcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cImNvbFwiIFtncmlkSURdPVwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2xcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5tYXgtd2lkdGgucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtaGVhZGVyPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtZmlsdGVyaW5nLWNlbGwgKm5nSWY9XCJhbGxvd0ZpbHRlcmluZyAmJiAhY29sLmNvbHVtbkdyb3VwICYmIGZpbHRlcmluZ1NlcnZpY2UuZmlsdGVyZWRDb2x1bW4gIT09IGNvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPSdjb2wud2lkdGgnIFtzdHlsZS5tYXgtd2lkdGgucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtZmlsdGVyaW5nLWNlbGw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgbGV0LWNvbCBbaWd4R3JpZEZvck9mXT1cIm9ubHlUb3BMZXZlbCh1bnBpbm5lZENvbHVtbnMpXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwicGFyZW50VmlydERpclwiXG4gICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09J3VucGlubmVkV2lkdGgnIFtpZ3hGb3JUcmFja0J5XT0ndHJhY2tDb2x1bW5DaGFuZ2VzJyAjaGVhZGVyQ29udGFpbmVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190aGVhZC1pdGVtXCI+XG4gICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlciBbaWd4Q29sdW1uTW92aW5nRHJhZ109XCJjb2xcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cImNvbFwiIFtncmlkSURdPVwiaWRcIiBbY29sdW1uXT1cImNvbFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPSdjb2wud2lkdGgnIFtzdHlsZS5tYXgtd2lkdGgucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtaGVhZGVyPlxuICAgICAgICAgICAgICAgIDxpZ3gtZ3JpZC1maWx0ZXJpbmctY2VsbCAqbmdJZj1cImFsbG93RmlsdGVyaW5nICYmICFjb2wuY29sdW1uR3JvdXAgJiYgZmlsdGVyaW5nU2VydmljZS5maWx0ZXJlZENvbHVtbiAhPT0gY29sXCIgW2NvbHVtbl09XCJjb2xcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT0nY29sLndpZHRoJyBbc3R5bGUubWF4LXdpZHRoLnB4XT0nY29sLndpZHRoJz48L2lneC1ncmlkLWZpbHRlcmluZy1jZWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtblwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwicmlnaHRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1yaWdodFwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8aWd4LWdyaWQtZmlsdGVyaW5nLXJvdyAqbmdJZj1cImZpbHRlcmluZ1NlcnZpY2UuaXNGaWx0ZXJSb3dWaXNpYmxlXCIgW2NvbHVtbl09XCJmaWx0ZXJpbmdTZXJ2aWNlLmZpbHRlcmVkQ29sdW1uXCI+PC9pZ3gtZ3JpZC1maWx0ZXJpbmctcm93PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHlcIiByb2xlPVwicm93Z3JvdXBcIiBbc3R5bGUuaGVpZ2h0LnB4XT0nY2FsY0hlaWdodCcgW3N0eWxlLndpZHRoLnB4XT0nY2FsY1dpZHRoJyAjdGJvZHkgKHNjcm9sbCk9J3Njcm9sbEhhbmRsZXIoJGV2ZW50KScgKHdoZWVsKT1cIndoZWVsSGFuZGxlcigpXCI+XG4gICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoIDw9IDBcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1sZWZ0XCI+PC9zcGFuPlxuICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtbiAmJiBwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1waW5uZWRcIiBbc3R5bGUubGVmdC5weF09XCJwaW5uZWRXaWR0aFwiPjwvc3Bhbj5cbiAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtcm93RGF0YSBbaWd4R3JpZEZvck9mXT1cImRhdGEgfCBncmlkVHJhbnNhY3Rpb246aWQ6cGlwZVRyaWdnZXJcbiAgICB8IGdyaWRGaWx0ZXJpbmc6ZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOmlkOnBpcGVUcmlnZ2VyXG4gICAgfCBncmlkU29ydDpzb3J0aW5nRXhwcmVzc2lvbnM6aWQ6cGlwZVRyaWdnZXJcbiAgICB8IGdyaWRQcmVHcm91cEJ5Omdyb3VwaW5nRXhwcmVzc2lvbnM6Z3JvdXBpbmdFeHBhbnNpb25TdGF0ZTpncm91cHNFeHBhbmRlZDppZDpwaXBlVHJpZ2dlclxuICAgIHwgZ3JpZFBhZ2luZzpwYWdlOnBlclBhZ2U6aWQ6cGlwZVRyaWdnZXJcbiAgICB8IGdyaWRQb3N0R3JvdXBCeTpncm91cGluZ0V4cHJlc3Npb25zOmdyb3VwaW5nRXhwYW5zaW9uU3RhdGU6Z3JvdXBzRXhwYW5kZWQ6aWQ6Z3JvdXBzUmVjb3JkczpwaXBlVHJpZ2dlclwiXG4gICAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ3ZlcnRpY2FsJ1wiXG4gICAgW2lneEZvckNvbnRhaW5lclNpemVdPSdjYWxjSGVpZ2h0JyBbaWd4Rm9ySXRlbVNpemVdPVwicm93SGVpZ2h0XCIgI3ZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyIChvbkNodW5rUHJlbG9hZCk9XCJkYXRhTG9hZGluZygkZXZlbnQpXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcmVjb3JkX3RlbXBsYXRlPlxuICAgICAgICAgICAgPGlneC1ncmlkLXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW3Jvd0RhdGFdPVwicm93RGF0YVwiICNyb3c+XG4gICAgICAgICAgICA8L2lneC1ncmlkLXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNncm91cF90ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxpZ3gtZ3JpZC1ncm91cGJ5LXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW2dyb3VwUm93XT1cInJvd0RhdGFcIiAjcm93PlxuICAgICAgICAgICAgPC9pZ3gtZ3JpZC1ncm91cGJ5LXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqaWd4VGVtcGxhdGVPdXRsZXQ9XCJpc0dyb3VwQnlSZWNvcmQocm93RGF0YSkgPyBncm91cF90ZW1wbGF0ZSA6IHJlY29yZF90ZW1wbGF0ZTsgY29udGV4dDogZ2V0Q29udGV4dChyb3dEYXRhKSBcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtblwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwicmlnaHRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1yaWdodFwiPjwvc3Bhbj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Jvdy1lZGl0aW5nLW91dGxldFwiIGlneE92ZXJsYXlPdXRsZXQgI2lneFJvd0VkaXRpbmdPdmVybGF5T3V0bGV0PjwvZGl2PlxuPC9kaXY+XG5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX190Zm9vdFwiIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgI3Rmb290PlxuICAgIDxkaXYgKm5nSWY9XCJoYXNTdW1tYXJpemVkQ29sdW1uc1wiIGNsYXNzPVwiaWd4LWdyaWRfX3N1bW1hcmllc1wiIFtzdHlsZS5oZWlnaHQucHhdPVwic3VtbWFyaWVzSGVpZ2h0XCIgcm9sZT1cInJvd1wiICNzdW1tYXJpZXM+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fcm93LWluZGVudGF0aW9uIGlneC1ncmlkX19yb3ctaW5kZW50YXRpb24tLWxldmVsLXt7Z3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGh9fVwiPjwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInN1bW1hcmllc01hcmdpblwiPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc3VtbWFyaWVzLXBhdGNoXCJcbiAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGgucHhdPVwic3VtbWFyaWVzTWFyZ2luXCJcbiAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT1cInN1bW1hcmllc01hcmdpblwiXG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1ucy5sZW5ndGggPiAwXCI+XG4gICAgICAgICAgICA8aWd4LWdyaWQtc3VtbWFyeSBbZ3JpZElEXT1cImlkXCIgKm5nRm9yPVwibGV0IGNvbCBvZiBub3RHcm91cHMocGlubmVkQ29sdW1ucylcIiAgW2NvbHVtbl09XCJjb2xcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT0nY29sLndpZHRoJz48L2lneC1ncmlkLXN1bW1hcnk+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtY29sIFtpZ3hHcmlkRm9yT2ZdPVwibm90R3JvdXBzKHVucGlubmVkQ29sdW1ucylcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvclNjcm9sbENvbnRhaW5lcl09XCJwYXJlbnRWaXJ0RGlyXCIgW2lneEZvckNvbnRhaW5lclNpemVdPSd1bnBpbm5lZFdpZHRoJyBbaWd4Rm9yVHJhY2tCeV09J3RyYWNrQ29sdW1uQ2hhbmdlcycgI3N1bW1hcnlDb250YWluZXI+XG4gICAgICAgICAgICA8aWd4LWdyaWQtc3VtbWFyeSBbZ3JpZElEXT1cImlkXCIgW2NvbHVtbl09XCJjb2xcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT0nY29sLndpZHRoJz48L2lneC1ncmlkLXN1bW1hcnk+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGxcIiBbc3R5bGUuaGVpZ2h0XT1cIicxOHB4J1wiICNzY3IgW2hpZGRlbl09XCJ1bnBpbm5lZFdpZHRoIC0gdG90YWxXaWR0aCA+PSAwXCI+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtc3RhcnRcIiBbc3R5bGUud2lkdGgucHhdPSdwaW5uZWRXaWR0aCcgW2hpZGRlbl09XCJwaW5uZWRXaWR0aCA9PT0gMFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW1haW5cIiBbc3R5bGUud2lkdGgucHhdPSd1bnBpbm5lZFdpZHRoJz5cbiAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgW2lneEdyaWRGb3JPZl09J1tdJyAjc2Nyb2xsQ29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtcGFnaW5hdG9yIGlneC1ncmlkLXBhZ2luYXRvclwiICpuZ0lmPVwicGFnaW5nXCIgI3BhZ2luYXRvcj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicGFnaW5hdGlvblRlbXBsYXRlID8gcGFnaW5hdGlvblRlbXBsYXRlIDogZGVmYXVsdFBhZ2VyOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogdGhpcyB9XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNlbXB0eUZpbHRlcmVkR3JpZD5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1tZXNzYWdlXCI+e3tlbXB0eUZpbHRlcmVkR3JpZE1lc3NhZ2V9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEVtcHR5R3JpZD5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1tZXNzYWdlXCI+e3tlbXB0eUdyaWRNZXNzYWdlfX08L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHREcm9wQXJlYT5cbiAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCIgY2xhc3M9XCJpZ3gtZHJvcC1hcmVhX19pY29uXCI+Z3JvdXBfd29yazwvaWd4LWljb24+XG4gICAgPHNwYW4gY2xhc3M9XCJpZ3gtZHJvcC1hcmVhX190ZXh0XCI+e3tkcm9wQXJlYU1lc3NhZ2V9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgKm5nSWY9XCJyb3dFZGl0YWJsZVwiIGlneFRvZ2dsZT5cbiAgICA8ZGl2IFtjbGFzc05hbWVdPVwiYmFubmVyQ2xhc3NcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0VkaXRDb250YWluZXI7IGNvbnRleHQ6IHsgcm93Q2hhbmdlc0NvdW50OiByb3dDaGFuZ2VzQ291bnQsIGVuZEVkaXQ6IGVuZEVkaXQuYmluZCh0aGlzKSB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFJvd0VkaXRUZXh0PlxuICAgIFlvdSBoYXZlIHt7IHJvd0NoYW5nZXNDb3VudCB9fSBjaGFuZ2VzIGluIHRoaXMgcm93XG48L25nLXRlbXBsYXRlPlxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Um93RWRpdEFjdGlvbnM+XG4gICAgPGJ1dHRvbiBpZ3hCdXR0b24gaWd4Um93RWRpdFRhYlN0b3AgKGNsaWNrKT1cImVuZEVkaXQoZmFsc2UsICRldmVudClcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCAoY2xpY2spPVwiZW5kRWRpdCh0cnVlLCAkZXZlbnQpXCI+RG9uZTwvYnV0dG9uPlxuPC9uZy10ZW1wbGF0ZT5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFJvd0VkaXRUZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWJhbm5lcl9fbWVzc2FnZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1iYW5uZXJfX3RleHRcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dFZGl0VGV4dCA/IHJvd0VkaXRUZXh0IDogZGVmYXVsdFJvd0VkaXRUZXh0OyBjb250ZXh0OiB7ICRpbXBsaWNpdDogcm93Q2hhbmdlc0NvdW50IH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19hY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19yb3dcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dFZGl0QWN0aW9ucyA/IHJvd0VkaXRBY3Rpb25zIDogZGVmYXVsdFJvd0VkaXRBY3Rpb25zOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZW5kRWRpdC5iaW5kKHRoaXMpIH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX291dGxldFwiICNpZ3hGaWx0ZXJpbmdPdmVybGF5T3V0bGV0IGlneE92ZXJsYXlPdXRsZXQ+PC9kaXY+XG5gXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRDb21wb25lbnQgZXh0ZW5kcyBJZ3hHcmlkQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgRG9DaGVjaywgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgcHJpdmF0ZSBfaWQgPSBgaWd4LWdyaWQtJHtORVhUX0lEKyt9YDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cHJlc3Npb25zID0gW107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdFeHBhbmRTdGF0ZTogSUdyb3VwQnlFeHBhbmRTdGF0ZVtdID0gW107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBSb3dUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdyb3VwaW5nRGlmZmVyO1xuICAgIHByaXZhdGUgX2hpZGVHcm91cGVkQ29sdW1ucyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtpZF09XCInaWd4LWdyaWQtMSdcIiBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5faWQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRJZCA9IHRoaXMuX2lkO1xuICAgICAgICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkucmVzZXQob2xkSWQsIHRoaXMuX2lkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2dyaWRBUEk6IElneEdyaWRBUElTZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4sXG4gICAgICAgIHNlbGVjdGlvbjogSWd4U2VsZWN0aW9uQVBJU2VydmljZSxcbiAgICAgICAgQEluamVjdChJZ3hHcmlkVHJhbnNhY3Rpb24pIF90cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uU2VydmljZTxUcmFuc2FjdGlvbiwgU3RhdGU+LFxuICAgICAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICB6b25lOiBOZ1pvbmUsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHB1YmxpYyBkb2N1bWVudCxcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIGZpbHRlcmluZ1NlcnZpY2U6IElneEZpbHRlcmluZ1NlcnZpY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKGdyaWRBUEksIHNlbGVjdGlvbiwgX3RyYW5zYWN0aW9ucywgZWxlbWVudFJlZiwgem9uZSwgZG9jdW1lbnQsIGNkciwgcmVzb2x2ZXIsIGRpZmZlcnMsIHZpZXdSZWYsIG5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgICBmaWx0ZXJpbmdTZXJ2aWNlKTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkgPSA8SWd4R3JpZEFQSVNlcnZpY2U+Z3JpZEFQSTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncm91cCBieSBzdGF0ZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBCeVN0YXRlID0gdGhpcy5ncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZ3JvdXBpbmdFeHByZXNzaW9ucygpOiBJU29ydGluZ0V4cHJlc3Npb25bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdyb3VwIGJ5IHN0YXRlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgYW5kIGVtaXRzIHRoZSBgb25Hcm91cGluZ0RvbmVgXG4gICAgICogZXZlbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgYXJndW1lbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IFt7XG4gICAgICogICAgIGZpZWxkTmFtZTogXCJJRFwiLFxuICAgICAqICAgICBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLFxuICAgICAqICAgICBpZ25vcmVDYXNlOiBmYWxzZVxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBncm91cGluZ0V4cHJlc3Npb25zKHZhbHVlOiBJU29ydGluZ0V4cHJlc3Npb25bXSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXhpbXVtIGFtb3VudCBvZiBncm91cGVkIGNvbHVtbnMgaXMgMTAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkRXhwcmVzc2lvbnM6IEFycmF5PElTb3J0aW5nRXhwcmVzc2lvbj4gPSB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IG5ld0V4cHJlc3Npb25zOiBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMgPSBjbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucyA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fZ3JpZEFQSS5nZXQodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuYXJyYW5nZV9zb3J0aW5nX2V4cHJlc3Npb25zKHRoaXMuaWQpO1xuICAgICAgICAgICAgLyogZ3JvdXBpbmcgc2hvdWxkIHdvcmsgaW4gY29uanVuY3Rpb24gd2l0aCBzb3J0aW5nXG4gICAgICAgICAgICBhbmQgd2l0aG91dCBvdmVycmlkaW5nIHNlcGFyYXRlIHNvcnRpbmcgZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5R3JvdXBpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0dGVyIGNhbGxlZCBiZWZvcmUgZ3JpZCBpcyByZWdpc3RlcmVkIGluIGdyaWQgQVBJIHNlcnZpY2VcbiAgICAgICAgICAgIHRoaXMuc29ydGluZ0V4cHJlc3Npb25zLnVuc2hpZnQuYXBwbHkodGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMsIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShvbGRFeHByZXNzaW9ucykgIT09IEpTT04uc3RyaW5naWZ5KG5ld0V4cHJlc3Npb25zKSAmJiB0aGlzLmNvbHVtbkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50ID0gW107XG4gICAgICAgICAgICBjb25zdCB1bmdyb3VwZWRDb2xzOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50ID0gW107XG4gICAgICAgICAgICBjb25zdCBncm91cGVkQ29sc0FyciA9IG5ld0V4cHJlc3Npb25zLmZpbHRlcigob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvbGRFeHByZXNzaW9ucy5zb21lKChvYmoyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZmllbGROYW1lID09PSBvYmoyLmZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBlZENvbHNBcnIuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgdW5ncm91cGVkQ29sc0FyciA9IG9sZEV4cHJlc3Npb25zLmZpbHRlcigob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuZXdFeHByZXNzaW9ucy5zb21lKChvYmoyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZmllbGROYW1lID09PSBvYmoyLmZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdW5ncm91cGVkQ29sc0Fyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5ncm91cGVkQ29scy5wdXNoKHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGVsZW0uZmllbGROYW1lKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwaW5nRG9uZUFyZ3M6IElHcm91cGluZ0RvbmVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IG5ld0V4cHJlc3Npb25zLFxuICAgICAgICAgICAgICAgIGdyb3VwZWRDb2x1bW5zOiBncm91cGVkQ29scyxcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRDb2x1bW5zOiB1bmdyb3VwZWRDb2xzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbkdyb3VwaW5nRG9uZS5lbWl0KGdyb3VwaW5nRG9uZUFyZ3MpO1xuICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBleHBhbnNpb24gc3RhdGVzIGZvciBncm91cCByb3dzLlxuICAgICAqIEluY2x1ZGVzIG9ubHkgc3RhdGVzIHRoYXQgZGlmZmVyIGZyb20gdGhlIGRlZmF1bHQgb25lIChjb250cm9sbGVkIHRocm91Z2ggZ3JvdXBzRXhwYW5kZWQgYW5kIHN0YXRlcyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkLlxuICAgICAqIENvbnRhaW5zIHRoZSBleHBhbnNpb24gc3RhdGUgKGV4cGFuZGVkOiBib29sZWFuKSBhbmQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAgcm93IChBcnJheSkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwRXhwU3RhdGUgPSB0aGlzLmdyaWQuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBncm91cGluZ0V4cGFuc2lvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbGlzdCBvZiBleHBhbnNpb24gc3RhdGVzIGZvciBncm91cCByb3dzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgICAgIHRoaXMuZ3JpZC5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW3tcbiAgICAgKiAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgKiAgICAgIGhpZXJhcmNoeTogW3sgZmllbGROYW1lOiAnSUQnLCB2YWx1ZTogMSB9XVxuICAgICAqICAgfV07XG4gICAgICogLy8gWW91IGNhbiB1c2UgRGF0YVV0aWwuZ2V0SGllcmFyY2h5KGdyb3VwUm93KSB0byBnZXQgdGhlIGdyb3VwIGBJZ3hHcmlkUm93Q29tcG9uZW50YCBoaWVyYXJjaHkuXG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5mbyA9IElneFRleHRIaWdobGlnaHREaXJlY3RpdmUuaGlnaGxpZ2h0R3JvdXBzTWFwLmdldCh0aGlzLmlkKTtcblxuICAgICAgICBsZXQgaGlnaGxpZ2h0SXRlbSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZEhpZ2hsaWdodGVkSXRlbSkge1xuICAgICAgICAgICAgaGlnaGxpZ2h0SXRlbSA9IHRoaXMuY29sbGFwc2VkSGlnaGxpZ2h0ZWRJdGVtLml0ZW07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0U2VhcmNoSW5mby5tYXRjaEluZm9DYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodEl0ZW0gPSB0aGlzLmxhc3RTZWFyY2hJbmZvLm1hdGNoSW5mb0NhY2hlW3RoaXMubGFzdFNlYXJjaEluZm8uYWN0aXZlTWF0Y2hJbmRleF0uaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dyb3VwaW5nRXhwYW5kU3RhdGUgPSBjbG9uZUFycmF5KHZhbHVlKTtcblxuICAgICAgICB0aGlzLnJlZnJlc2hTZWFyY2goKTtcblxuICAgICAgICBpZiAoaGlnaGxpZ2h0SXRlbSAhPT0gbnVsbCAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhLmluZGV4T2YoaGlnaGxpZ2h0SXRlbSk7XG4gICAgICAgICAgICBjb25zdCBncm91cFJvdyA9IHRoaXMuZ2V0R3JvdXBCeVJlY29yZHMoKVtpbmRleF07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V4cGFuZGVkR3JvdXAoZ3JvdXBSb3cpKSB7XG4gICAgICAgICAgICAgICAgSWd4VGV4dEhpZ2hsaWdodERpcmVjdGl2ZS5jbGVhckFjdGl2ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlZEhpZ2hsaWdodGVkSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogYWN0aXZlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogaGlnaGxpZ2h0SXRlbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29sbGFwc2VkSGlnaGxpZ2h0ZWRJdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGFwc2VkSW5mbyA9IHRoaXMuY29sbGFwc2VkSGlnaGxpZ2h0ZWRJdGVtLmluZm87XG4gICAgICAgICAgICAgICAgSWd4VGV4dEhpZ2hsaWdodERpcmVjdGl2ZS5zZXRBY3RpdmVIaWdobGlnaHQodGhpcy5pZCwge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sbGFwc2VkSW5mby5jb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXg6IGNvbGxhcHNlZEluZm8ucm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb2xsYXBzZWRJbmZvLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBjb2xsYXBzZWRJbmZvLnBhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIGNyZWF0ZWQgZ3JvdXBzIGFyZSByZW5kZXJlZCBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyZWQgc3RhdGUgaXMgZXhwYW5kZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2dyb3Vwc0V4cGFuZGVkXT1cImZhbHNlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBncm91cHNFeHBhbmRlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBIGhpZXJhcmNoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JvdXAgYnkgcmVjb3Jkcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGdyb3VwUmVjb3JkcyA9IHRoaXMuZ3JpZC5ncm91cHNSZWNvcmRzO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cHNSZWNvcmRzOiBJR3JvdXBCeVJlY29yZFtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHdoZXRoZXIgdGhlIGdyb3VwZWQgY29sdW1ucyBzaG91bGQgYmUgaGlkZGVuIGFzIHdlbGwuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCJmYWxzZVwiXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGlkZUdyb3VwZWRDb2x1bW5zXT1cInRydWVcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBoaWRlR3JvdXBlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBoaWRlR3JvdXBlZENvbHVtbnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKS5jcmVhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hpZGVHcm91cGVkQ29sdW1ucyA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIG1lc3NhZ2UgZGlzcGxheWVkIGluc2lkZSB0aGUgR3JvdXBCeSBkcm9wIGFyZWEgd2hlcmUgY29sdW1ucyBjYW4gYmUgZHJhZ2dlZCBvbi5cbiAgICAgKiBOb3RlOiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgZHJvcEFyZWFNZXNzYWdlPVwiRHJvcCBoZXJlIHRvIGdyb3VwIVwiPlxuICAgICAqICAgICAgPGlneC1jb2x1bW4gW2dyb3VwYWJsZV09XCJ0cnVlXCIgZmllbGQ9XCJJRFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyb3BBcmVhTWVzc2FnZSA9ICdEcmFnIGEgY29sdW1uIGhlYWRlciBhbmQgZHJvcCBpdCBoZXJlIHRvIGdyb3VwIGJ5IHRoYXQgY29sdW1uLic7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBHcm91cEJ5IGRyb3AgYXJlYS5cbiAgICAgKiBOb3RlOiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2Ryb3BBcmVhVGVtcGxhdGVdPVwiZHJvcEFyZWFSZWZcIj5cbiAgICAgKiAgICAgIDxpZ3gtY29sdW1uIFtncm91cGFibGVdPVwidHJ1ZVwiIGZpZWxkPVwiSURcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtZ3JpZD5cbiAgICAgKlxuICAgICAqIDxuZy10ZW1wbGF0ZSAjbXlEcm9wQXJlYT5cbiAgICAgKiAgICAgIDxzcGFuPiBDdXN0b20gZHJvcCBhcmVhISA8L3NwYW4+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0c1xuICAgICAqIEBWaWV3Q2hpbGQoJ215RHJvcEFyZWEnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGRyb3BBcmVhUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyb3BBcmVhVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSBuZXcgYElneENvbHVtbkNvbXBvbmVudGAgZ2V0cyBncm91cGVkL3VuZ3JvdXBlZCwgb3IgbXVsdGlwbGUgY29sdW1ucyBnZXRcbiAgICAgKiBncm91cGVkL3VuZ3JvdXBlZCBhdCBvbmNlIGJ5IHVzaW5nIHRoZSBHcm91cCBCeSBBUEkuXG4gICAgICogVGhlIGBvbkdyb3VwaW5nRG9uZWAgZXZlbnQgd291bGQgYmUgcmFpc2VkIG9ubHkgb25jZSBpZiBzZXZlcmFsIGNvbHVtbnMgZ2V0IGdyb3VwZWQgYXQgb25jZSBieSBjYWxsaW5nXG4gICAgICogdGhlIGBncm91cEJ5KClgIG9yIGBjbGVhckdyb3VwaW5nKClgIEFQSSBtZXRob2RzIGFuZCBwYXNzaW5nIGFuIGFycmF5IGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIFRoZSBldmVudCBhcmd1bWVudHMgcHJvdmlkZSB0aGUgYGV4cHJlc3Npb25zYCwgYGdyb3VwZWRDb2x1bW5zYCBhbmQgYHVuZ3JvdXBlZENvbHVtbnNgIHByb3BlcnRpZXMsIHdoaWNoIGNvbnRhaW5cbiAgICAgKiB0aGUgYElTb3J0aW5nRXhwcmVzc2lvbmAgYW5kIHRoZSBgSWd4Q29sdW1uQ29tcG9uZW50YCByZWxhdGVkIHRvIHRoZSBncm91cGluZy91bmdyb3VwaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGBncm91cGVkQ29sdW1uc2AgYW5kIGB1bmdyb3VwZWRDb2x1bW5zYCBzaG93IG9ubHkgdGhlICoqbmV3bHkqKiBjaGFuZ2VkIGNvbHVtbnMgKGFmZmVjdGVkIGJ5IHRoZSAqKmxhc3QqKlxuICAgICAqIGdyb3VwaW5nL3VuZ3JvdXBpbmcgb3BlcmF0aW9uKSwgbm90IGFsbCBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgZ3JvdXBlZC91bmdyb3VwZWQuXG4gICAgICogY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JvdXBpbmdEb25lKGV2ZW50OiBJR3JvdXBpbmdEb25lRXZlbnRBcmdzKXtcbiAgICAgKiAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBldmVudC5leHByZXNzaW9ucztcbiAgICAgKiAgICAgLy90aGUgbmV3bHkgZ3JvdXBlZCBjb2x1bW5zXG4gICAgICogICAgIGNvbnN0IGdyb3VwZWRDb2x1bW5zID0gZXZlbnQuZ3JvdXBlZENvbHVtbnM7XG4gICAgICogICAgIC8vdGhlIG5ld2x5IHVuZ3JvdXBlZCBjb2x1bW5zXG4gICAgICogICAgIGNvbnN0IHVuZ3JvdXBlZENvbHVtbnMgPSBldmVudC51bmdyb3VwZWRDb2x1bW5zO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIChvbkdyb3VwaW5nRG9uZSk9XCJncm91cGluZ0RvbmUoJGV2ZW50KVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uR3JvdXBpbmdEb25lID0gbmV3IEV2ZW50RW1pdHRlcjxJR3JvdXBpbmdEb25lRXZlbnRBcmdzPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uRm9jdXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElHcmlkRm9jdXNDaGFuZ2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGdyb3VwVGVtcGxhdGU6IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIEBWaWV3Q2hpbGRyZW4oSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQsIHsgcmVhZDogSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSlcbiAgICBwcml2YXRlIF9ncm91cHNSb3dMaXN0OiBRdWVyeUxpc3Q8SWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHREcm9wQXJlYScsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgZGVmYXVsdERyb3BBcmVhVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgYWxsIGdyb3VwIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwTGlzdCA9IHRoaXMuZ3JpZC5ncm91cHNSb3dMaXN0O1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ3JvdXBzUm93TGlzdCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFF1ZXJ5TGlzdDxhbnk+KCk7XG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBzUm93TGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByTGlzdCA9IHRoaXMuX2dyb3Vwc1Jvd0xpc3QuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5yZXNldChyTGlzdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2dyb3VwQXJlYScpXG4gICAgcHVibGljIGdyb3VwQXJlYTogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZ3JvdXBBcmVhSG9zdENsYXNzKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnaWd4LWRyb3AtYXJlYS0tY29zeSc7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpZ3gtZHJvcC1hcmVhLS1jb21wYWN0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpZ3gtZHJvcC1hcmVhJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgJ3MgZ3JvdXAgcm93LlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGdyb3VwUm93VGVtcGxhdGUgPSB0aGlzLmdyaWQuZ3JvdXBSb3dUZW1wbGF0ZTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZ3JvdXBSb3dUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwUm93VGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCBgSWd4R3JpZFJvd0NvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cFJvd1RlbXBsYXRlID0gbXlSb3dUZW1wbGF0ZS5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBSb3dUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9ncm91cFJvd1RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGFyZWEuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwQXJlYVRlbXBsYXRlID0gdGhpcy5ncmlkLmdyb3VwQXJlYVRlbXBsYXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwQXJlYVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgJ3MgZ3JvdXAgYXJlYS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwQXJlYVRlbXBsYXRlID0gbXlBcmVhVGVtcGxhdGUuXG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGdyb3VwQXJlYVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwQXJlYVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIGJ5IGEgbmV3IGBJZ3hDb2x1bW5Db21wb25lbnRgIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBleHByZXNzaW9uLCBvciBtb2RpZmllcyBhbiBleGlzdGluZyBvbmUuXG4gICAgICogQWxzbyBhbGxvd3MgZm9yIG11bHRpcGxlIGNvbHVtbnMgdG8gYmUgZ3JvdXBlZCBhdCBvbmNlIGlmIGFuIGFycmF5IG9mIGBJU29ydGluZ0V4cHJlc3Npb25gIGlzIHBhc3NlZC5cbiAgICAgKiBUaGUgb25Hcm91cGluZ0RvbmUgZXZlbnQgd291bGQgZ2V0IHJhaXNlZCBvbmx5ICoqb25jZSoqIGlmIHRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBCeSh7IGZpZWxkTmFtZTogbmFtZSwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYywgaWdub3JlQ2FzZTogZmFsc2UgfSk7XG4gICAgICogdGhpcy5ncmlkLmdyb3VwQnkoW1xuICAgICAgICAgICAgeyBmaWVsZE5hbWU6IG5hbWUxLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBmaWVsZE5hbWU6IG5hbWUyLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uRGVzYywgaWdub3JlQ2FzZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBmaWVsZE5hbWU6IG5hbWUzLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uRGVzYywgaWdub3JlQ2FzZTogZmFsc2UgfVxuICAgICAgICBdKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBCeShleHByZXNzaW9uOiBJU29ydGluZ0V4cHJlc3Npb24gfCBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+KTogdm9pZDtcbiAgICBwdWJsaWMgZ3JvdXBCeSguLi5yZXN0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW5kRWRpdCh0cnVlKTtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5zdWJtaXRfdmFsdWUodGhpcy5pZCk7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMSAmJiByZXN0WzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQnlNdWx0aXBsZShyZXN0WzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQnkocmVzdFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUdyaWRTaXplcygpO1xuICAgICAgICB0aGlzLnJlc3RvcmVIaWdobGlnaHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGdyb3VwaW5nIGluIHRoZSBncmlkLCBpZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuICAgICAqIElmIGEgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBjbGVhcnMgZ3JvdXBpbmcgZm9yIGEgcGFydGljdWxhciBjb2x1bW4gb3IgYW4gYXJyYXkgb2YgY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmNsZWFyR3JvdXBpbmcoKTsgLy9jbGVhcnMgYWxsIGdyb3VwaW5nXG4gICAgICogdGhpcy5ncmlkLmNsZWFyR3JvdXBpbmcoXCJJRFwiKTsgLy91bmdyb3VwcyBhIHNpbmdsZSBjb2x1bW5cbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZyhbXCJJRFwiLCBcIkNvbHVtbjFcIiwgXCJDb2x1bW4yXCJdKTsgLy91bmdyb3VwcyBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJHcm91cGluZyhuYW1lPzogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmNsZWFyX2dyb3VwYnkodGhpcy5pZCwgbmFtZSk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlR3JpZFNpemVzKCk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhpZ2hsaWdodCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYSBncm91cCBpcyBleHBhbmRlZCBvciBub3QuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgZXhwYW5kZWRHcm91cCA9IHRoaXMuZ3JpZC5pc0V4cGFuZGVkR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGlzRXhwYW5kZWRHcm91cChncm91cDogSUdyb3VwQnlSZWNvcmQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZXhwYW5kZWQgOiB0aGlzLmdyb3Vwc0V4cGFuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiBhIGdyb3VwLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkO1xuICAgICAqIGNvbnN0IHRvZ2dsZUV4cEdyb3VwID0gdGhpcy5ncmlkLnRvZ2dsZUdyb3VwKHRoaXMuZ3JvdXBSb3cpO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlR3JvdXAoZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNHcm91cEJ5UmVjb3JkKHJlY29yZDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIHJldHVybiByZWNvcmQucmVjb3JkcyBpbnN0YW5jZSBvZiBHcm91cGVkUmVjb3JkcyBmYWlscyB1bmRlciBXZWJwYWNrXG4gICAgICAgIHJldHVybiByZWNvcmQucmVjb3JkcyAmJiByZWNvcmQucmVjb3Jkcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIGFsbCBncm91cCByb3dzIHJlY3Vyc2l2ZWx5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQudG9nZ2xlQWxsR3JvdXBSb3dzO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVBbGxHcm91cFJvd3MoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLmdyb3Vwc0V4cGFuZGVkID0gIXRoaXMuZ3JvdXBzRXhwYW5kZWQ7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIGdyb3VwYWJsZSBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cGFibGVHcmlkID0gdGhpcy5ncmlkLmhhc0dyb3VwYWJsZUNvbHVtbnM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhhc0dyb3VwYWJsZUNvbHVtbnMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkxpc3Quc29tZSgoY29sKSA9PiBjb2wuZ3JvdXBhYmxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5mb3JFYWNoKChleHByKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICBjb2wuaGlkZGVuID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGdyaWQncyBncm91cCBieSBkcm9wIGFyZWEgaXMgdmlzaWJsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZHJvcFZpc2libGUgPSB0aGlzLmdyaWQuZHJvcEFyZWFWaXNpYmxlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHJvcEFyZWFWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuZHJhZ2dlZENvbHVtbiAmJiB0aGlzLmRyYWdnZWRDb2x1bW4uZ3JvdXBhYmxlKSB8fFxuICAgICAgICAgICAgIXRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwQnkoZXhwcmVzc2lvbjogSVNvcnRpbmdFeHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeSh0aGlzLmlkLCBleHByZXNzaW9uLmZpZWxkTmFtZSwgZXhwcmVzc2lvbi5kaXIsIGV4cHJlc3Npb24uaWdub3JlQ2FzZSwgZXhwcmVzc2lvbi5zdHJhdGVneSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBCeU11bHRpcGxlKGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfbXVsdGlwbGUodGhpcy5pZCwgZXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dldFN0YXRlRm9yR3JvdXBSb3coZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkKTogSUdyb3VwQnlFeHBhbmRTdGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfZ2V0X2V4cGFuZGVkX2Zvcl9ncm91cCh0aGlzLmlkLCBncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdG9nZ2xlR3JvdXAoZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeV90b2dnbGVfZ3JvdXAodGhpcy5pZCwgZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5R3JvdXBpbmcoKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuc29ydF9tdWx0aXBsZSh0aGlzLmlkLCB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgcHVibGljIGdldENvbnRleHQocm93RGF0YSk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHJvd0RhdGEsXG4gICAgICAgICAgICB0ZW1wbGF0ZUlEOiB0aGlzLmlzR3JvdXBCeVJlY29yZChyb3dEYXRhKSA/ICdncm91cFJvdycgOiAnZGF0YVJvdydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIG1ldGhvZCdzIGlkZWEgaXMgdG8gZ2V0IGJ5IGhvdyBtdWNoIGVhY2ggZGF0YSByb3cgaXMgb2Zmc2V0IGJ5IHRoZSBncm91cCBieSByb3dzIGJlZm9yZSBpdC5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRHcm91cEluY3JlbWVudERhdGEoKTogbnVtYmVyW10ge1xuICAgICAgICBpZiAodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3Vwc1JlY29yZHMgPSB0aGlzLmdldEdyb3VwQnlSZWNvcmRzKCk7XG4gICAgICAgICAgICBjb25zdCBncm91cEJ5SW5jcmVtZW50cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIGxldCBwcmV2SGllcmFyY2h5ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnQgPSAwO1xuXG4gICAgICAgICAgICBncm91cHNSZWNvcmRzLmZvckVhY2goKGdicikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaW5kZXhPZihnYnIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGV2ZWxJbmNyZW1lbnQgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2SGllcmFyY2h5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbEluY3JlbWVudCArPSB0aGlzLmdldExldmVsSW5jcmVtZW50KDAsIGdici5ncm91cFBhcmVudCwgcHJldkhpZXJhcmNoeS5ncm91cFBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBsZXZlbCB3ZSBzdHVtYmxlIHVwb24sIHNvIHdlIGhhdmVuJ3QgYWNjb3VudGVkIGZvciBhbnkgb2YgaXRzIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsSW5jcmVtZW50ICs9IGdici5sZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCArPSBsZXZlbEluY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgcHJldkhpZXJhcmNoeSA9IGdicjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZ2JyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncm91cEJ5SW5jcmVtZW50cy5wdXNoKGluY3JlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBncm91cEJ5SW5jcmVtZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbEluY3JlbWVudChjdXJyZW50SW5jcmVtZW50LCBjdXJyZW50SGllcmFyY2h5LCBwcmV2SGllcmFyY2h5KSB7XG4gICAgICAgIGlmIChjdXJyZW50SGllcmFyY2h5ICE9PSBwcmV2SGllcmFyY2h5ICYmICEhcHJldkhpZXJhcmNoeSAmJiAhIWN1cnJlbnRIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExldmVsSW5jcmVtZW50KCsrY3VycmVudEluY3JlbWVudCwgY3VycmVudEhpZXJhcmNoeS5ncm91cFBhcmVudCwgcHJldkhpZXJhcmNoeS5ncm91cFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluY3JlbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0R3JvdXBCeVJlY29yZHMoKTogSUdyb3VwQnlSZWNvcmRbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyxcbiAgICAgICAgICAgICAgICBleHBhbnNpb246IHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXhwYW5kZWQ6IHRoaXMuZ3JvdXBzRXhwYW5kZWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBEYXRhVXRpbC5ncm91cChjbG9uZUFycmF5KHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhKSwgc3RhdGUpLm1ldGFkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcFJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICB0aGlzLmNsZWFyR3JvdXBpbmcoZXZlbnQub3duZXIuaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpcHNPcmRlckNoYW5nZWQoZXZlbnQ6IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IG5ld0dyb3VwaW5nID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnQuY2hpcHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5maWVsZE5hbWUgPT09IGV2ZW50LmNoaXBzQXJyYXlbaV0uaWQ7XG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSkuZ3JvdXBhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlzYWxsb3cgY2hhbmdpbmcgb3JkZXIgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2l0aCBncm91cGFibGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3R3JvdXBpbmcucHVzaChleHByKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGUgPSBbXTtcbiAgICAgICAgdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucyA9IG5ld0dyb3VwaW5nO1xuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgLy8gV2hlbiByZW9yZGVyZWQgdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiwgd2UgZG9uJ3QgaGF2ZSBgb25Nb3ZlRW5kYCBldmVudC5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNoaXBzTW92aW5nRW5kZWQoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoaXBDbGlja2VkKGV2ZW50OiBJQ2hpcENsaWNrRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHNvcnRpbmdFeHByID0gdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IGNvbHVtbkV4cHIgPSBzb3J0aW5nRXhwci5maW5kKChleHByKSA9PiBleHByLmZpZWxkTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICBjb2x1bW5FeHByLmRpciA9IDMgLSBjb2x1bW5FeHByLmRpcjtcbiAgICAgICAgdGhpcy5zb3J0KGNvbHVtbkV4cHIpO1xuICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25DaGlwS2V5RG93bihldmVudDogSUNoaXBLZXlEb3duRXZlbnRBcmdzKSB7XG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJyAnIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSAnU3BhY2ViYXInIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBzb3J0aW5nRXhwciA9IHRoaXMuc29ydGluZ0V4cHJlc3Npb25zO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uRXhwciA9IHNvcnRpbmdFeHByLmZpbmQoKGV4cHIpID0+IGV4cHIuZmllbGROYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgICAgICBjb2x1bW5FeHByLmRpciA9IDMgLSBjb2x1bW5FeHByLmRpcjtcbiAgICAgICAgICAgIHRoaXMuc29ydChjb2x1bW5FeHByKTtcbiAgICAgICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEdyb3VwQXJlYUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEFyZWEgPyB0aGlzLmdyb3VwQXJlYS5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlubmVkV2lkdGggPSB0aGlzLmdyaWQuZ2V0UGlubmVkV2lkdGgoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdGFrZUhpZGRlbiBJZiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRQaW5uZWRXaWR0aCh0YWtlSGlkZGVuID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHN1bSA9IHN1cGVyLmdldFBpbm5lZFdpZHRoKHRha2VIaWRkZW4pO1xuXG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoID4gMCAmJiB0aGlzLmhlYWRlckdyb3VwQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5oZWFkZXJHcm91cENvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxUbyhyb3c6IG51bWJlciwgY29sdW1uOiBudW1iZXIsIHBhZ2U6IG51bWJlciwgZ3JvdXBCeVJlY29yZD86IElHcm91cEJ5UmVjb3JkKTogdm9pZCB7XG4gICAgICAgIGlmIChncm91cEJ5UmVjb3JkICYmICF0aGlzLmlzRXhwYW5kZWRHcm91cChncm91cEJ5UmVjb3JkKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVHcm91cChncm91cEJ5UmVjb3JkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLnNjcm9sbFRvKHJvdywgY29sdW1uLCBwYWdlLCBncm91cEJ5UmVjb3JkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVGaWx0ZXJlZFNvcnRlZERhdGEoKTogYW55W10ge1xuICAgICAgICBsZXQgZGF0YTogYW55W10gPSBzdXBlci5yZXNvbHZlRmlsdGVyZWRTb3J0ZWREYXRhKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydGluZ0V4cHJlc3Npb25zICYmXG4gICAgICAgICAgICB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRpbmdQaXBlID0gbmV3IElneEdyaWRTb3J0aW5nUGlwZSh0aGlzLl9ncmlkQVBJKTtcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0aW5nUGlwZS50cmFuc2Zvcm0oZGF0YSwgdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMsIHRoaXMuaWQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgcHVibGljIGdldCBkcm9wQXJlYVRlbXBsYXRlUmVzb2x2ZWQoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BBcmVhVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BBcmVhVGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RHJvcEFyZWFUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5ncm91cFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cFJvd1RlbXBsYXRlID0gdGhpcy5ncm91cFRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGlkZUdyb3VwZWRDb2x1bW5zICYmIHRoaXMuY29sdW1uTGlzdCAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodGhpcy5oaWRlR3JvdXBlZENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJDb250ZW50SW5pdCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5vbkdyb3VwaW5nRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZW5kRWRpdCh0cnVlKSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdEaWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmdyb3VwaW5nRGlmZmVyLmRpZmYodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIHRoaXMuY29sdW1uTGlzdCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbSgocmVjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKHJlYy5pdGVtLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iXX0=