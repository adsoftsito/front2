/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
var IgxSelectionAPIService = /** @class */ (function () {
    function IgxSelectionAPIService() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.get = /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        return this.selection.get(componentID);
    };
    /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.set = /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    function (componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    };
    /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.clear = /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        this.selection.set(componentID, this.get_empty());
    };
    /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.size = /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        var /** @type {?} */ sel = this.get(componentID);
        return sel ? sel.size : 0;
    };
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    IgxSelectionAPIService.prototype.add_item = /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    function (componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    };
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    IgxSelectionAPIService.prototype.add_items = /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    function (componentID, itemIDs, clearSelection) {
        var _this = this;
        var /** @type {?} */ selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        itemIDs.forEach(function (item) { return selection = _this.add_item(componentID, item, selection); });
        return selection;
    };
    /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.select_item = /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    function (componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    };
    /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.select_items = /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    function (componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    };
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    IgxSelectionAPIService.prototype.delete_item = /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    function (componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    };
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    IgxSelectionAPIService.prototype.delete_items = /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    function (componentID, itemIDs) {
        var _this = this;
        var /** @type {?} */ selection;
        itemIDs.forEach(function (deselectedItem) { return selection = _this.delete_item(componentID, deselectedItem, selection); });
        return selection;
    };
    /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.deselect_item = /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    function (componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    };
    /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    IgxSelectionAPIService.prototype.deselect_items = /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    function (componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    };
    /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    IgxSelectionAPIService.prototype.is_item_selected = /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    function (componentID, itemID) {
        var /** @type {?} */ sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    };
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    IgxSelectionAPIService.prototype.first_item = /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    function (componentID) {
        var /** @type {?} */ sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    };
    /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    IgxSelectionAPIService.prototype.are_all_selected = /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    function (componentID, dataCount) {
        return this.size(componentID) === dataCount;
    };
    /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    IgxSelectionAPIService.prototype.are_none_selected = /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    function (componentID) {
        return this.size(componentID) === 0;
    };
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    IgxSelectionAPIService.prototype.get_all_ids = /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    function (data, primaryKey) {
        return primaryKey ? data.map(function (x) { return x[primaryKey]; }) : data;
    };
    /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    IgxSelectionAPIService.prototype.get_empty = /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    function () {
        return new Set();
    };
    IgxSelectionAPIService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */ IgxSelectionAPIService.ngInjectableDef = i0.defineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
    return IgxSelectionAPIService;
}());
export { IgxSelectionAPIService };
function IgxSelectionAPIService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxSelectionAPIService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxSelectionAPIService.ctorParameters;
    /**
     * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
     * If the primaryKey is omitted, then selection is based on the item data
     * @type {?}
     */
    IgxSelectionAPIService.prototype.selection;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9jb3JlL3NlbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7Ozs7Ozs7eUJBV08sSUFBSSxHQUFHLEVBQW9COzs7Ozs7O0lBTWxFLG9DQUFHOzs7OztjQUFDLFdBQW1CO1FBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7Ozs7Ozs7SUFRcEMsb0NBQUc7Ozs7OztjQUFDLFdBQW1CLEVBQUUsWUFBc0I7UUFDbEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ2YsTUFBTSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNsRDtRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FBQzs7Ozs7OztJQU8zQyxzQ0FBSzs7Ozs7Y0FBQyxXQUFtQjtRQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7SUFPL0MscUNBQUk7Ozs7O2NBQUMsV0FBbUI7UUFDM0IscUJBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7O0lBY3ZCLHlDQUFROzs7Ozs7Ozs7OztjQUFDLFdBQW1CLEVBQUUsTUFBTSxFQUFFLEdBQWM7UUFDdkQsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ1AsR0FBRyxHQUFHLElB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LENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7O2dCQTdPeEIsVUFBVSxTQUFDO29CQUNSLFVBQVUsRUFBRSxNQUFNO2lCQUNyQjs7O2lDQUxEOztTQU1hLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqIEBoaWRkZW4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIElneFNlbGVjdGlvbkFQSVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIElmIHByaW1hcnlLZXkgaXMgZGVmaW5lZCwgdGhlbiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgYmFzZWQgb24gdGhlIHByaW1hcnlLZXksIGFuZCBpdCBpcyBhcnJheSBvZiBudW1iZXJzLCBzdHJpbmdzLCBldGMuXG4gICAgICogSWYgdGhlIHByaW1hcnlLZXkgaXMgb21pdHRlZCwgdGhlbiBzZWxlY3Rpb24gaXMgYmFzZWQgb24gdGhlIGl0ZW0gZGF0YVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZWxlY3Rpb246IE1hcDxzdHJpbmcsICBTZXQ8YW55Pj4gPSBuZXcgTWFwPHN0cmluZywgU2V0PGFueT4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoY29tcG9uZW50SUQ6IHN0cmluZyk6IFNldDxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldChjb21wb25lbnRJRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG5ldyBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBuZXdTZWxlY3Rpb24gVGhlIG5ldyBjb21wb25lbnQgc2VsZWN0aW9uIHRvIGJlIHNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0KGNvbXBvbmVudElEOiBzdHJpbmcsIG5ld1NlbGVjdGlvbjogU2V0PGFueT4pIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnRJRCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGNvbXBvbmVudCBpZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXQoY29tcG9uZW50SUQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHNlbGVjdGlvbiBmb3IgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhcihjb21wb25lbnRJRDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldChjb21wb25lbnRJRCwgdGhpcy5nZXRfZW1wdHkoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbiBsZW5ndGguXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIHNpemUoY29tcG9uZW50SUQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHNlbCA9IHRoaXMuZ2V0KGNvbXBvbmVudElEKTtcbiAgICAgICAgcmV0dXJuIHNlbCA/IHNlbC5zaXplIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBzZWxlY3Rpb24gdGhhdCBjb25zaXN0IG9mIHRoZSBuZXcgaXRlbSBhZGRlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIFRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIGlzIG5ldyBTZXQsXG4gICAgICogdGhlcmVmb3JlIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBjb21wb25lbnQgc2VsZWN0aW9uIHlvdSBuZWVkIHRvIGNhbGwgaW4gYWRkaXRpb24gdGhlIHNldF9zZWxlY3Rpb24oKSBtZXRob2RcbiAgICAgKiBvciBpbnN0ZWFkIHVzZSB0aGUgc2VsZWN0X2l0ZW0oKSBvbmUuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbSB0by5cbiAgICAgKiBAcGFyYW0gaXRlbUlEIElEIG9mIHRoZSBpdGVtIHRvIGFkZCB0byBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBzZWwgVXNlZCBpbnRlcm5hbGx5IG9ubHkgYnkgdGhlIHNlbGVjdGlvbiAoYWRkX2l0ZW1zIG1ldGhvZCkgdG8gYWNjdW11bGF0ZSBzZWxlY3Rpb24gZm9yIG11bHRpcGxlIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGFmdGVyIHRoZSBuZXcgaXRlbSBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkX2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pik6IFNldDxhbnk+IHtcbiAgICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgICAgIHNlbCA9IG5ldyBTZXQodGhpcy5nZXQoY29tcG9uZW50SUQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbCA9IHRoaXMuZ2V0X2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpdGVtSUQgJiYgaXRlbUlEICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgaXRlbSBpZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWwuYWRkKGl0ZW1JRCk7XG4gICAgICAgIHJldHVybiBzZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgc2VsZWN0aW9uIHRoYXQgY29uc2lzdCBvZiB0aGUgbmV3IGl0ZW1zIGFkZGVkIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogVGhlIHJldHVybmVkIGNvbGxlY3Rpb24gaXMgbmV3IFNldCxcbiAgICAgKiB0aGVyZWZvcmUgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGNvbXBvbmVudCBzZWxlY3Rpb24geW91IG5lZWQgdG8gY2FsbCBpbiBhZGRpdGlvbiB0aGUgc2V0X3NlbGVjdGlvbigpIG1ldGhvZFxuICAgICAqIG9yIGluc3RlYWQgdXNlIHRoZSBzZWxlY3RfaXRlbXMoKSBvbmUuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbXMgdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRHMgQXJyYXkgb2YgSURzIG9mIHRoZSBpdGVtcyB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xlYXJTZWxlY3Rpb24gSWYgdHJ1ZSBpdCB3aWxsIGNsZWFyIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNlbGVjdGlvbiBhZnRlciB0aGUgbmV3IGl0ZW1zIGFyZSBhZGRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkX2l0ZW1zKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRHM6IGFueVtdLCBjbGVhclNlbGVjdGlvbj86IGJvb2xlYW4pOiBTZXQ8YW55PiB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNldDxhbnk+O1xuICAgICAgICBpZiAoY2xlYXJTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0X2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbUlEcy5mb3JFYWNoKChpdGVtKSA9PiBzZWxlY3Rpb24gPSB0aGlzLmFkZF9pdGVtKGNvbXBvbmVudElELCBpdGVtLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbSB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSBhZGQgbmV3IGl0ZW0gdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gc2VsIFVzZWQgaW50ZXJuYWxseSBvbmx5IGJ5IHRoZSBzZWxlY3Rpb24gKHNlbGVjdF9pdGVtcyBtZXRob2QpIHRvIGFjY3VtdWxhdGUgc2VsZWN0aW9uIGZvciBtdWx0aXBsZSBpdGVtcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2VsZWN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICB0aGlzLnNldChjb21wb25lbnRJRCwgdGhpcy5hZGRfaXRlbShjb21wb25lbnRJRCwgaXRlbUlELCBzZWwpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbXMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2UgYWRkIG5ldyBpdGVtcyB0by5cbiAgICAgKiBAcGFyYW0gaXRlbUlEcyBBcnJheSBvZiBJRHMgb2YgdGhlIGl0ZW1zIHRvIGFkZCB0byBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjbGVhclNlbGVjdGlvbiBJZiB0cnVlIGl0IHdpbGwgY2xlYXIgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEOiBhbnlbXSwgY2xlYXJTZWxlY3Rpb24/OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbXBvbmVudElELCB0aGlzLmFkZF9pdGVtcyhjb21wb25lbnRJRCwgaXRlbUlELCBjbGVhclNlbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNlbGVjdGlvbiB0aGF0IGNvbnNpc3Qgb2YgdGhlIG5ldyBpdGVtcyBleGNsdWRlZCBmcm9tIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogVGhlIHJldHVybmVkIGNvbGxlY3Rpb24gaXMgbmV3IFNldCxcbiAgICAgKiB0aGVyZWZvcmUgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGNvbXBvbmVudCBzZWxlY3Rpb24geW91IG5lZWQgdG8gY2FsbCBpbiBhZGRpdGlvbiB0aGUgc2V0X3NlbGVjdGlvbigpIG1ldGhvZFxuICAgICAqIG9yIGluc3RlYWQgdXNlIHRoZSBkZXNlbGVjdF9pdGVtKCkgb25lLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSByZW1vdmUgaXRlbXMgZnJvbS5cbiAgICAgKiBAcGFyYW0gaXRlbUlEIElEIG9mIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHNlbCBVc2VkIGludGVybmFsbHkgb25seSBieSB0aGUgc2VsZWN0aW9uIChkZWxldGVfaXRlbXMgbWV0aG9kKSB0byBhY2N1bXVsYXRlIGRlc2VsZWN0ZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIGl0ZW0gaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlX2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICBpZiAoIXNlbCkge1xuICAgICAgICAgICAgc2VsID0gbmV3IFNldCh0aGlzLmdldChjb21wb25lbnRJRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5kZWxldGUoaXRlbUlEKTtcbiAgICAgICAgcmV0dXJuIHNlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBzZWxlY3Rpb24gdGhhdCBjb25zaXN0IG9mIHRoZSBuZXcgaXRlbXMgcmVtb3ZlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIFRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIGlzIG5ldyBTZXQsXG4gICAgICogdGhlcmVmb3JlIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBjb21wb25lbnQgc2VsZWN0aW9uIHlvdSBuZWVkIHRvIGNhbGwgaW4gYWRkaXRpb24gdGhlIHNldF9zZWxlY3Rpb24oKSBtZXRob2RcbiAgICAgKiBvciBpbnN0ZWFkIHVzZSB0aGUgZGVzZWxlY3RfaXRlbXMoKSBvbmUuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIHJlbW92ZSBpdGVtcyBmcm9tLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW1zIHRvIHJlbW92ZSBmcm9tIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEczogYW55W10pOiBTZXQ8YW55PiB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNldDxhbnk+O1xuICAgICAgICBpdGVtSURzLmZvckVhY2goKGRlc2VsZWN0ZWRJdGVtKSA9PiBzZWxlY3Rpb24gPSB0aGlzLmRlbGV0ZV9pdGVtKGNvbXBvbmVudElELCBkZXNlbGVjdGVkSXRlbSwgc2VsZWN0aW9uKSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSByZW1vdmUgaXRlbSBmcm9tLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gc2VsIFVzZWQgaW50ZXJuYWxseSBvbmx5IGJ5IHRoZSBzZWxlY3Rpb24gKGRlc2VsZWN0X2l0ZW1zIG1ldGhvZCkgdG8gYWNjdW11bGF0ZSBzZWxlY3Rpb24gZm9yIG11bHRpcGxlIGl0ZW1zLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZXNlbGVjdF9pdGVtKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCwgc2VsPzogU2V0PGFueT4pIHtcbiAgICAgICAgdGhpcy5zZXQoY29tcG9uZW50SUQsIHRoaXMuZGVsZXRlX2l0ZW0oY29tcG9uZW50SUQsIGl0ZW1JRCwgc2VsKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGl0ZW1zIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbXMgdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRHMgQXJyYXkgb2YgSURzIG9mIHRoZSBpdGVtcyB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEOiBhbnlbXSwgY2xlYXJTZWxlY3Rpb24/OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbXBvbmVudElELCB0aGlzLmRlbGV0ZV9pdGVtcyhjb21wb25lbnRJRCwgaXRlbUlEKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQgaW4gdGhlIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc19pdGVtX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIGlmICghc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbC5oYXMoaXRlbUlEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIFRoaXMgaXMgY29ycmVjdCB3aGVuIHdlIGhhdmUgb25seSBvbmUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiAoZm9yIHNpbmdsZSBzZWxlY3Rpb24gcHVycG9zZXMpXG4gICAgICogYW5kIHRoZSBtZXRob2QgcmV0dXJucyB0aGF0IGl0ZW0uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBGaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAgICovXG4gICAgcHVibGljIGZpcnN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIGlmIChzZWwgJiYgc2VsLnNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGRhdGFDb3VudDogbnVtYmVyIE51bWJlciBvZiBpdGVtcyBpbiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGFyZV9hbGxfc2VsZWN0ZWQoY29tcG9uZW50SUQ6IHN0cmluZywgZGF0YUNvdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZShjb21wb25lbnRJRCkgPT09IGRhdGFDb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYW55IG9mIHRoZSBpdGVtcyBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gZGF0YSBFbnRpcmUgZGF0YSBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIHRoZXJlIGlzIGFueSBpdGVtIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhcmVfbm9uZV9zZWxlY3RlZChjb21wb25lbnRJRDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoY29tcG9uZW50SUQpID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcHJpbWFyeSBrZXkgdmFsdWVzIGZyb20gYSBkYXRhIGFycmF5LiBJZiB0aGVyZSBpc24ndCBhIHByaW1hcnkga2V5IGRlZmluZWQgdGhhdCB0aGUgZW50aXJlIGRhdGEgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gZGF0YSBFbnRpcmUgZGF0YSBhcnJheS5cbiAgICAgKiBAcGFyYW0gcHJpbWFyeUtleSBEYXRhIHByaW1hcnkga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgaWRlbnRpZmllcnMsIGVpdGhlciBwcmltYXJ5IGtleSB2YWx1ZXMgb3IgdGhlIGVudGlyZSBkYXRhIGFycmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRfYWxsX2lkcyhkYXRhLCBwcmltYXJ5S2V5Pykge1xuICAgICAgICByZXR1cm4gcHJpbWFyeUtleSA/IGRhdGEubWFwKCh4KSA9PiB4W3ByaW1hcnlLZXldKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlbXB0eSBzZWxlY3Rpb24gY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBlbXB0eSBzZXQuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0X2VtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgIH1cbn1cbiJdfQ==