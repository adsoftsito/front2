/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, Optional, Output, Inject } from '@angular/core';
import { IgxNavigationService } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { ConnectedPositioningStrategy, AbsoluteScrollStrategy } from '../../services';
import { filter, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
export class IgxToggleDirective {
    /**
     * @hidden
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} overlayService
     * @param {?} navigationService
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        this.overlayClosed = () => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.onClosed.emit();
            this.unsubscribe();
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     * @return {?}
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    open(overlaySettings) {
        this._collapsed = false;
        this.cdr.detectChanges();
        const /** @type {?} */ openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        if (this._overlayId) {
            this.overlayService.show(this._overlayId, overlaySettings);
        }
        else {
            this._overlayId = this.overlayService.show(this.elementRef, overlaySettings);
        }
        this.unsubscribe();
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter, takeUntil(this.destroy$)).subscribe(() => {
            this.onOpened.emit();
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter, takeUntil(this.destroy$))
            .subscribe((e) => {
            const /** @type {?} */ eventArgs = { cancel: false };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter, takeUntil(this.destroy$))
            .subscribe(this.overlayClosed);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    close() {
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    toggle(overlaySettings) {
        this.collapsed ? this.open(overlaySettings) : this.close();
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
}
IgxToggleDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            },] },
];
/** @nocollapse */
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] },] },
    { type: IgxNavigationService, decorators: [{ type: Optional },] },
];
IgxToggleDirective.propDecorators = {
    "onOpened": [{ type: Output },],
    "onOpening": [{ type: Output },],
    "onClosed": [{ type: Output },],
    "onClosing": [{ type: Output },],
    "id": [{ type: Input },],
    "hiddenClass": [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] },],
    "defaultClass": [{ type: HostBinding, args: ['class.igx-toggle',] },],
};
function IgxToggleDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxToggleDirective.propDecorators;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayId;
    /** @type {?} */
    IgxToggleDirective.prototype.destroy$;
    /** @type {?} */
    IgxToggleDirective.prototype._overlaySubFilter;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayOpenedSub;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayClosingSub;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayClosedSub;
    /**
     * Emits an event after the toggle container is opened.
     *
     * ```typescript
     * onToggleOpened(event) {
     *    alert("Toggle opened!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpened)='onToggleOpened($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpened;
    /**
     * Emits an event before the toggle container is opened.
     *
     * ```typescript
     * onToggleOpening(event) {
     *  alert("Toggle opening!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpening)='onToggleOpening($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpening;
    /**
     * Emits an event after the toggle container is closed.
     *
     * ```typescript
     * onToggleClosed(event) {
     *  alert("Toggle closed!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onClosed)='onToggleClosed($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosed;
    /**
     * Emits an event before the toggle container is closed.
     *
     * ```typescript
     * onToggleClosing(event) {
     *  alert("Toggle closing!");
     * }
     * ```
     *
     * ```html
     * <div
     *  igxToggle
     *  (onClosing)='onToggleClosing($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosing;
    /** @type {?} */
    IgxToggleDirective.prototype._collapsed;
    /**
     * Identifier which is registered into `IgxNavigationService`
     *
     * ```typescript
     * let myToggleId = this.toggle.id;
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.id;
    /** @type {?} */
    IgxToggleDirective.prototype.overlayClosed;
    /** @type {?} */
    IgxToggleDirective.prototype.elementRef;
    /** @type {?} */
    IgxToggleDirective.prototype.cdr;
    /** @type {?} */
    IgxToggleDirective.prototype.overlayService;
    /** @type {?} */
    IgxToggleDirective.prototype.navigationService;
}
export class IgxToggleActionDirective {
    /**
     * @param {?} element
     * @param {?} navigationService
     */
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * DEPRECATED. Determines whether the toggle should close when you click outside.
     *
     * ```typescript
     * // get
     * let closesOnOutsideClick = this.toggle.closeOnOutsideClick;
     * ```
     * @return {?}
     */
    get closeOnOutsideClick() {
        return this._closeOnOutsideClick;
    }
    /**
     * ```html
     * <!--set-->
     * <div igxToggleAction [closeOnOutsideClick]="'true'"></div>
     * ```
     * @param {?} v
     * @return {?}
     */
    set closeOnOutsideClick(v) {
        console.warn(`igxToggleAction 'closeOnOutsideClick' input is deprecated. Use 'overlaySettings' input object instead.`);
        this._closeOnOutsideClick = v;
    }
    /**
     * @hidden
     * @param {?} target
     * @return {?}
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    onClick() {
        if (this.closeOnOutsideClick !== undefined) {
            this._overlayDefaults.closeOnOutsideClick = this.closeOnOutsideClick;
        }
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        if (this.overlaySettings && this.overlaySettings.positionStrategy && !this.overlaySettings.positionStrategy.settings.target) {
            this.overlaySettings.positionStrategy.settings.target = this.element.nativeElement;
        }
        this.target.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings));
    }
}
IgxToggleActionDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            },] },
];
/** @nocollapse */
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: IgxNavigationService, decorators: [{ type: Optional },] },
];
IgxToggleActionDirective.propDecorators = {
    "overlaySettings": [{ type: Input },],
    "closeOnOutsideClick": [{ type: Input },],
    "outlet": [{ type: Input, args: ['igxToggleOutlet',] },],
    "target": [{ type: Input, args: ['igxToggleAction',] },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};
function IgxToggleActionDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleActionDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleActionDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxToggleActionDirective.propDecorators;
    /** @type {?} */
    IgxToggleActionDirective.prototype._overlayDefaults;
    /**
     * Provide settings that control the toggle overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: false,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <!--set-->
     * <div igxToggleAction [overlaySettings]="settings"></div>
     * ```
     * @type {?}
     */
    IgxToggleActionDirective.prototype.overlaySettings;
    /** @type {?} */
    IgxToggleActionDirective.prototype._closeOnOutsideClick;
    /**
     * Determines where the toggle element overlay should be attached.
     *
     * ```html
     * <!--set-->
     * <div igxToggleAction [igxToggleOutlet]="outlet"></div>
     * ```
     * Where `outlet` in an instance of `IgxOverlayOutletDirective` or an `ElementRef`
     * @type {?}
     */
    IgxToggleActionDirective.prototype.outlet;
    /** @type {?} */
    IgxToggleActionDirective.prototype._target;
    /** @type {?} */
    IgxToggleActionDirective.prototype.element;
    /** @type {?} */
    IgxToggleActionDirective.prototype.navigationService;
}
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export class IgxOverlayOutletDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
    }
    /**
     * @hidden
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
}
IgxOverlayOutletDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            },] },
];
/** @nocollapse */
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef, },
];
function IgxOverlayOutletDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxOverlayOutletDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxOverlayOutletDirective.ctorParameters;
    /** @type {?} */
    IgxOverlayOutletDirective.prototype.element;
}
export class IgxToggleModule {
}
IgxToggleModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            },] },
];
function IgxToggleModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBR1IsUUFBUSxFQUNSLE1BQU0sRUFDTixNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sdUJBQXVCLENBQUM7QUFDMUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFxQyw0QkFBNEIsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pILE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFrQyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFRL0QsTUFBTTs7Ozs7Ozs7SUFtSUYsWUFDWSxZQUNBLEtBQzJCLGdCQUNmO1FBSFosZUFBVSxHQUFWLFVBQVU7UUFDVixRQUFHLEdBQUgsR0FBRztRQUN3QixtQkFBYyxHQUFkLGNBQWM7UUFDN0Isc0JBQWlCLEdBQWpCLGlCQUFpQjt3QkFySXRCLElBQUksT0FBTyxFQUFXO2lDQUMyQztZQUNoRixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDeEM7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQXNCaUIsSUFBSSxZQUFZLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQW1CakIsSUFBSSxZQUFZLEVBQXVCOzs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFtQnhDLElB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ekMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLFFBQVEsRUFBRSxvQkFBb0I7YUFDakM7Ozs7WUE1WkcsVUFBVTs7Ozs7Ozs7Ozs7OztBQTJhZCxNQUFNOzs7WUFMTCxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLENBQUM7Z0JBQ3ZGLE9BQU8sRUFBRSxDQUFDLGtCQUFrQixFQUFFLHdCQUF3QixFQUFFLHlCQUF5QixDQUFDO2dCQUNsRixTQUFTLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzthQUNwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBOZ01vZHVsZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBJbmplY3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hOYXZpZ2F0aW9uU2VydmljZSwgSVRvZ2dsZVZpZXcgfSBmcm9tICcuLi8uLi9jb3JlL25hdmlnYXRpb24nO1xuaW1wb3J0IHsgSWd4T3ZlcmxheVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vdmVybGF5L292ZXJsYXknO1xuaW1wb3J0IHsgT3ZlcmxheVNldHRpbmdzLCBPdmVybGF5RXZlbnRBcmdzLCBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5LCBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIE9wZXJhdG9yRnVuY3Rpb24sIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE92ZXJsYXlDYW5jZWxhYmxlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgQ2FuY2VsYWJsZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZScsXG4gICAgc2VsZWN0b3I6ICdbaWd4VG9nZ2xlXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlRGlyZWN0aXZlIGltcGxlbWVudHMgSVRvZ2dsZVZpZXcsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF9vdmVybGF5SWQ6IHN0cmluZztcbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBwcml2YXRlIF9vdmVybGF5U3ViRmlsdGVyOiBPcGVyYXRvckZ1bmN0aW9uPE92ZXJsYXlFdmVudEFyZ3MsIE92ZXJsYXlFdmVudEFyZ3M+W10gPSBbXG4gICAgICAgIGZpbHRlcih4ID0+IHguaWQgPT09IHRoaXMuX292ZXJsYXlJZClcbiAgICBdO1xuICAgIHByaXZhdGUgX292ZXJsYXlPcGVuZWRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q2xvc2luZ1N1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zZWRTdWI6IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZU9wZW5lZChldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiVG9nZ2xlIG9wZW5lZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uT3BlbmVkKT0nb25Ub2dnbGVPcGVuZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uT3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZU9wZW5pbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgb3BlbmluZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uT3BlbmluZyk9J29uVG9nZ2xlT3BlbmluZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25PcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxDYW5jZWxhYmxlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlQ2xvc2VkKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIGNsb3NlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQ2xvc2VkKT0nb25Ub2dnbGVDbG9zZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NpbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2luZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgaWd4VG9nZ2xlXG4gICAgICogIChvbkNsb3NpbmcpPSdvblRvZ2dsZUNsb3NpbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8Q2FuY2VsYWJsZUV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgd2hpY2ggaXMgcmVnaXN0ZXJlZCBpbnRvIGBJZ3hOYXZpZ2F0aW9uU2VydmljZWBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbXlUb2dnbGVJZCA9IHRoaXMudG9nZ2xlLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZS0taGlkZGVuJylcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oaWRkZW4nKVxuICAgIHB1YmxpYyBnZXQgaGlkZGVuQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdG9nZ2xlJylcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneE92ZXJsYXlTZXJ2aWNlKSBwcml2YXRlIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdG9nZ2xlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUub3BlbigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBvcGVuKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAgIGNvbnN0IG9wZW5FdmVudEFyZ3M6IENhbmNlbGFibGVFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5vbk9wZW5pbmcuZW1pdChvcGVuRXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKG9wZW5FdmVudEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5zaG93KHRoaXMuX292ZXJsYXlJZCwgb3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlJZCA9IHRoaXMub3ZlcmxheVNlcnZpY2Uuc2hvdyh0aGlzLmVsZW1lbnRSZWYsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlPcGVuZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLm9uT3BlbmVkLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlciwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW5lZC5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vdmVybGF5Q2xvc2luZ1N1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2VcbiAgICAgICAgICAgIC5vbkNsb3NpbmdcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIsIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGU6IE92ZXJsYXlDYW5jZWxhYmxlRXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBDYW5jZWxhYmxlRXZlbnRBcmdzID0geyBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NpbmcuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIGUuY2FuY2VsID0gZXZlbnRBcmdzLmNhbmNlbDtcblxuICAgICAgICAgICAgICAgIC8vICBpbiBjYXNlIGV2ZW50IGlzIG5vdCBjYW5jZWxlZCB0aGlzIHdpbGwgY2xvc2UgdGhlIHRvZ2dsZSBhbmQgd2UgbmVlZCB0byB1bnN1YnNjcmliZS5cbiAgICAgICAgICAgICAgICAvLyAgT3RoZXJ3aXNlIGlmIGZvciBzb21lIHJlYXNvbiwgZS5nLiBjbG9zZSBvbiBvdXRzaWRlIGNsaWNrLCBjbG9zZSgpIGdldHMgY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vICBvbkNsb3NlZCB3YXMgZmlyZWQgd2Ugd2lsbCBlbmQgd2l0aCBjYWxsaW5nIG9uQ2xvc2luZyBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgICAgIGlmICghZS5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2luZ1N1Yik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDbG9zZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLm9uQ2xvc2VkXG4gICAgICAgICAgICAucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMub3ZlcmxheUNsb3NlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5oaWRlKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgb3IgY2xvc2VzIHRoZSB0b2dnbGUsIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID8gdGhpcy5vcGVuKG92ZXJsYXlTZXR0aW5ncykgOiB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwb3NpdGlvbnMgdGhlIHRvZ2dsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5yZXBvc2l0aW9uKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHJlcG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UucmVwb3NpdGlvbih0aGlzLl9vdmVybGF5SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlICYmIHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWRkKHRoaXMuaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5yZW1vdmUodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNlZCAmJiB0aGlzLl9vdmVybGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuaGlkZSh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvdmVybGF5Q2xvc2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vdmVybGF5SWQ7XG4gICAgICAgIHRoaXMub25DbG9zZWQuZW1pdCgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5T3BlbmVkU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2luZ1N1Yik7XG4gICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheUNsb3NlZFN1Yik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhclN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbikge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmICFzdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICd0b2dnbGUtYWN0aW9uJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hUb2dnbGVBY3Rpb25dJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hUb2dnbGVBY3Rpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHByb3RlY3RlZCBfb3ZlcmxheURlZmF1bHRzOiBPdmVybGF5U2V0dGluZ3M7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIHNldHRpbmdzIHRoYXQgY29udHJvbCB0aGUgdG9nZ2xlIG92ZXJsYXkgcG9zaXRpb25pbmcsIGludGVyYWN0aW9uIGFuZCBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICogICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiBmYWxzZSxcbiAgICAgKiAgICAgIG1vZGFsOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICogLS0tXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbb3ZlcmxheVNldHRpbmdzXT1cInNldHRpbmdzXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgb3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3M7XG5cbiAgICBwcml2YXRlIF9jbG9zZU9uT3V0c2lkZUNsaWNrOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQuIERldGVybWluZXMgd2hldGhlciB0aGUgdG9nZ2xlIHNob3VsZCBjbG9zZSB3aGVuIHlvdSBjbGljayBvdXRzaWRlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBjbG9zZXNPbk91dHNpZGVDbGljayA9IHRoaXMudG9nZ2xlLmNsb3NlT25PdXRzaWRlQ2xpY2s7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBjbG9zZU9uT3V0c2lkZUNsaWNrKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VPbk91dHNpZGVDbGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbY2xvc2VPbk91dHNpZGVDbGlja109XCIndHJ1ZSdcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgY2xvc2VPbk91dHNpZGVDbGljayh2OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgaWd4VG9nZ2xlQWN0aW9uICdjbG9zZU9uT3V0c2lkZUNsaWNrJyBpbnB1dCBpcyBkZXByZWNhdGVkLiBVc2UgJ292ZXJsYXlTZXR0aW5ncycgaW5wdXQgb2JqZWN0IGluc3RlYWQuYCk7XG4gICAgICAgIHRoaXMuX2Nsb3NlT25PdXRzaWRlQ2xpY2sgPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hlcmUgdGhlIHRvZ2dsZSBlbGVtZW50IG92ZXJsYXkgc2hvdWxkIGJlIGF0dGFjaGVkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbaWd4VG9nZ2xlT3V0bGV0XT1cIm91dGxldFwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIFdoZXJlIGBvdXRsZXRgIGluIGFuIGluc3RhbmNlIG9mIGBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlYCBvciBhbiBgRWxlbWVudFJlZmBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneFRvZ2dsZU91dGxldCcpXG4gICAgcHVibGljIG91dGxldDogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB8IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVBY3Rpb24nKVxuICAgIHNldCB0YXJnZXQodGFyZ2V0OiBhbnkpIHtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3RhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmdldCh0aGlzLl90YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IElUb2dnbGVWaWV3IHwgc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBuZXcgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSh7IHRhcmdldDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgfSksXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogbmV3IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBtb2RhbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIHB1YmxpYyBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlEZWZhdWx0cy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzLm91dGxldCA9IHRoaXMub3V0bGV0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlTZXR0aW5ncyAmJiB0aGlzLm92ZXJsYXlTZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5ICYmICF0aGlzLm92ZXJsYXlTZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LnNldHRpbmdzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5zZXR0aW5ncy50YXJnZXQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldC50b2dnbGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3ZlcmxheURlZmF1bHRzLCB0aGlzLm92ZXJsYXlTZXR0aW5ncykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNYXJrIGFuIGVsZW1lbnQgYXMgYW4gaWd4T3ZlcmxheSBvdXRsZXQgY29udGFpbmVyLlxuICogRGlyZWN0aXZlIGluc3RhbmNlIGlzIGV4cG9ydGVkIGFzIGBvdmVybGF5LW91dGxldGAgdG8gYmUgYXNzaWduZWQgdG8gdGVtcGxhdGVzIHZhcmlhYmxlczpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgaWd4T3ZlcmxheU91dGxldCAjb3V0bGV0PVwib3ZlcmxheS1vdXRsZXRcIj48L2Rpdj5cbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ292ZXJsYXktb3V0bGV0JyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hPdmVybGF5T3V0bGV0XSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4VG9nZ2xlRGlyZWN0aXZlLCBJZ3hUb2dnbGVBY3Rpb25EaXJlY3RpdmUsIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hUb2dnbGVEaXJlY3RpdmUsIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSwgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbSWd4TmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZU1vZHVsZSB7IH1cbiJdfQ==