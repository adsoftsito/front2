/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { VerticalAlignment, HorizontalAlignment } from './../utilities';
import { ConnectedPositioningStrategy } from './connected-positioning-strategy';
/** @enum {number} */
var Axis = {
    X: 1,
    Y: 0,
};
Axis[Axis.X] = "X";
Axis[Axis.Y] = "Y";
var AutoPositionStrategy = /** @class */ (function (_super) {
    tslib_1.__extends(AutoPositionStrategy, _super);
    function AutoPositionStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.offsetPadding = 16;
        return _this;
    }
    /**
     * @param {?} document
     * @return {?}
     */
    AutoPositionStrategy.prototype.getViewPort = /**
     * @param {?} document
     * @return {?}
     */
    function (document) {
        // Material Design implementation
        var /** @type {?} */ clientRect = document.documentElement.getBoundingClientRect();
        var /** @type {?} */ scrollPosition = {
            top: -clientRect.top,
            left: -clientRect.left
        };
        var /** @type {?} */ width = window.innerWidth;
        var /** @type {?} */ height = window.innerHeight;
        return {
            top: scrollPosition.top,
            left: scrollPosition.left,
            bottom: scrollPosition.top + height,
            right: scrollPosition.left + width,
            height: height,
            width: width
        };
    };
    // The position method should return a <div> container that will host the component
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    AutoPositionStrategy.prototype.position = /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        var _this = this;
        if (!initialCall) {
            _super.prototype.position.call(this, contentElement, size);
            return;
        }
        this._initialSettings = this._initialSettings || Object.assign({}, this._initialSettings, this.settings);
        this.settings = this._initialSettings ? Object.assign({}, this.settings, this._initialSettings) : this.settings;
        var /** @type {?} */ viewPort = this.getViewPort(document);
        _super.prototype.position.call(this, contentElement, size);
        var /** @type {?} */ checkIfMoveHorizontal = function (elem) {
            var /** @type {?} */ leftBound = elem.offsetLeft;
            var /** @type {?} */ rightBound = elem.offsetLeft + elem.lastElementChild.clientWidth;
            switch (_this.settings.horizontalDirection) {
                case HorizontalAlignment.Left:
                    if (leftBound < viewPort.left) {
                        _this.settings.horizontalDirection = HorizontalAlignment.Right;
                        _this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                    }
                    break;
                case HorizontalAlignment.Right:
                    if (rightBound > viewPort.right) {
                        _this.settings.horizontalDirection = HorizontalAlignment.Left;
                        _this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                    }
                    break;
                default:
                    return;
            }
        };
        var /** @type {?} */ checkIfMoveVertical = function (elem) {
            var /** @type {?} */ topBound = elem.offsetTop;
            var /** @type {?} */ bottomBound = elem.offsetTop + elem.lastElementChild.clientHeight;
            switch (_this.settings.verticalDirection) {
                case VerticalAlignment.Top:
                    if (topBound < viewPort.top) {
                        _this.settings.verticalDirection = VerticalAlignment.Bottom;
                        _this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                    }
                    break;
                case VerticalAlignment.Bottom:
                    if (bottomBound > viewPort.bottom) {
                        _this.settings.verticalDirection = VerticalAlignment.Top;
                        _this.settings.verticalStartPoint = VerticalAlignment.Top;
                    }
                    break;
                default:
                    return;
            }
        };
        checkIfMoveVertical(contentElement);
        checkIfMoveHorizontal(contentElement);
        _super.prototype.position.call(this, contentElement, size);
    };
    return AutoPositionStrategy;
}(ConnectedPositioningStrategy));
export { AutoPositionStrategy };
function AutoPositionStrategy_tsickle_Closure_declarations() {
    /** @type {?} */
    AutoPositionStrategy.prototype.offsetPadding;
    /** @type {?} */
    AutoPositionStrategy.prototype._initialSettings;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9hdXRvLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFvQixpQkFBaUIsRUFBRSxtQkFBbUIsRUFBUyxNQUFNLGdCQUFnQixDQUFDO0FBRWpHLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDOzs7Ozs7OztBQU1oRixJQUFBO0lBQTBDLGdEQUE0Qjs7OzhCQUMzQyxFQUFFOzs7Ozs7O0lBRXpCLDBDQUFXOzs7O0lBQVgsVUFBWSxRQUFROztRQUNoQixxQkFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ3BFLHFCQUFNLGNBQWMsR0FBRztZQUNuQixHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRztZQUNwQixJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSTtTQUN6QixDQUFDO1FBQ0YscUJBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDaEMscUJBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFbEMsTUFBTSxDQUFDO1lBQ0gsR0FBRyxFQUFFLGNBQWMsQ0FBQyxHQUFHO1lBQ3ZCLElBQUksRUFBRSxjQUFjLENBQUMsSUFBSTtZQUN6QixNQUFNLEVBQUUsY0FBYyxDQUFDLEdBQUcsR0FBRyxNQUFNO1lBQ25DLEtBQUssRUFBRSxjQUFjLENBQUMsSUFBSSxHQUFHLEtBQUs7WUFDbEMsTUFBTSxRQUFBO1lBQ04sS0FBSyxPQUFBO1NBQ1IsQ0FBQztLQUVMO0lBR0QsbUZBQW1GOzs7Ozs7OztJQUNuRix1Q0FBUTs7Ozs7OztJQUFSLFVBQVMsY0FBMkIsRUFBRSxJQUF1QyxFQUFFLFFBQW1CLEVBQUUs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Q0FBQyxRQUFRLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxDQUFDO3dCQUN4RCxLQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQztxQkFDNUQ7b0JBQ0QsS0FBSyxDQUFDO2dCQUNWO29CQUNJLE1BQU0sQ0FBQzthQUNkO1NBQ0osQ0FBQztRQUNGLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3BDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RDLGlCQUFNLFFBQVEsWUFBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDeEM7K0JBckZMO0VBUTBDLDRCQUE0QixFQThFckUsQ0FBQTtBQTlFRCxnQ0E4RUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb3NpdGlvblNldHRpbmdzLCBWZXJ0aWNhbEFsaWdubWVudCwgSG9yaXpvbnRhbEFsaWdubWVudCwgUG9pbnQgfSBmcm9tICcuLy4uL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBJUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4vSVBvc2l0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4vY29ubmVjdGVkLXBvc2l0aW9uaW5nLXN0cmF0ZWd5JztcblxuZW51bSBBeGlzIHtcbiAgICBYID0gMSxcbiAgICBZID0gMFxufVxuZXhwb3J0IGNsYXNzIEF1dG9Qb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSBpbXBsZW1lbnRzIElQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBwdWJsaWMgb2Zmc2V0UGFkZGluZyA9IDE2O1xuICAgIHByaXZhdGUgX2luaXRpYWxTZXR0aW5ncztcbiAgICBnZXRWaWV3UG9ydChkb2N1bWVudCkgeyAvLyBNYXRlcmlhbCBEZXNpZ24gaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB7XG4gICAgICAgICAgICB0b3A6IC1jbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IC1jbGllbnRSZWN0LmxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHNjcm9sbFBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBib3R0b206IHNjcm9sbFBvc2l0aW9uLnRvcCArIGhlaWdodCxcbiAgICAgICAgICAgIHJpZ2h0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICB9O1xuXG4gICAgfVxuXG5cbiAgICAvLyBUaGUgcG9zaXRpb24gbWV0aG9kIHNob3VsZCByZXR1cm4gYSA8ZGl2PiBjb250YWluZXIgdGhhdCB3aWxsIGhvc3QgdGhlIGNvbXBvbmVudFxuICAgIHBvc2l0aW9uKGNvbnRlbnRFbGVtZW50OiBIVE1MRWxlbWVudCwgc2l6ZTogeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LCBkb2N1bWVudD86IERvY3VtZW50LCBpbml0aWFsQ2FsbD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbml0aWFsQ2FsbCkge1xuICAgICAgICAgICAgc3VwZXIucG9zaXRpb24oY29udGVudEVsZW1lbnQsIHNpemUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRpYWxTZXR0aW5ncyA9IHRoaXMuX2luaXRpYWxTZXR0aW5ncyB8fCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbml0aWFsU2V0dGluZ3MsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5faW5pdGlhbFNldHRpbmdzID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZXR0aW5ncywgdGhpcy5faW5pdGlhbFNldHRpbmdzKSA6IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0ID0gdGhpcy5nZXRWaWV3UG9ydChkb2N1bWVudCk7XG4gICAgICAgIHN1cGVyLnBvc2l0aW9uKGNvbnRlbnRFbGVtZW50LCBzaXplKTtcbiAgICAgICAgY29uc3QgY2hlY2tJZk1vdmVIb3Jpem9udGFsID0gKGVsZW06IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0Qm91bmQgPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdW5kID0gZWxlbS5vZmZzZXRMZWZ0ICsgZWxlbS5sYXN0RWxlbWVudENoaWxkLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRCb3VuZCA8IHZpZXdQb3J0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50ID0gSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodEJvdW5kID4gdmlld1BvcnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgPSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjaGVja0lmTW92ZVZlcnRpY2FsID0gKGVsZW06IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3BCb3VuZCA9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tQm91bmQgPSBlbGVtLm9mZnNldFRvcCArIGVsZW0ubGFzdEVsZW1lbnRDaGlsZC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LlRvcDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcEJvdW5kIDwgdmlld1BvcnQudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uID0gVmVydGljYWxBbGlnbm1lbnQuQm90dG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b206XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3R0b21Cb3VuZCA+IHZpZXdQb3J0LmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxTdGFydFBvaW50ID0gVmVydGljYWxBbGlnbm1lbnQuVG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tJZk1vdmVWZXJ0aWNhbChjb250ZW50RWxlbWVudCk7XG4gICAgICAgIGNoZWNrSWZNb3ZlSG9yaXpvbnRhbChjb250ZW50RWxlbWVudCk7XG4gICAgICAgIHN1cGVyLnBvc2l0aW9uKGNvbnRlbnRFbGVtZW50LCBzaXplKTtcbiAgICB9XG59XG4iXX0=