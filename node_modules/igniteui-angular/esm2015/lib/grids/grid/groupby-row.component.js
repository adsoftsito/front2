/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, HostListener, Input, ViewChild, } from '@angular/core';
import { IgxSelectionAPIService } from '../../core/selection';
import { GridBaseAPIService } from '../api.service';
import { first } from 'rxjs/operators';
export class IgxGridGroupByRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} selection
     * @param {?} element
     * @param {?} cdr
     */
    constructor(gridAPI, selection, element, cdr) {
        this.gridAPI = gridAPI;
        this.selection = selection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.tabindex = 0;
    }
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     * @return {?}
     */
    get focused() {
        return this.isFocused;
    }
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     * @return {?}
     */
    get expanded() {
        return this.grid.isExpandedGroup(this.groupRow);
    }
    /**
     * @hidden
     * @return {?}
     */
    get describedBy() {
        const /** @type {?} */ grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
        return this.gridID + '_' + grRowExpr;
    }
    /**
     * @return {?}
     */
    get dataRowIndex() {
        return this.index;
    }
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     * @return {?}
     */
    get styleClasses() {
        return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level +
            (this.focused ? ` ${this.defaultCssClass}--active` : '');
    }
    /**
     * @hidden
     * @return {?}
     */
    onFocus() {
        this.isFocused = true;
    }
    /**
     * @hidden
     * @return {?}
     */
    onBlur() {
        this.isFocused = false;
    }
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @param {?=} key
     * @return {?}
     */
    toggle(key) {
        const /** @type {?} */ shouldExpand = (!key && !this.expanded) || (key && !this.expanded && (key === 'arrowleft' || key === 'left'));
        this.handleToggleScroll();
        if (!shouldExpand) {
            this.grid.verticalScrollContainer.getVerticalScroll().dispatchEvent(new Event('scroll'));
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        event.preventDefault();
        event.stopPropagation();
        const /** @type {?} */ alt = event.altKey;
        const /** @type {?} */ key = event.key.toLowerCase();
        if (!this.isKeySupportedInGroupRow(key) || event.ctrlKey) {
            return;
        }
        if (this.isToggleKey(key)) {
            if (!alt) {
                return;
            }
            this.toggle(key);
            return;
        }
        const /** @type {?} */ args = { cell: null, groupRow: this, event: event, cancel: false };
        this.grid.onFocusChange.emit(args);
        if (args.cancel) {
            return;
        }
        const /** @type {?} */ colIndex = this._getSelectedColIndex() || 0;
        const /** @type {?} */ visibleColumnIndex = this.grid.columnList.toArray()[colIndex].visibleIndex !== -1 ?
            this.grid.columnList.toArray()[colIndex].visibleIndex : 0;
        switch (key) {
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'tab':
                if (event.shiftKey) {
                    this.grid.navigation.navigateUp(this.nativeElement, this.index, this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex);
                }
                else {
                    this.grid.navigation.navigateDown(this.nativeElement, this.index, 0);
                }
                break;
        }
    }
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     * @return {?}
     */
    get grid() {
        return this.gridAPI.get(this.gridID);
    }
    /**
     * @hidden
     * @return {?}
     */
    get dataType() {
        return this.grid.getColumnByName(this.groupRow.expression.fieldName).dataType;
    }
    /**
     * @return {?}
     */
    _getSelectedColIndex() {
        const /** @type {?} */ cell = this.selection.first_item(this.gridID + '-cell');
        if (cell) {
            return cell.columnID;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isKeySupportedInGroupRow(key) {
        return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
            'tab'].indexOf(key) !== -1;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isToggleKey(key) {
        return ['left', 'right', 'arrowleft', 'arrowright'].indexOf(key) !== -1;
    }
    /**
     * @return {?}
     */
    handleToggleScroll() {
        if (this.grid.rowList.length > 0 && this.grid.rowList.last.index ===
            this.grid.verticalScrollContainer.igxForOf.length - 1) {
            const /** @type {?} */ groupRowIndex = this.index;
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first())
                .subscribe(() => {
                this.grid.nativeElement.querySelector(`[data-rowIndex="${groupRowIndex}"]`).focus();
            });
        }
        this.grid.toggleGroup(this.groupRow);
    }
}
IgxGridGroupByRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: `<ng-container #defaultGroupRow>
    <div (click)="toggle()" class="igx-grid__grouping-indicator">
        <igx-icon *ngIf="!expanded" fontSet="material">chevron_right</igx-icon>
        <igx-icon *ngIf="expanded" fontSet="material">expand_more</igx-icon>
    </div>

    <div class="igx-grid__group-content" #groupContent>
        <ng-container *ngTemplateOutlet="grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }">
        </ng-container>
    </div>

    <ng-template #defaultGroupByTemplate>
        <div class="igx-group-label">
            <igx-icon fontSet="material" class="igx-group-label__icon">group_work</igx-icon>
            <span class="igx-group-label__column-name">
            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:
            </span>

            <ng-container *ngIf="dataType === 'boolean' || dataType === 'string'; else default" >
                <span class="igx-group-label__text">{{ groupRow.value }}</span>
            </ng-container>
            <ng-template #default>
                <ng-container *ngIf="dataType === 'number'">
                    <span class="igx-group-label__text">{{ groupRow.value | number }}</span>
                </ng-container>
                <ng-container *ngIf="dataType === 'date'">
                    <span class="igx-group-label__text">{{ groupRow.value | date }}</span>
                </ng-container>
            </ng-template>

            <igx-badge [value]="groupRow.records ? groupRow.records.length : 0" class='igx-group-label__count-badge'></igx-badge>
        </div>
    </ng-template>
</ng-container>
`
            },] },
];
/** @nocollapse */
IgxGridGroupByRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService, },
    { type: IgxSelectionAPIService, },
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
IgxGridGroupByRowComponent.propDecorators = {
    "index": [{ type: Input },],
    "gridID": [{ type: Input },],
    "groupRow": [{ type: Input },],
    "groupContent": [{ type: ViewChild, args: ['groupContent',] },],
    "expanded": [{ type: HostBinding, args: ['attr.aria-expanded',] },],
    "tabindex": [{ type: HostBinding, args: ['attr.tabindex',] },],
    "describedBy": [{ type: HostBinding, args: ['attr.aria-describedby',] },],
    "dataRowIndex": [{ type: HostBinding, args: ['attr.data-rowIndex',] },],
    "styleClasses": [{ type: HostBinding, args: ['class',] },],
    "onFocus": [{ type: HostListener, args: ['focus',] },],
    "onBlur": [{ type: HostListener, args: ['blur',] },],
    "onKeydown": [{ type: HostListener, args: ['keydown', ['$event'],] },],
};
function IgxGridGroupByRowComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridGroupByRowComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridGroupByRowComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxGridGroupByRowComponent.propDecorators;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.defaultCssClass;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.paddingIndentationCssClass;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.isFocused;
    /**
     * An \@Input property that sets the index of the row.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.index;
    /**
     * An \@Input property that sets the id of the grid the row belongs to.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.gridID;
    /**
     * An \@Input property that specifies the group record the component renders for.
     * ```typescript
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.groupRow;
    /**
     * Returns a reference of the content of the group.
     * ```typescript
     * const groupRowContent = this.grid1.rowList.first.groupContent;
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.groupContent;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.tabindex;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.gridAPI;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.selection;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.element;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.cdr;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXBieS1yb3cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9ncmlkcy9ncmlkL2dyb3VwYnktcm93LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxTQUFTLEdBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFOUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBMEN2QyxNQUFNOzs7Ozs7O0lBRUYsWUFBbUIsT0FBaUQsRUFDeEQsV0FDRCxTQUNBO1FBSFEsWUFBTyxHQUFQLE9BQU8sQ0FBMEM7UUFDeEQsY0FBUyxHQUFULFNBQVM7UUFDVixZQUFPLEdBQVAsT0FBTztRQUNQLFFBQUcsR0FBSCxHQUFHOzs7OytCQUtjLHFCQUFxQjs7OzswQ0FLVixvQ0FBb0M7Ozs7eUJBS3JELEtBQUs7Ozs7d0JBK0RULENBQUM7S0E5RW1COzs7Ozs7OztJQXVCdEMsSUFBSSxPQUFPO1FBQ1AsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7S0FDekI7Ozs7Ozs7O1FBNkNHLFFBQVE7UUFDUixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7Ozs7UUFhaEQsV0FBVztRQUNYLHVCQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FB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Q0FBQztZQUN4RCx1QkFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFdBQVc7aUJBQ3hDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDYixTQUFTLENBQUMsR0FBRyxFQUFFO2dCQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsYUFBYSxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUN2RixDQUFDLENBQUM7U0FDVjtRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7OztZQXRSNUMsU0FBUyxTQUFDO2dCQUNQLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO2dCQUMxQixRQUFRLEVBQUUsc0JBQXNCO2dCQUNoQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ2I7YUFDQTs7OztZQTNDUSxrQkFBa0I7WUFGbEIsc0JBQXNCO1lBTjNCLFVBQVU7WUFGVixpQkFBaUI7OztzQkE0RmhCLEtBQUs7dUJBU0wsS0FBSzt5QkFTTCxLQUFLOzZCQVNMLFNBQVMsU0FBQyxjQUFjO3lCQVN4QixXQUFXLFNBQUMsb0JBQW9CO3lCQVFoQyxXQUFXLFNBQUMsZUFBZTs0QkFNM0IsV0FBVyxTQUFDLHVCQUF1Qjs2QkFNbkMsV0FBVyxTQUFDLG9CQUFvQjs2QkFxQmhDLFdBQVcsU0FBQyxPQUFPO3dCQVNuQixZQUFZLFNBQUMsT0FBTzt1QkFRcEIsWUFBWSxTQUFDLE1BQU07MEJBc0JuQixZQUFZLFNBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFNlbGVjdGlvbkFQSVNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBzZWxlY3RvcjogJ2lneC1ncmlkLWdyb3VwYnktcm93JyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgI2RlZmF1bHRHcm91cFJvdz5cbiAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiIGNsYXNzPVwiaWd4LWdyaWRfX2dyb3VwaW5nLWluZGljYXRvclwiPlxuICAgICAgICA8aWd4LWljb24gKm5nSWY9XCIhZXhwYW5kZWRcIiBmb250U2V0PVwibWF0ZXJpYWxcIj5jaGV2cm9uX3JpZ2h0PC9pZ3gtaWNvbj5cbiAgICAgICAgPGlneC1pY29uICpuZ0lmPVwiZXhwYW5kZWRcIiBmb250U2V0PVwibWF0ZXJpYWxcIj5leHBhbmRfbW9yZTwvaWd4LWljb24+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2dyb3VwLWNvbnRlbnRcIiAjZ3JvdXBDb250ZW50PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZ3JpZC5ncm91cFJvd1RlbXBsYXRlID8gZ3JpZC5ncm91cFJvd1RlbXBsYXRlIDogZGVmYXVsdEdyb3VwQnlUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGdyb3VwUm93IH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRHcm91cEJ5VGVtcGxhdGU+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JvdXAtbGFiZWxcIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIiBjbGFzcz1cImlneC1ncm91cC1sYWJlbF9faWNvblwiPmdyb3VwX3dvcms8L2lneC1pY29uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JvdXAtbGFiZWxfX2NvbHVtbi1uYW1lXCI+XG4gICAgICAgICAgICB7eyBncm91cFJvdy5leHByZXNzaW9uID8gZ3JvdXBSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUgOiAnJyB9fTpcbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImRhdGFUeXBlID09PSAnYm9vbGVhbicgfHwgZGF0YVR5cGUgPT09ICdzdHJpbmcnOyBlbHNlIGRlZmF1bHRcIiA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JvdXAtbGFiZWxfX3RleHRcIj57eyBncm91cFJvdy52YWx1ZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0PlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRhVHlwZSA9PT0gJ251bWJlcidcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JvdXAtbGFiZWxfX3RleHRcIj57eyBncm91cFJvdy52YWx1ZSB8IG51bWJlciB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZGF0YVR5cGUgPT09ICdkYXRlJ1wiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncm91cC1sYWJlbF9fdGV4dFwiPnt7IGdyb3VwUm93LnZhbHVlIHwgZGF0ZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDxpZ3gtYmFkZ2UgW3ZhbHVlXT1cImdyb3VwUm93LnJlY29yZHMgPyBncm91cFJvdy5yZWNvcmRzLmxlbmd0aCA6IDBcIiBjbGFzcz0naWd4LWdyb3VwLWxhYmVsX19jb3VudC1iYWRnZSc+PC9pZ3gtYmFkZ2U+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLWNvbnRhaW5lcj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4sXG4gICAgICAgIHByaXZhdGUgc2VsZWN0aW9uOiBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkZWZhdWx0Q3NzQ2xhc3MgPSAnaWd4LWdyaWRfX2dyb3VwLXJvdyc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhZGRpbmdJbmRlbnRhdGlvbkNzc0NsYXNzID0gJ2lneC1ncmlkX19ncm91cC1yb3ctLXBhZGRpbmctbGV2ZWwnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpc0ZvY3VzZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcm93IGlzIGZvY3VzZWQuXG4gICAgICogYGBgXG4gICAgICogbGV0IGdyaWRSb3dGb2N1c2VkID0gdGhpcy5ncmlkMS5yb3dMaXN0LmZpcnN0LmZvY3VzZWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBpbmRleCBvZiB0aGUgcm93LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQtZ3JvdXBieS1yb3cgW2dyaWRJRF09XCJpZFwiIFtpbmRleF09XCJyb3dJbmRleFwiIFtncm91cFJvd109XCJyb3dEYXRhXCIgI3Jvdz48L2lneC1ncmlkLWdyb3VwYnktcm93PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBpZCBvZiB0aGUgZ3JpZCB0aGUgcm93IGJlbG9uZ3MgdG8uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZC1ncm91cGJ5LXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW2dyb3VwUm93XT1cInJvd0RhdGFcIiAjcm93PjwvaWd4LWdyaWQtZ3JvdXBieS1yb3c+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ3JpZElEOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIGdyb3VwIHJlY29yZCB0aGUgY29tcG9uZW50IHJlbmRlcnMgZm9yLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiA8aWd4LWdyaWQtZ3JvdXBieS1yb3cgW2dyaWRJRF09XCJpZFwiIFtpbmRleF09XCJyb3dJbmRleFwiIFtncm91cFJvd109XCJyb3dEYXRhXCIgI3Jvdz48L2lneC1ncmlkLWdyb3VwYnktcm93PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2Ugb2YgdGhlIGNvbnRlbnQgb2YgdGhlIGdyb3VwLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cFJvd0NvbnRlbnQgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZ3JvdXBDb250ZW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2dyb3VwQ29udGVudCcpXG4gICAgcHVibGljIGdyb3VwQ29udGVudDogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZ3JvdXAgcm93IGlzIGV4cGFuZGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cFJvd0V4cGFuZGVkID0gdGhpcy5ncmlkMS5yb3dMaXN0LmZpcnN0LmV4cGFuZGVkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWV4cGFuZGVkJylcbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaXNFeHBhbmRlZEdyb3VwKHRoaXMuZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyB0YWJpbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGVzY3JpYmVkYnknKVxuICAgIGdldCBkZXNjcmliZWRCeSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBnclJvd0V4cHIgPSB0aGlzLmdyb3VwUm93LmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuZ3JvdXBSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZElEICsgJ18nICsgZ3JSb3dFeHByO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5kYXRhLXJvd0luZGV4JylcbiAgICBnZXQgZGF0YVJvd0luZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIEhUTUwgZWxlbWVudC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBSb3dFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBuYXRpdmVFbGVtZW50KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHlsZSBjbGFzc2VzIGFwcGxpZWQgdG8gdGhlIGdyb3VwIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwQ3NzU3R5bGVzID0gdGhpcy5ncmlkMS5yb3dMaXN0LmZpcnN0LnN0eWxlQ2xhc3NlcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgICBnZXQgc3R5bGVDbGFzc2VzKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmRlZmF1bHRDc3NDbGFzc30gYCArIGAke3RoaXMucGFkZGluZ0luZGVudGF0aW9uQ3NzQ2xhc3N9LWAgKyB0aGlzLmdyb3VwUm93LmxldmVsICtcbiAgICAgICAgICAgICh0aGlzLmZvY3VzZWQgPyBgICR7dGhpcy5kZWZhdWx0Q3NzQ2xhc3N9LS1hY3RpdmVgIDogJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBwdWJsaWMgb25Gb2N1cygpIHtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICAgIHB1YmxpYyBvbkJsdXIoKSB7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZ3JvdXAgcm93LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QudG9nZ2xlKClcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKGtleT8pIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkRXhwYW5kID0gKCFrZXkgJiYgIXRoaXMuZXhwYW5kZWQpIHx8IChrZXkgJiYgIXRoaXMuZXhwYW5kZWQgJiYgKGtleSA9PT0gJ2Fycm93bGVmdCcgfHwga2V5ID09PSAnbGVmdCcpKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb2dnbGVTY3JvbGwoKTtcbiAgICAgICAgaWYgKCFzaG91bGRFeHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRWZXJ0aWNhbFNjcm9sbCgpLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzY3JvbGwnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uS2V5ZG93bihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgYWx0ID0gZXZlbnQuYWx0S2V5O1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNLZXlTdXBwb3J0ZWRJbkdyb3VwUm93KGtleSkgfHwgZXZlbnQuY3RybEtleSkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWFsdCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHsgY2VsbDogbnVsbCwgZ3JvdXBSb3c6IHRoaXMsIGV2ZW50OiBldmVudCwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQub25Gb2N1c0NoYW5nZS5lbWl0KGFyZ3MpO1xuICAgICAgICBpZiAoYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xJbmRleCA9IHRoaXMuX2dldFNlbGVjdGVkQ29sSW5kZXgoKSB8fCAwO1xuICAgICAgICBjb25zdCB2aXNpYmxlQ29sdW1uSW5kZXggPSB0aGlzLmdyaWQuY29sdW1uTGlzdC50b0FycmF5KClbY29sSW5kZXhdLnZpc2libGVJbmRleCAhPT0gLTEgP1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbkxpc3QudG9BcnJheSgpW2NvbEluZGV4XS52aXNpYmxlSW5kZXggOiAwO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyb3dkb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLm5hdmlnYXRlRG93bih0aGlzLm5hdGl2ZUVsZW1lbnQsIHRoaXMuaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhcnJvd3VwJzpcbiAgICAgICAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5uYXZpZ2F0ZVVwKHRoaXMubmF0aXZlRWxlbWVudCwgdGhpcy5pbmRleCwgdmlzaWJsZUNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhYic6XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLm5hdmlnYXRlVXAodGhpcy5uYXRpdmVFbGVtZW50LCB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLnVucGlubmVkQ29sdW1uc1t0aGlzLmdyaWQudW5waW5uZWRDb2x1bW5zLmxlbmd0aCAtIDFdLnZpc2libGVJbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRpb24ubmF2aWdhdGVEb3duKHRoaXMubmF0aXZlRWxlbWVudCwgdGhpcy5pbmRleCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYElneEdyaWRDb21wb25lbnRgIHRoZSBgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnRgIGJlbG9uZ3MgdG8uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC5ncmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBncmlkKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRBUEkuZ2V0KHRoaXMuZ3JpZElEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRhdGFUeXBlKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Q29sdW1uQnlOYW1lKHRoaXMuZ3JvdXBSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUpLmRhdGFUeXBlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldFNlbGVjdGVkQ29sSW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLnNlbGVjdGlvbi5maXJzdF9pdGVtKHRoaXMuZ3JpZElEICsgJy1jZWxsJyk7XG4gICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5jb2x1bW5JRDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNLZXlTdXBwb3J0ZWRJbkdyb3VwUm93KGtleSkge1xuICAgICAgICByZXR1cm4gWydkb3duJywgJ3VwJywgJ2xlZnQnLCAncmlnaHQnLCAnYXJyb3dkb3duJywgJ2Fycm93dXAnLCAnYXJyb3dsZWZ0JywgJ2Fycm93cmlnaHQnLFxuICAgICAgICAgICAgJ3RhYiddLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1RvZ2dsZUtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIFsnbGVmdCcsICdyaWdodCcsICdhcnJvd2xlZnQnLCAnYXJyb3dyaWdodCddLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgfVxuICAgIHByaXZhdGUgaGFuZGxlVG9nZ2xlU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLnJvd0xpc3QubGVuZ3RoID4gMCAmJiB0aGlzLmdyaWQucm93TGlzdC5sYXN0LmluZGV4ID09PVxuICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvck9mLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwUm93SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLm9uQ2h1bmtMb2FkXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93SW5kZXg9XCIke2dyb3VwUm93SW5kZXh9XCJdYCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgfVxufVxuIl19