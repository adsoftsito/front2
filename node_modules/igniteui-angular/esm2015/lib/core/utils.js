/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
export function cloneArray(array, deep) {
    const /** @type {?} */ arr = [];
    if (!array) {
        return arr;
    }
    let /** @type {?} */ i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
export function cloneHierarchicalArray(array, childDataKey) {
    const /** @type {?} */ result = [];
    if (!array) {
        return result;
    }
    for (const /** @type {?} */ item of array) {
        if (Array.isArray(item[childDataKey])) {
            const /** @type {?} */ clonedItem = cloneValue(item);
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            result.push(clonedItem);
        }
        else {
            result.push(item);
        }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
export function mergeObjects(obj1, obj2) {
    if (!isObject(obj1)) {
        throw new Error(`Cannot merge into ${obj1}. First param must be an object.`);
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    for (const /** @type {?} */ key of Object.keys(obj2)) {
        obj1[key] = cloneValue(obj2[key]);
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
export function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const /** @type {?} */ result = {};
        for (const /** @type {?} */ key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/** @enum {number} */
const KEYCODES = {
    ENTER: 13,
    SPACE: 32,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,
    F2: 113,
    TAB: 9,
};
export { KEYCODES };
/** @enum {string} */
const KEYS = {
    ENTER: 'Enter',
    SPACE: ' ',
    SPACE_IE: 'Spacebar',
    ESCAPE: 'Escape',
    ESCAPE_IE: 'Esc',
    LEFT_ARROW: 'ArrowLeft',
    UP_ARROW: 'ArrowUp',
    RIGHT_ARROW: 'ArrowRight',
    DOWN_ARROW: 'ArrowDown',
    F2: 'F2',
    TAB: 'Tab',
};
export { KEYS };
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
export function valToPxlsUsingRange(range, node) {
    let /** @type {?} */ overflow = null;
    if (isIE() || isEdge()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const /** @type {?} */ width = range.getBoundingClientRect().width;
    if (isIE() || isEdge()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 * @param {?} canvas2dCtx
 * @param {?} node
 * @return {?}
 */
export function valToPxlsUsingCanvas(canvas2dCtx, node) {
    const /** @type {?} */ s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 * @return {?}
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
export function isEdge() {
    const /** @type {?} */ edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
export function isFirefox() {
    const /** @type {?} */ firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
export function isNavigationKey(key) {
    return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
        'home', 'end', 'space', 'spacebar', ' '].indexOf(key) !== -1;
}
/**
 * @record
 */
export function CancelableEventArgs() { }
function CancelableEventArgs_tsickle_Closure_declarations() {
    /**
     * Provides the ability to cancel the event.
     * @type {?}
     */
    CancelableEventArgs.prototype.cancel;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUdBLE1BQU0scUJBQXFCLEtBQUssRUFBRSxJQUFjO0lBQzVDLHVCQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDZixFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDVCxNQUFNLENBQUMsR0FBRyxDQUFDO0tBQ2Q7SUFDRCxxQkFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUNyQixPQUFPLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDVCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuRDtJQUNELE1BQU0sQ0FBQyxHQUFHLENBQUM7Q0FDZDs7Ozs7Ozs7QUFNRCxNQUFNLGlDQUFpQyxLQUFZLEVBQUUsWUFBaUI7SUFDbEUsdUJBQU0sTUFBTSxHQUFVLEVBQUUsQ0FBQztJQUN6QixFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDVCxNQUFNLENBQUMsTUFBTSxDQUFDO0tBQ2pCO0lBRUQsR0FBRyxDQUFDLENBQUMsdUJBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDdkIsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsdUJBQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNwQyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsc0JBQXNCLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FB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LENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDdkQ7Ozs7O0FBSUQsTUFBTTtJQUNGLHVCQUFNLFdBQVcsR0FBRyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sQ0FBQyxXQUFXLENBQUM7Q0FDdEI7Ozs7O0FBS0QsTUFBTTtJQUNGLHVCQUFNLGNBQWMsR0FBRyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNFLE1BQU0sQ0FBQyxjQUFjLENBQUM7Q0FDekI7Ozs7OztBQUdELE1BQU0sMEJBQTBCLEdBQVc7SUFDdkMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFlBQVk7UUFDcEYsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUNwRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5LCBkZWVwPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBkZWVwID8gY2xvbmVWYWx1ZShhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtW2NoaWxkRGF0YUtleV0pKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRJdGVtID0gY2xvbmVWYWx1ZShpdGVtKTtcbiAgICAgICAgICAgIGNsb25lZEl0ZW1bY2hpbGREYXRhS2V5XSA9IGNsb25lSGllcmFyY2hpY2FsQXJyYXkoY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldLCBjaGlsZERhdGFLZXkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2xvbmVkSXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERlZXAgY2xvbmVzIGFsbCBmaXJzdCBsZXZlbCBrZXlzIG9mIE9iajIgYW5kIG1lcmdlcyB0aGVtIHRvIE9iajFcbiAqIEBwYXJhbSBvYmoxIE9iamVjdCB0byBtZXJnZSBpbnRvXG4gKiBAcGFyYW0gb2JqMiBPYmplY3QgdG8gbWVyZ2UgZnJvbVxuICogQHJldHVybnMgT2JqMSB3aXRoIG1lcmdlZCBjbG9uZWQga2V5cyBmcm9tIE9iajJcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxOiB7fSwgb2JqMjoge30pOiBhbnkge1xuICAgIGlmICghaXNPYmplY3Qob2JqMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWVyZ2UgaW50byAke29iajF9LiBGaXJzdCBwYXJhbSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iajIpKSB7XG4gICAgICAgIG9iajFba2V5XSA9IGNsb25lVmFsdWUob2JqMltrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqMTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGRlZXAgY2xvbmUgb2YgcHJvdmlkZWQgdmFsdWUuXG4gKiBTdXBwb3J0cyBwcmltaXRpdmUgdmFsdWVzLCBkYXRlcyBhbmQgb2JqZWN0cy5cbiAqIElmIHBhc3NlZCB2YWx1ZSBpcyBhcnJheSByZXR1cm5zIHNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY2xvbmVcbiAqIEByZXR1cm5zIERlZXAgY29weSBvZiBwcm92aWRlZCB2YWx1ZVxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlOiBhbnkpOiBhbnkge1xuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi52YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZVZhbHVlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHR3byBwYXNzZWQgYXJndW1lbnRzIGFyZSBlcXVhbFxuICogQ3VycmVudGx5IHN1cHBvcnRzIGRhdGUgb2JqZWN0c1xuICogQHBhcmFtIG9iajFcbiAqIEBwYXJhbSBvYmoyXG4gKiBAcmV0dXJuczogYGJvb2xlYW5gXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpOiBib29sZWFuIHtcbiAgICBpZiAoaXNEYXRlKG9iajEpICYmIGlzRGF0ZShvYmoyKSkge1xuICAgICAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZQ09ERVMge1xuICAgIEVOVEVSID0gMTMsXG4gICAgU1BBQ0UgPSAzMixcbiAgICBFU0NBUEUgPSAyNyxcbiAgICBMRUZUX0FSUk9XID0gMzcsXG4gICAgVVBfQVJST1cgPSAzOCxcbiAgICBSSUdIVF9BUlJPVyA9IDM5LFxuICAgIERPV05fQVJST1cgPSA0MCxcbiAgICBGMiA9IDExMyxcbiAgICBUQUIgPSA5XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEtFWVMge1xuICAgIEVOVEVSID0gJ0VudGVyJyxcbiAgICBTUEFDRSA9ICcgJyxcbiAgICBTUEFDRV9JRSA9ICdTcGFjZWJhcicsXG4gICAgRVNDQVBFID0gJ0VzY2FwZScsXG4gICAgRVNDQVBFX0lFID0gJ0VzYycsXG4gICAgTEVGVF9BUlJPVyA9ICdBcnJvd0xlZnQnLFxuICAgIFVQX0FSUk9XID0gJ0Fycm93VXAnLFxuICAgIFJJR0hUX0FSUk9XID0gJ0Fycm93UmlnaHQnLFxuICAgIERPV05fQVJST1cgPSAnQXJyb3dEb3duJyxcbiAgICBGMiA9ICdGMicsXG4gICAgVEFCID0gJ1RhYidcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgUmFuZ2VcbiogYGBgdHlwZXNjcmlwdFxuKiBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4qXG4qIGxldCBzaXplID0gdmFsVG9QeGxzVXNpbmdSYW5nZShyYW5nZSwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbFRvUHhsc1VzaW5nUmFuZ2UocmFuZ2U6IFJhbmdlLCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGxldCBvdmVyZmxvdyA9IG51bGw7XG4gICAgaWYgKGlzSUUoKSB8fCBpc0VkZ2UoKSkge1xuICAgICAgICBvdmVyZmxvdyA9IG5vZGUuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgY29uc3Qgd2lkdGggPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgIGlmIChpc0lFKCkgfHwgaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGhhY2sgLSBvdGhlcndpc2UgY29udGVudCB3b24ndCBiZSBtZWFzdXJlZCBjb3JyZWN0bHkgaW4gSUUvRWRnZVxuICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKkBoaWRkZW5cbiogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgQ2FudmFzXG4qIGBgYHR5cGVzY3JpcHRcbiogbGV0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4qIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbipcbiogbGV0IHNpemUgPSB2YWxUb1B4bHNVc2luZ0NhbnZhcyhjdHgsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxUb1B4bHNVc2luZ0NhbnZhcyhjYW52YXMyZEN0eDogYW55LCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBmb250IHRvIGdldCBjb3JyZWN0IHdpZHRoXG4gICAgY2FudmFzMmRDdHguZm9udCA9IHMuZm9udFNpemUgKyAnICcgKyBzLmZvbnRGYW1pbHk7XG5cbiAgICByZXR1cm4gY2FudmFzMmRDdHgubWVhc3VyZVRleHQobm9kZS50ZXh0Q29udGVudCkud2lkdGg7XG59XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJRSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignVHJpZGVudC8nKSA+IDA7XG59XG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFZGdlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVkZ2VCcm93c2VyID0gL0VkZ2VbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGVkZ2VCcm93c2VyO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZpcmVmb3hCcm93c2VyID0gL0ZpcmVmb3hbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGZpcmVmb3hCcm93c2VyO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmF2aWdhdGlvbktleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBbJ2Rvd24nLCAndXAnLCAnbGVmdCcsICdyaWdodCcsICdhcnJvd2Rvd24nLCAnYXJyb3d1cCcsICdhcnJvd2xlZnQnLCAnYXJyb3dyaWdodCcsXG4gICAgICAgICdob21lJywgJ2VuZCcsICdzcGFjZScsICdzcGFjZWJhcicsICcgJ10uaW5kZXhPZihrZXkpICE9PSAtMTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgYWJpbGl0eSB0byBjYW5jZWwgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cbiJdfQ==