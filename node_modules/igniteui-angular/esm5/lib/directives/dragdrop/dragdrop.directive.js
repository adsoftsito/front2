/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, Output, Renderer2, ChangeDetectorRef } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
/** @enum {number} */
var RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
export { RestrictDrag };
RestrictDrag[RestrictDrag.VERTICALLY] = "VERTICALLY";
RestrictDrag[RestrictDrag.HORIZONTALLY] = "HORIZONTALLY";
RestrictDrag[RestrictDrag.NONE] = "NONE";
var IgxDragCustomEventDetails = /** @class */ (function () {
    function IgxDragCustomEventDetails() {
    }
    return IgxDragCustomEventDetails;
}());
export { IgxDragCustomEventDetails };
function IgxDragCustomEventDetails_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.owner;
}
var IgxDropEnterEventArgs = /** @class */ (function () {
    function IgxDropEnterEventArgs() {
    }
    return IgxDropEnterEventArgs;
}());
export { IgxDropEnterEventArgs };
function IgxDropEnterEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.dragData;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.startX;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.startY;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.pageX;
    /** @type {?} */
    IgxDropEnterEventArgs.prototype.pageY;
}
var IgxDropLeaveEventArgs = /** @class */ (function () {
    function IgxDropLeaveEventArgs() {
    }
    return IgxDropLeaveEventArgs;
}());
export { IgxDropLeaveEventArgs };
function IgxDropLeaveEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.dragData;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.startX;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.startY;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.pageX;
    /** @type {?} */
    IgxDropLeaveEventArgs.prototype.pageY;
}
var IgxDropEventArgs = /** @class */ (function () {
    function IgxDropEventArgs() {
    }
    return IgxDropEventArgs;
}());
export { IgxDropEventArgs };
function IgxDropEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IgxDropEventArgs.prototype.owner;
    /** @type {?} */
    IgxDropEventArgs.prototype.drag;
    /** @type {?} */
    IgxDropEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragBaseEventArgs() { }
function IDragBaseEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IDragBaseEventArgs.prototype.originalEvent;
    /** @type {?} */
    IDragBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function IDragStartEventArgs() { }
function IDragStartEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IDragStartEventArgs.prototype.cancel;
}
var IgxDragDirective = /** @class */ (function () {
    function IgxDragDirective(cdr, element, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * An \@Input property that indicates when the drag should start
         * By default the drag starts after the draggable element is moved by 5px
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragTolerance = 5;
        /**
         * Sets a custom class that will be added to the `dragGhost` element.
         * ```html
         * <div igxDrag [ghostImageClass]="'dragGhost'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.ghostImageClass = '';
        /**
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.hideBaseOnDrag = false;
        /**
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         */
        this.returnMoveEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragClicked(){
         *      alert("The elemented has been clicked!");
         * }
         * ```
         */
        this.dragClicked = new EventEmitter();
        /**
         * @hidden
         */
        this.touch = 'none';
        /**
         * @hidden
         */
        this.transitionProperty = 'top, left';
        /**
         * @hidden
         */
        this.top1 = 0;
        /**
         * @hidden
         */
        this.left1 = 0;
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this._startX = 0;
        /**
         * @hidden
         */
        this._startY = 0;
        /**
         * @hidden
         */
        this._dragStarted = false;
        /**
         * @hidden
         */
        this._pointerDownId = null;
        /**
         * @hidden
         */
        this._clicked = false;
        /**
         * @hidden
         */
        this._lastDropArea = null;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        /**
         * @hidden
         */
        this._removeOnDestroy = true;
    }
    Object.defineProperty(IgxDragDirective.prototype, "visible", {
        get: /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibilty = this.myDrag.visible;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._visibility === 'visible';
        },
        set: /**
         * Sets the visibility of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         * @param {?} bVisible
         * @return {?}
         */
        function (bVisible) {
            this._visibility = bVisible ? 'visible' : 'hidden';
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "left", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this._dragGhost.style.left, 10);
        },
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this._dragGhost) {
                    _this._dragGhost.style.left = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "top", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this._dragGhost.style.top, 10);
        },
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this._dragGhost) {
                    _this._dragGhost.style.top = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
        get: /**
         * Returns if the browser supports pointer events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let pointerEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return typeof PointerEvent !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
        get: /**
         * Returns if the browser supports touch events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let touchEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return 'ontouchstart' in window;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            if (_this.pointerEventsEnabled) {
                fromEvent(_this.element.nativeElement, 'pointerdown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(_this.element.nativeElement, 'pointermove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(_this.element.nativeElement, 'pointerup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else if (_this.touchEventsEnabled) {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(_this.element.nativeElement, 'touchstart').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(_this.element.nativeElement, 'mousedown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
        if (this._dragGhost && this._removeOnDestroy) {
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
        }
    };
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerDown = /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    function (event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        // Take margins because getBoundingClientRect() doesn't include margins of the element
        var /** @type {?} */ marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        var /** @type {?} */ marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._dragOffsetX = (this._startX - this.element.nativeElement.getBoundingClientRect().left) + marginLeft;
        this._dragOffsetY = (this._startY - this.element.nativeElement.getBoundingClientRect().top) + marginTop;
        this._dragStartX = this._startX - this._dragOffsetX;
        this._dragStartY = this._startY - this._dragOffsetY;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until dragGhost is created.
        if (this.pointerEventsEnabled) {
            this.element.nativeElement.setPointerCapture(this._pointerDownId);
        }
        else {
            this.element.nativeElement.focus();
            event.preventDefault();
        }
    };
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerMove = /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._clicked) {
            var /** @type {?} */ dragStartArgs_1 = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            var /** @type {?} */ pageX = void 0, /** @type {?} */ pageY = void 0;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            var /** @type {?} */ totalMovedX = pageX - this._startX;
            var /** @type {?} */ totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                this.zone.run(function () {
                    _this.dragStart.emit(dragStartArgs_1);
                });
                if (!dragStartArgs_1.cancel) {
                    this._dragStarted = true;
                    // We moved enough so dragGhost can be rendered and actual dragging to start.
                    this.createDragGhost(event);
                }
                return;
            }
            else if (!this._dragStarted) {
                return;
            }
            this.left = this._dragStartX + totalMovedX;
            this.top = this._dragStartY + totalMovedY;
            this.dispatchDragEvents(pageX, pageY);
        }
    };
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerUp = /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatchind drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        var /** @type {?} */ eventArgs = {
            originalEvent: event,
            owner: this
        };
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                if (!this.animateOnRelease) {
                    this.onTransitionEnd(null);
                }
                // dragging ended over a drop area. Call this after transition because onDrop might remove the element.
                this.dispatchDropEvent(event.pageX, event.pageY);
                // else the drop directive needs to call the dropFinished() method so the animation can perform
            }
            else if (this.animateOnRelease &&
                (this.left !== Math.floor(this._dragStartX) || this.top !== Math.floor(this._dragStartY))) {
                // If the start positions are the same as the current the transition will not execute.
                // return the ghost to start position before removing it. See onTransitionEnd.
                this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
                this.left = this._dragStartX;
                this.top = this._dragStartY;
            }
            else {
                this.onTransitionEnd(null);
            }
            this.zone.run(function () {
                _this.dragEnd.emit(eventArgs);
            });
        }
        else {
            this.zone.run(function () {
                _this.dragClicked.emit(eventArgs);
            });
        }
    };
    /**
     * @hidden
     * Create dragGhost element - copy of the base element. Bind all needed events.
     * @param event Pointer event required when the dragGhost is being initialized.
     */
    /**
     * @hidden
     * Create dragGhost element - copy of the base element. Bind all needed events.
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @return {?}
     */
    IgxDragDirective.prototype.createDragGhost = /**
     * @hidden
     * Create dragGhost element - copy of the base element. Bind all needed events.
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @return {?}
     */
    function (event) {
        var _this = this;
        this._dragGhost = this.element.nativeElement.cloneNode(true);
        this._dragGhost.style.transitionDuration = '0.0s';
        this._dragGhost.style.position = 'absolute';
        this._dragGhost.style.top = this._dragStartY + 'px';
        this._dragGhost.style.left = this._dragStartX + 'px';
        if (this.ghostImageClass) {
            this.renderer.addClass(this._dragGhost, this.ghostImageClass);
        }
        document.body.appendChild(this._dragGhost);
        if (this.pointerEventsEnabled) {
            // The dragGhost takes control for moving and dragging after it has been shown.
            this._dragGhost.setPointerCapture(this._pointerDownId);
            this._dragGhost.addEventListener('pointermove', function (args) {
                _this.onPointerMove(args);
            });
            this._dragGhost.addEventListener('pointerup', function (args) {
                _this.onPointerUp(args);
            });
        }
        if (this.animateOnRelease) {
            // Transition animation when the dragGhost is released and it returns to it's original position.
            this._dragGhost.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
        }
        // Hide the base after the dragGhost is created, because otherwise the dragGhost will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDragEvents = /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        var /** @type {?} */ topDropArea;
        var /** @type {?} */ eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this
        };
        var /** @type {?} */ elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (var /** @type {?} */ i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' && elementsFromPoint[i] !== this._dragGhost) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', eventArgs);
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', eventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDropEvent = /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        var /** @type {?} */ eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    };
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    IgxDragDirective.prototype.updateDragRelativePos = /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    function () {
        if (!this._dragGhost) {
            return;
        }
        // Calculate the new dragGhost position to remain where the mouse is, so it doesn't jump
        var /** @type {?} */ totalDraggedX = this.left - this._dragStartX;
        var /** @type {?} */ totalDraggedY = this.top - this._dragStartY;
        var /** @type {?} */ newPosX = this.element.nativeElement.getBoundingClientRect().left;
        var /** @type {?} */ newPosY = this.element.nativeElement.getBoundingClientRect().top;
        var /** @type {?} */ diffStartX = this._dragStartX - newPosX;
        var /** @type {?} */ diffStartY = this._dragStartY - newPosY;
        this.top = newPosX + totalDraggedX - diffStartX;
        this.left = newPosY + totalDraggedY - diffStartY;
    };
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    IgxDragDirective.prototype.dropFinished = /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    function () {
        if (this.animateOnRelease && this._dragGhost) {
            this.updateDragRelativePos();
            // Return the dragged element to the start. See onTransitionEnd next.
            // Take margins becuase getBoundingClientRect() doesn't include margins
            var /** @type {?} */ marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
            var /** @type {?} */ marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
            var /** @type {?} */ newPosX = this.element.nativeElement.getBoundingClientRect().left;
            var /** @type {?} */ newPosY = this.element.nativeElement.getBoundingClientRect().top;
            this._dragGhost.style.transitionDuration = this.defaultReturnDuration;
            this.left = newPosX - marginLeft;
            this.top = newPosY - marginTop;
        }
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDragDirective.prototype.onTransitionEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._dragStarted && !this._clicked) {
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this._dragGhost.parentNode.removeChild(this._dragGhost);
            this._dragGhost = null;
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this._dragStarted = false;
            this.zone.run(function () {
                _this.returnMoveEnd.emit({
                    originalEvent: event,
                    owner: _this
                });
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.getElementsAtPoint = /**
     * @hidden
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint conider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        var /** @type {?} */ viewPortX = pageX - window.pageXOffset;
        var /** @type {?} */ viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            return document['msElementsFromPoint'](viewPortX, viewPortY);
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchEvent = /**
     * @hidden
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (target, eventName, eventArgs) {
        // This way is IE11 compatible.
        var /** @type {?} */ dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Othersie can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    };
    IgxDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrag]'
                },] },
    ];
    /** @nocollapse */
    IgxDragDirective.ctorParameters = function () { return [
        { type: ChangeDetectorRef, },
        { type: ElementRef, },
        { type: NgZone, },
        { type: Renderer2, },
    ]; };
    IgxDragDirective.propDecorators = {
        "data": [{ type: Input, args: ['igxDrag',] },],
        "dragTolerance": [{ type: Input },],
        "ghostImageClass": [{ type: Input },],
        "hideBaseOnDrag": [{ type: Input },],
        "animateOnRelease": [{ type: Input },],
        "dragStart": [{ type: Output },],
        "dragEnd": [{ type: Output },],
        "returnMoveEnd": [{ type: Output },],
        "dragClicked": [{ type: Output },],
        "touch": [{ type: HostBinding, args: ['style.touchAction',] },],
        "transitionProperty": [{ type: HostBinding, args: ['style.transitionProperty',] },],
        "top1": [{ type: HostBinding, args: ['style.top.px',] },],
        "left1": [{ type: HostBinding, args: ['style.left.px',] },],
        "_visibility": [{ type: HostBinding, args: ['style.visibility',] },],
    };
    return IgxDragDirective;
}());
export { IgxDragDirective };
function IgxDragDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDragDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDragDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxDragDirective.propDecorators;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.data;
    /**
     * An \@Input property that indicates when the drag should start
     * By default the drag starts after the draggable element is moved by 5px
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragTolerance;
    /**
     * Sets a custom class that will be added to the `dragGhost` element.
     * ```html
     * <div igxDrag [ghostImageClass]="'dragGhost'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.ghostImageClass;
    /**
     * An \@Input property that hides the draggable element.
     * By default it's set to false.
     * ```html
     * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.hideBaseOnDrag;
    /**
     * An \@Input property that enables/disables the draggable element animation
     * when the element is released.
     * By default it's set to false.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.animateOnRelease;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragStart;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragEnd;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.returnMoveEnd;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public dragClicked(){
     *      alert("The elemented has been clicked!");
     * }
     * ```
     * @type {?}
     */
    IgxDragDirective.prototype.dragClicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.touch;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.transitionProperty;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.top1;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.left1;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._visibility;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.defaultReturnDuration;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._startX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._startY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragGhost;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStarted;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragOffsetX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragOffsetY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStartX;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._dragStartY;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._pointerDownId;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._clicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._lastDropArea;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._destroy;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._removeOnDestroy;
    /** @type {?} */
    IgxDragDirective.prototype.cdr;
    /** @type {?} */
    IgxDragDirective.prototype.element;
    /** @type {?} */
    IgxDragDirective.prototype.zone;
    /** @type {?} */
    IgxDragDirective.prototype.renderer;
}
var IgxDropDirective = /** @class */ (function () {
    function IgxDropDirective(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable elemente has entered the chip area!");
         * }
         * ```
         */
        this.onEnter = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable elemente has left the chip area!");
         * }
         * ```
         */
        this.onLeave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable elemente has been dropped in the chip area!");
         * }
         * ```
         */
        this.onDrop = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
    }
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(_this._destroy))
                .subscribe(function (res) { return _this.onDragEnter(/** @type {?} */ (res)); });
            fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
            fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
        });
    };
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragOver = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = true;
        var /** @type {?} */ eventArgs = {
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY
        };
        this._zone.run(function () {
            _this.onEnter.emit(eventArgs);
        });
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragLeave = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = false;
        var /** @type {?} */ eventArgs = {
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY
        };
        this._zone.run(function () {
            _this.onLeave.emit();
        });
    };
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragDrop = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        var /** @type {?} */ args = {
            owner: this,
            drag: event.detail.owner,
            cancel: false
        };
        this._zone.run(function () {
            _this.onDrop.emit(args);
        });
        if (!args.cancel) {
            // To do for generic scenario
            this._renderer.removeChild(event.detail.owner.element.nativeElement.parentNode, event.detail.owner.element.nativeElement);
            this._renderer.appendChild(this.element.nativeElement, event.detail.owner.element.nativeElement);
            setTimeout(function () {
                event.detail.owner.dropFinished();
            }, 0);
        }
    };
    IgxDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrop]'
                },] },
    ];
    /** @nocollapse */
    IgxDropDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
        { type: NgZone, },
    ]; };
    IgxDropDirective.propDecorators = {
        "data": [{ type: Input, args: ['igxDrop',] },],
        "onEnter": [{ type: Output },],
        "onLeave": [{ type: Output },],
        "onDrop": [{ type: Output },],
        "droppable": [{ type: HostBinding, args: ['attr.droppable',] },],
        "dragover": [{ type: HostBinding, args: ['class.dragOver',] },],
        "onDragDrop": [{ type: HostListener, args: ['igxDrop', ['$event'],] },],
    };
    return IgxDropDirective;
}());
export { IgxDropDirective };
function IgxDropDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDropDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDropDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxDropDirective.propDecorators;
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.data;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable elemente has entered the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onEnter;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable elemente has left the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onLeave;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable elemente has been dropped in the chip area!");
     * }
     * ```
     * @type {?}
     */
    IgxDropDirective.prototype.onDrop;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.droppable;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.dragover;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype._destroy;
    /** @type {?} */
    IgxDropDirective.prototype.element;
    /** @type {?} */
    IgxDropDirective.prototype._renderer;
    /** @type {?} */
    IgxDropDirective.prototype._zone;
}
/**
 * The IgxDragDropModule provides the {\@link IgxDragDirective}, {\@link IgxDropDirective} inside your application.
 */
var IgxDragDropModule = /** @class */ (function () {
    function IgxDragDropModule() {
    }
    IgxDragDropModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDragDirective, IgxDropDirective],
                    exports: [IgxDragDirective, IgxDropDirective]
                },] },
    ];
    return IgxDragDropModule;
}());
export { IgxDragDropModule };
function IgxDragDropModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxDragDropModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxDragDropModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2Ryb3AuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kaXJlY3RpdmVzL2RyYWdkcm9wL2RyYWdkcm9wLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBRVosS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBR04sTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdFLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7O0FBUXJELElBQUE7OztvQ0F6QkE7SUErQkMsQ0FBQTtBQU5ELHFDQU1DOzs7Ozs7Ozs7Ozs7O0FBRUQsSUFBQTs7O2dDQWpDQTtJQXlDQyxDQUFBO0FBUkQsaUNBUUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsSUFBQTs7O2dDQTNDQTtJQW1EQyxDQUFBO0FBUkQsaUNBUUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsSUFBQTs7OzJCQXJEQTtJQXlEQyxDQUFBO0FBSkQsNEJBSUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpVUcsMEJBQW1CLEdBQXNCLEVBQVMsT0FBbUIsRUFBUyxJQUFZLEVBQVMsUUFBbUI7UUFBbkcsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFBUyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFTLGFBQVEsR0FBUixRQUFRLENBQVc7Ozs7Ozs7Ozs7NkJBL1IvRixDQUFDOzs7Ozs7Ozs7K0JBV0MsRUFBRTs7Ozs7Ozs7Ozs4QkFZSCxLQUFLOzs7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RUFBRSxnQkFBZ0IsQ0FBQztpQkFDaEQ7OzRCQXA3QkQ7O1NBcTdCYSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE5nWm9uZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCB0aHJvdHRsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGVudW0gUmVzdHJpY3REcmFnIHtcbiAgICBWRVJUSUNBTExZLFxuICAgIEhPUklaT05UQUxMWSxcbiAgICBOT05FXG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzIHtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRW50ZXJFdmVudEFyZ3Mge1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgZHJhZ0RhdGE6IGFueTtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wTGVhdmVFdmVudEFyZ3Mge1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgZHJhZ0RhdGE6IGFueTtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRXZlbnRBcmdzIHtcbiAgICBvd25lcjogSWd4RHJvcERpcmVjdGl2ZTtcbiAgICBkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0Jhc2VFdmVudEFyZ3Mge1xuICAgIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ1N0YXJ0RXZlbnRBcmdzIGV4dGVuZHMgSURyYWdCYXNlRXZlbnRBcmdzIHtcbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERyYWddJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEcmFnRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcmFnYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcmFnXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4RHJhZycpXG4gICAgcHVibGljIGRhdGE6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSBkcmFnIHNob3VsZCBzdGFydFxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGRyYWcgc3RhcnRzIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBieSA1cHhcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnVG9sZXJhbmNlXT1cIjEwMFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ1RvbGVyYW5jZSA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGNsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGRyYWdHaG9zdGAgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdEltYWdlQ2xhc3NdPVwiJ2RyYWdHaG9zdCdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdob3N0SW1hZ2VDbGFzcyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaGlkZXMgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ1RvbGVyYW5jZV09XCIxMDBcIiBbaGlkZUJhc2VPbkRyYWddPVwiJ3RydWUnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoaWRlQmFzZU9uRHJhZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZW5hYmxlcy9kaXNhYmxlcyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgYW5pbWF0aW9uXG4gICAgICogd2hlbiB0aGUgZWxlbWVudCBpcyByZWxlYXNlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3Mgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2FuaW1hdGVPblJlbGVhc2VdPVwiJ3RydWUnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBhbmltYXRlT25SZWxlYXNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIiAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnU3RhcnRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIiAoZHJhZ0VuZCk9XCJvbkRyYWdFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQgYW5kIGFmdGVyIGl0cyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2FuaW1hdGVPblJlbGVhc2VdPVwiJ3RydWUnXCIgKHJldHVybk1vdmVFbmQpPVwib25Nb3ZlRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25Nb3ZlRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBtb3ZlIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXR1cm5Nb3ZlRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFthbmltYXRlT25SZWxlYXNlXT1cIid0cnVlJ1wiIChkcmFnQ2xpY2tlZCk9XCJkcmFnQ2xpY2tlZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdDbGlja2VkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBlbGVtZW50ZWQgaGFzIGJlZW4gY2xpY2tlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnQ2xpY2tlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudG91Y2hBY3Rpb24nKVxuICAgIHB1YmxpYyB0b3VjaCA9ICdub25lJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eScpXG4gICAgcHVibGljIHRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd0b3AsIGxlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudG9wLnB4JylcbiAgICBwdWJsaWMgdG9wMSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5sZWZ0LnB4JylcbiAgICBwdWJsaWMgbGVmdDEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudmlzaWJpbGl0eScpXG4gICAgcHVibGljIF92aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIHRoaXMubXlEcmFnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB2aXNpYmxlKGJWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSBiVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBkcmFnVmlzaWJpbHR5ID0gdGhpcy5teURyYWcudmlzaWJsZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGxlZnQodmFsOiBudW1iZXIpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnR2hvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc3R5bGUubGVmdCA9IHZhbCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9kcmFnR2hvc3Quc3R5bGUubGVmdCwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHRvcCh2YWw6IG51bWJlcikge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdHaG9zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50b3AgPSB2YWwgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9kcmFnR2hvc3Quc3R5bGUudG9wLCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIm15RHJhZ1wiICx7cmVhZDogSWd4RHJhZ0RpcmVjdGl2ZX0pXG4gICAgICogcHVibGljIG15RHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IHBvaW50ZXJFdmVudHMgPSB0aGlzLm15RHJhZy5wb2ludGVyRXZlbnRzRW5hYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBwb2ludGVyRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBQb2ludGVyRXZlbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgdG91Y2hFdmVudHMgPSB0aGlzLm15RHJhZy5wb2ludGVyRXZlbnRzRW5hYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3VjaEV2ZW50c0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0UmV0dXJuRHVyYXRpb24gPSAnMC41cyc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdGFydFggPSAwO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnR2hvc3Q7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnT2Zmc2V0WDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnT2Zmc2V0WTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kcmFnU3RhcnRYO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydFk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcG9pbnRlckRvd25JZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jbGlja2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbGFzdERyb3BBcmVhID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcmVtb3ZlT25EZXN0cm95ID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLCBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIHpvbmU6IE5nWm9uZSwgcHVibGljIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJkb3duJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdwb2ludGVybW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJ1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLiBVc2UgdGhlbiBtb3VzZSBldmVudHMuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndG91Y2hzdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2htb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2hlbmQnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuIFVzZSB0aGVuIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNlbW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNldXAnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5jb21wbGV0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kcmFnR2hvc3QgJiYgdGhpcy5fcmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9kcmFnR2hvc3QpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgYm91bmQgdG8gdGhlIFBvaW50ZXJEb3duIGV2ZW50IG9mIHRoZSBiYXNlIGVsZW1lbnQgaWd4RHJhZyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlckRvd24gZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBkb2Vzbid0IGluY2x1ZGUgbWFyZ2lucyBvZiB0aGUgZWxlbWVudFxuICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuXG4gICAgICAgIHRoaXMuX2RyYWdPZmZzZXRYID0gKHRoaXMuX3N0YXJ0WCAtIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICsgbWFyZ2luTGVmdDtcbiAgICAgICAgdGhpcy5fZHJhZ09mZnNldFkgPSAodGhpcy5fc3RhcnRZIC0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSArIG1hcmdpblRvcDtcbiAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0WCA9IHRoaXMuX3N0YXJ0WCAtIHRoaXMuX2RyYWdPZmZzZXRYO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRZID0gdGhpcy5fc3RhcnRZIC0gdGhpcy5fZHJhZ09mZnNldFk7XG5cbiAgICAgICAgLy8gU2V0IHBvaW50ZXIgY2FwdHVyZSBzbyB3ZSBkZXRlY3QgcG9pbnRlcm1vdmUgZXZlbiBpZiBtb3VzZSBpcyBvdXQgb2YgYm91bmRzIHVudGlsIGRyYWdHaG9zdCBpcyBjcmVhdGVkLlxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUodGhpcy5fcG9pbnRlckRvd25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBQZXJmbW9ybSBkcmFnIG1vdmUgbG9naWMgd2hlbiBkcmFnZ2luZyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzIGlmIHRoZXJlIGlzIGlneERyb3AgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBkcmFnR2hvc3QgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIHRoZSBkcmFnR2hvc3QuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJNb3ZlIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdTdGFydEFyZ3M6IElEcmFnU3RhcnRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwYWdlWCwgcGFnZVk7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmaXJzdCBmb3IgcG9pbnRlciBldmVudHMgb3Igbm9uIHRvdWNoLCBiZWNhdXNlIHdlIGNhbiBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMgYXQgb25jZS5cbiAgICAgICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcGFnZVggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIHRvdWNoIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlZFggPSBwYWdlWCAtIHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTW92ZWRZID0gcGFnZVkgLSB0aGlzLl9zdGFydFk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYWdTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKHRvdGFsTW92ZWRYKSA+IHRoaXMuZHJhZ1RvbGVyYW5jZSB8fCBNYXRoLmFicyh0b3RhbE1vdmVkWSkgPiB0aGlzLmRyYWdUb2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0LmVtaXQoZHJhZ1N0YXJ0QXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTdGFydEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbW92ZWQgZW5vdWdoIHNvIGRyYWdHaG9zdCBjYW4gYmUgcmVuZGVyZWQgYW5kIGFjdHVhbCBkcmFnZ2luZyB0byBzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEcmFnR2hvc3QoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fZHJhZ1N0YXJ0WCArIHRvdGFsTW92ZWRYO1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLl9kcmFnU3RhcnRZICsgdG90YWxNb3ZlZFk7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hEcmFnRXZlbnRzKHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIGVuZCBsb2dpYyB3aGVuIHJlbGVhc2luZyB0aGUgZHJhZ0dob3N0IGFuZCBkaXNwYXRjaGluZCBkcm9wIGV2ZW50IGlmIGlneERyb3AgaXMgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBkcmFnR2hvc3QgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIHRoZSBkcmFnR2hvc3QuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJVcCBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0RHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhICE9PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbmltYXRlT25SZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRyYWdnaW5nIGVuZGVkIG92ZXIgYSBkcm9wIGFyZWEuIENhbGwgdGhpcyBhZnRlciB0cmFuc2l0aW9uIGJlY2F1c2Ugb25Ecm9wIG1pZ2h0IHJlbW92ZSB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRHJvcEV2ZW50KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB0aGUgZHJvcCBkaXJlY3RpdmUgbmVlZHMgdG8gY2FsbCB0aGUgZHJvcEZpbmlzaGVkKCkgbWV0aG9kIHNvIHRoZSBhbmltYXRpb24gY2FuIHBlcmZvcm1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmltYXRlT25SZWxlYXNlICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmxlZnQgIT09IE1hdGguZmxvb3IodGhpcy5fZHJhZ1N0YXJ0WCkgfHwgdGhpcy50b3AgIT09IE1hdGguZmxvb3IodGhpcy5fZHJhZ1N0YXJ0WSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IHBvc2l0aW9ucyBhcmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdGhlIHRyYW5zaXRpb24gd2lsbCBub3QgZXhlY3V0ZS5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGdob3N0IHRvIHN0YXJ0IHBvc2l0aW9uIGJlZm9yZSByZW1vdmluZyBpdC4gU2VlIG9uVHJhbnNpdGlvbkVuZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3Quc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fZHJhZ1N0YXJ0WDtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuX2RyYWdTdGFydFk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdDbGlja2VkLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENyZWF0ZSBkcmFnR2hvc3QgZWxlbWVudCAtIGNvcHkgb2YgdGhlIGJhc2UgZWxlbWVudC4gQmluZCBhbGwgbmVlZGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlciBldmVudCByZXF1aXJlZCB3aGVuIHRoZSBkcmFnR2hvc3QgaXMgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZURyYWdHaG9zdChldmVudCkge1xuICAgICAgICB0aGlzLl9kcmFnR2hvc3QgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zdHlsZS50b3AgPSB0aGlzLl9kcmFnU3RhcnRZICsgJ3B4JztcbiAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLmxlZnQgPSB0aGlzLl9kcmFnU3RhcnRYICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5naG9zdEltYWdlQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZHJhZ0dob3N0LCB0aGlzLmdob3N0SW1hZ2VDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2RyYWdHaG9zdCk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkcmFnR2hvc3QgdGFrZXMgY29udHJvbCBmb3IgbW92aW5nIGFuZCBkcmFnZ2luZyBhZnRlciBpdCBoYXMgYmVlbiBzaG93bi5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5zZXRQb2ludGVyQ2FwdHVyZSh0aGlzLl9wb2ludGVyRG93bklkKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnR2hvc3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlclVwKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRlT25SZWxlYXNlKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIHRoZSBkcmFnR2hvc3QgaXMgcmVsZWFzZWQgYW5kIGl0IHJldHVybnMgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlkZSB0aGUgYmFzZSBhZnRlciB0aGUgZHJhZ0dob3N0IGlzIGNyZWF0ZWQsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBkcmFnR2hvc3Qgd2lsbCBiZSBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKHRoaXMuaGlkZUJhc2VPbkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIERpc3BhdGNoIGN1c3RvbSBpZ3hEcmFnRW50ZXIvaWd4RHJhZ0xlYXZlIGV2ZW50cyBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gYW5kIGlmIGRyb3AgYXJlYSBpcyB1bmRlci5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcmFnRXZlbnRzKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHRvcERyb3BBcmVhO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMgPSB7XG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbGVtZW50c0Zyb21Qb2ludCA9IHRoaXMuZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHNGcm9tUG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50c0Zyb21Qb2ludFtpXS5nZXRBdHRyaWJ1dGUoJ2Ryb3BwYWJsZScpID09PSAndHJ1ZScgJiYgZWxlbWVudHNGcm9tUG9pbnRbaV0gIT09IHRoaXMuX2RyYWdHaG9zdCkge1xuICAgICAgICAgICAgICAgIHRvcERyb3BBcmVhID0gZWxlbWVudHNGcm9tUG9pbnRbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRHJvcEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0b3BEcm9wQXJlYSwgJ2lneERyYWdPdmVyJywgZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSAmJlxuICAgICAgICAgICAgKCF0aGlzLl9sYXN0RHJvcEFyZWEgfHwgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRvcERyb3BBcmVhKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0RHJvcEFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gdG9wRHJvcEFyZWE7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0VudGVyJywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdG9wRHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3REcm9wQXJlYSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyb3AgZXZlbnQgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGlmIHRoZXJlIGlzIGxhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIExhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIGlzIHVwZGF0ZWQgaW4gQGRpc3BhdGNoRHJhZ0V2ZW50cyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJvcEV2ZW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyb3AnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVXBkYXRlIHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVEcmFnUmVsYXRpdmVQb3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBkcmFnR2hvc3QgcG9zaXRpb24gdG8gcmVtYWluIHdoZXJlIHRoZSBtb3VzZSBpcywgc28gaXQgZG9lc24ndCBqdW1wXG4gICAgICAgIGNvbnN0IHRvdGFsRHJhZ2dlZFggPSB0aGlzLmxlZnQgLSB0aGlzLl9kcmFnU3RhcnRYO1xuICAgICAgICBjb25zdCB0b3RhbERyYWdnZWRZID0gdGhpcy50b3AgLSB0aGlzLl9kcmFnU3RhcnRZO1xuICAgICAgICBjb25zdCBuZXdQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY29uc3QgbmV3UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgY29uc3QgZGlmZlN0YXJ0WCA9IHRoaXMuX2RyYWdTdGFydFggLSBuZXdQb3NYO1xuICAgICAgICBjb25zdCBkaWZmU3RhcnRZID0gdGhpcy5fZHJhZ1N0YXJ0WSAtIG5ld1Bvc1k7XG4gICAgICAgIHRoaXMudG9wID0gbmV3UG9zWCArIHRvdGFsRHJhZ2dlZFggLSBkaWZmU3RhcnRYO1xuICAgICAgICB0aGlzLmxlZnQgPSBuZXdQb3NZICsgdG90YWxEcmFnZ2VkWSAtIGRpZmZTdGFydFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mb3JtcyB0aGUgYGlneERyYWdgIGRpcmVjdGl2ZSB0aGF0IGl0IGhhcyBiZWVuIGRyb3BwZWQvcmVsZWFzZWQuXG4gICAgICogVGhpcyBzaG91bGQgdXN1bGx5IGJlIGNhbGxlZCB3aGVuIGBhbmltYXRlT25SZWxlYXNlYCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIFdoZW4gY2FuY2VsaW5nIG9yIGRlZmluaW5nIGN1c3RvbSBkcm9wIGxvZ2ljIHRoaXMgdGVsbHMgdGhlIGlneERyYWcgdG8gdXBkYXRlIGl0J3MgcG9zaXRpb25zIGFuZFxuICAgICAqIGFuaW1hdGUgY29ycmVjdGx5IHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyb3BFbGVtKGV2ZW50KSB7XG4gICAgICogICAgIC8vIEZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBpZ3hEcm9wIGRpcmVjdGl2ZSBldmVudCBgb25Ecm9wYFxuICAgICAqICAgICAvLyBUaGlzIGNhbmNlbHMgdGhlIGRlZmF1bHQgZHJvcCBsb2dpYyBvZiB0aGUgYGlneERyb3BgXG4gICAgICogICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogICAgIGV2ZW50LmRyYWcuZHJvcEZpbmlzaGVkKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBkcm9wRmluaXNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UgJiYgdGhpcy5fZHJhZ0dob3N0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdSZWxhdGl2ZVBvcygpO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGRyYWdnZWQgZWxlbWVudCB0byB0aGUgc3RhcnQuIFNlZSBvblRyYW5zaXRpb25FbmQgbmV4dC5cbiAgICAgICAgICAgIC8vIFRha2UgbWFyZ2lucyBiZWN1YXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGRvZXNuJ3QgaW5jbHVkZSBtYXJnaW5zXG4gICAgICAgICAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudClbJ21hcmdpbi1sZWZ0J10sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Bvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgbmV3UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbmV3UG9zWCAtIG1hcmdpbkxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ld1Bvc1kgLSBtYXJnaW5Ub3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZHJhZ1N0YXJ0ZWQgJiYgIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhZ0dob3N0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZHJhZ0dob3N0KTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdHaG9zdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybk1vdmVFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnRzQXRQb2ludChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgICAgIC8vIGNvcnJlY3QgdGhlIGNvb3JkaW5hdGVzIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlXG4gICAgICAgIC8vIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50IGNvbmlkZXIgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gICAgICAgIC8vIHdpbmRvdy5wYWdlWE9mZnNldCA9PSB3aW5kb3cuc2Nyb2xsWDsgLy8gYWx3YXlzIHRydWVcbiAgICAgICAgLy8gdXNpbmcgd2luZG93LnBhZ2VYT2Zmc2V0IGZvciBJRTkgY29tcGF0aWJpbGl0eVxuICAgICAgICBjb25zdCB2aWV3UG9ydFggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIGlmIChkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKSB7XG4gICAgICAgICAgICAvLyBFZGdlIGFuZCBJRSBzcGVjaWFsIHNub3dmbGFrZXNcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyIGJyb3dzZXJzIGxpa2UgQ2hyb21lLCBGaXJlZm94LCBPcGVyYVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50TmFtZTogc3RyaW5nLCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMpIHtcbiAgICAgICAgLy8gVGhpcyB3YXkgaXMgSUUxMSBjb21wYXRpYmxlLlxuICAgICAgICBjb25zdCBkcmFnTGVhdmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICBkcmFnTGVhdmVFdmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCBmYWxzZSwgZmFsc2UsIGV2ZW50QXJncyk7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGRyYWdMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gT3RoZXJzaWUgY2FuIGJlIHVzZWQgYHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIGV2ZW50QXJncykpO2BcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERyb3BdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJvcGAgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcm9wYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcm9wXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4RHJvcCcpXG4gICAgcHVibGljIGRhdGE6IGFueTtcblxuICAgIC8qKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgZW50ZXJzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChvbkVudGVyKT1cImRyYWdFbnRlcigpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdFbnRlcigpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnRlIGhhcyBlbnRlcmVkIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25FbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4RHJvcEVudGVyRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBsZWF2ZXMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKG9uTGVhdmUpPVwiZHJhZ0xlYXZlKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0xlYXZlKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudGUgaGFzIGxlZnQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hEcm9wTGVhdmVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQgaW4gdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogU2luY2UgdGhlIGBpZ3hEcm9wYCBoYXMgZGVmYXVsdCBsb2dpYyB0aGF0IGFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCBhcyBhIGNoaWxkLCBpdCBjYW4gYmUgY2FuY2VsZWQgaGVyZS5cbiAgICAgKiBUbyBjYW5jZWwgdGhlIGRlZmF1bHQgbG9naWMgdGhlIGBjYW5jZWxgIHByb3BlcnR5IG9mIHRoZSBldmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAob25Ecm9wKT1cImRyYWdEcm9wKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0Ryb3AoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50ZSBoYXMgYmVlbiBkcm9wcGVkIGluIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Ecm9wID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hEcm9wRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5kcm9wcGFibGUnKVxuICAgIHB1YmxpYyBkcm9wcGFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZHJhZ092ZXInKVxuICAgIHB1YmxpYyBkcmFnb3ZlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0VudGVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0VudGVyKHJlcyBhcyBDdXN0b21FdmVudDxJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzPikpO1xuXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdpZ3hEcmFnTGVhdmUnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnTGVhdmUocmVzKSk7XG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdpZ3hEcmFnT3ZlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdPdmVyKHJlcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdPdmVyKGV2ZW50KSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnRW50ZXIoZXZlbnQ6IEN1c3RvbUV2ZW50PElneERyYWdDdXN0b21FdmVudERldGFpbHM+KSB7XG4gICAgICAgIHRoaXMuZHJhZ292ZXIgPSB0cnVlO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyb3BFbnRlckV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgZHJhZzogZXZlbnQuZGV0YWlsLm93bmVyLFxuICAgICAgICAgICAgZHJhZ0RhdGE6IGV2ZW50LmRldGFpbC5vd25lci5kYXRhLFxuICAgICAgICAgICAgc3RhcnRYOiBldmVudC5kZXRhaWwuc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiBldmVudC5kZXRhaWwuc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50LmRldGFpbC5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudC5kZXRhaWwucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVudGVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdMZWF2ZShldmVudCkge1xuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSWd4RHJvcExlYXZlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTGVhdmUuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignaWd4RHJvcCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uRHJhZ0Ryb3AoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgYXJnczogSWd4RHJvcEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgZHJhZzogZXZlbnQuZGV0YWlsLm93bmVyLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRHJvcC5lbWl0KGFyZ3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAvLyBUbyBkbyBmb3IgZ2VuZXJpYyBzY2VuYXJpb1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2hpbGQoZXZlbnQuZGV0YWlsLm93bmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLCBldmVudC5kZXRhaWwub3duZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBldmVudC5kZXRhaWwub3duZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLm93bmVyLmRyb3BGaW5pc2hlZCgpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBUaGUgSWd4RHJhZ0Ryb3BNb2R1bGUgcHJvdmlkZXMgdGhlIHtAbGluayBJZ3hEcmFnRGlyZWN0aXZlfSwge0BsaW5rIElneERyb3BEaXJlY3RpdmV9IGluc2lkZSB5b3VyIGFwcGxpY2F0aW9uLlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW0lneERyYWdEaXJlY3RpdmUsIElneERyb3BEaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hEcmFnRGlyZWN0aXZlLCBJZ3hEcm9wRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hEcmFnRHJvcE1vZHVsZSB7IH1cbiJdfQ==