/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
var /** @type {?} */ MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var /** @type {?} */ FEBRUARY = 1;
/**
 * @param {?=} start
 * @param {?=} stop
 * @param {?=} step
 * @return {?}
 */
export function range(start, stop, step) {
    if (start === void 0) { start = 0; }
    if (step === void 0) { step = 1; }
    var /** @type {?} */ res = [];
    var /** @type {?} */ cur = (stop === undefined) ? 0 : start;
    var /** @type {?} */ max = (stop === undefined) ? start : stop;
    for (var /** @type {?} */ i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {?} year
 * @return {?}
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
/**
 * @param {?} year
 * @param {?} month
 * @param {?} day
 * @return {?}
 */
export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {?} year
 * @param {?} month
 * @return {?}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    var /** @type {?} */ day = weekDay(year, month, 1);
    var /** @type {?} */ nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
/**
 * @record
 */
export function ICalendarDate() { }
function ICalendarDate_tsickle_Closure_declarations() {
    /** @type {?} */
    ICalendarDate.prototype.date;
    /** @type {?} */
    ICalendarDate.prototype.isCurrentMonth;
    /** @type {?} */
    ICalendarDate.prototype.isPrevMonth;
    /** @type {?} */
    ICalendarDate.prototype.isNextMonth;
}
/**
 * @record
 */
export function IFormattedParts() { }
function IFormattedParts_tsickle_Closure_declarations() {
    /** @type {?} */
    IFormattedParts.prototype.value;
    /** @type {?|undefined} */
    IFormattedParts.prototype.literal;
    /** @type {?} */
    IFormattedParts.prototype.combined;
}
/** @enum {number} */
var WEEKDAYS = {
    SUNDAY: 0,
    MONDAY: 1,
    TUESDAY: 2,
    WEDNESDAY: 3,
    THURSDAY: 4,
    FRIDAY: 5,
    SATURDAY: 6,
};
export { WEEKDAYS };
WEEKDAYS[WEEKDAYS.SUNDAY] = "SUNDAY";
WEEKDAYS[WEEKDAYS.MONDAY] = "MONDAY";
WEEKDAYS[WEEKDAYS.TUESDAY] = "TUESDAY";
WEEKDAYS[WEEKDAYS.WEDNESDAY] = "WEDNESDAY";
WEEKDAYS[WEEKDAYS.THURSDAY] = "THURSDAY";
WEEKDAYS[WEEKDAYS.FRIDAY] = "FRIDAY";
WEEKDAYS[WEEKDAYS.SATURDAY] = "SATURDAY";
var Calendar = /** @class */ (function () {
    function Calendar(firstWeekDay) {
        if (firstWeekDay === void 0) { firstWeekDay = WEEKDAYS.SUNDAY; }
        this._firstWeekDay = firstWeekDay;
    }
    Object.defineProperty(Calendar.prototype, "firstWeekDay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._firstWeekDay % 7;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._firstWeekDay = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * \@memberof Calendar
     * @return {?}
     *
     */
    Calendar.prototype.weekdays = /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * \@memberof Calendar
     * @return {?}
     *
     */
    function () {
        var /** @type {?} */ res = [];
        try {
            for (var _a = tslib_1.__values(range(this.firstWeekDay, this.firstWeekDay + 7)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var i = _b.value;
                res.push(i % 7);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return res;
        var e_1, _c;
    };
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    Calendar.prototype.monthdates = /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    function (year, month, extraWeek) {
        if (extraWeek === void 0) { extraWeek = false; }
        var /** @type {?} */ date = new Date(year, month, 1);
        var /** @type {?} */ days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        var /** @type {?} */ res = [];
        var /** @type {?} */ value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    try {
                        for (var _a = tslib_1.__values(range(0, 7)), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var i = _b.value;
                            value = this.generateICalendarDate(date, year, month);
                            res.push(value);
                            date = this.timedelta(date, 'day', 1);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                break;
            }
        }
        return res;
        var e_2, _c;
    };
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    Calendar.prototype.monthdatescalendar = /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    function (year, month, extraWeek) {
        if (extraWeek === void 0) { extraWeek = false; }
        var /** @type {?} */ dates = this.monthdates(year, month, extraWeek);
        var /** @type {?} */ res = [];
        try {
            for (var _a = tslib_1.__values(range(0, dates.length, 7)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var i = _b.value;
                res.push(dates.slice(i, i + 7));
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
        var e_3, _c;
    };
    /**
     * @param {?} date
     * @param {?} interval
     * @param {?} units
     * @return {?}
     */
    Calendar.prototype.timedelta = /**
     * @param {?} date
     * @param {?} interval
     * @param {?} units
     * @return {?}
     */
    function (date, interval, units) {
        var /** @type {?} */ ret = new Date(date);
        var /** @type {?} */ checkRollover = function () {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    };
    /**
     * @param {?} date
     * @param {?} locale
     * @param {?} options
     * @param {?} parts
     * @return {?}
     */
    Calendar.prototype.formatToParts = /**
     * @param {?} date
     * @param {?} locale
     * @param {?} options
     * @param {?} parts
     * @return {?}
     */
    function (date, locale, options, parts) {
        var /** @type {?} */ formatter = new Intl.DateTimeFormat(locale, options);
        var /** @type {?} */ result = {
            date: date,
            full: formatter.format(date)
        };
        if ((/** @type {?} */ (formatter)).formatToParts) {
            var /** @type {?} */ formattedParts_1 = (/** @type {?} */ (formatter)).formatToParts(date);
            var /** @type {?} */ toType = function (partType) {
                var /** @type {?} */ index = formattedParts_1.findIndex(function (_a) {
                    var type = _a.type;
                    return type === partType;
                });
                var /** @type {?} */ o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts_1[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts_1[index].value;
                o.literal = formattedParts_1[index + 1] ? formattedParts_1[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            try {
                for (var parts_1 = tslib_1.__values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                    var each = parts_1_1.value;
                    result[each] = toType(each);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        else {
            try {
                for (var parts_2 = tslib_1.__values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                    var each = parts_2_1.value;
                    result[each] = { value: '', literal: '', combined: '' };
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (parts_2_1 && !parts_2_1.done && (_b = parts_2.return)) _b.call(parts_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        return result;
        var e_4, _a, e_5, _b;
    };
    /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.generateICalendarDate = /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        return {
            date: date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    };
    /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.isPreviousMonth = /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    };
    /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.isNextMonth = /**
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    };
    return Calendar;
}());
export { Calendar };
function Calendar_tsickle_Closure_declarations() {
    /** @type {?} */
    Calendar.prototype._firstWeekDay;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NhbGVuZGFyL2NhbGVuZGFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EscUJBQU0sS0FBSyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvRCxxQkFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0FBRW5CLE1BQU0sZ0JBQWdCLEtBQVMsRUFBRSxJQUFJLEVBQUUsSUFBUTtJQUF6QixzQkFBQSxFQUFBLFNBQVM7SUFBUSxxQkFBQSxFQUFBLFFBQVE7SUFDM0MscUJBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNmLHFCQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDN0MscUJBQU0sR0FBRyxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNoRCxHQUFHLENBQUMsQ0FBQyxxQkFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ3hELEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDZjtJQUNELE1BQU0sQ0FBQyxHQUFHLENBQUM7Q0FDZDs7Ozs7Ozs7QUFTRCxNQUFNLGlCQUFpQixJQUFZO0lBQy9CLE1BQU0sQ0FB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YTtRQUMzRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLEtBQUssQ0FBQztTQUNsQztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDOzs7Ozs7OztJQUc3Qiw4QkFBVzs7Ozs7O2NBQUMsSUFBVSxFQUFFLElBQVksRUFBRSxLQUFhO1FBQ3ZELEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzlCLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDO1NBQ2xDO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUM7O21CQTdRekM7SUErUUMsQ0FBQTtBQXZNRCxvQkF1TUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IE1EQVlTID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgRkVCUlVBUlkgPSAxO1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQgPSAwLCBzdG9wLCBzdGVwID0gMSkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGN1ciA9IChzdG9wID09PSB1bmRlZmluZWQpID8gMCA6IHN0YXJ0O1xuICAgIGNvbnN0IG1heCA9IChzdG9wID09PSB1bmRlZmluZWQpID8gc3RhcnQgOiBzdG9wO1xuICAgIGZvciAobGV0IGkgPSBjdXI7IHN0ZXAgPCAwID8gaSA+IG1heCA6IGkgPCBtYXg7IGkgKz0gc3RlcCkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgZm9yIGxlYXAgeWVhcnMsIGZhbHNlIGZvciBub24tbGVhcCB5ZWFycy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0geWVhclxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhcCh5ZWFyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwKSAmJiAoKHllYXIgJSAxMDAgIT09IDApIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrRGF5KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KS5nZXREYXkoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2Vla2RheSBhbmQgbnVtYmVyIG9mIGRheXMgZm9yIHllYXIsIG1vbnRoLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB5ZWFyXG4gKiBAcGFyYW0gbW9udGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb250aFJhbmdlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlcltdIHtcbiAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb250aCBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgY29uc3QgZGF5ID0gd2Vla0RheSh5ZWFyLCBtb250aCwgMSk7XG4gICAgbGV0IG5EYXlzID0gTURBWVNbbW9udGhdO1xuICAgIGlmICgobW9udGggPT09IEZFQlJVQVJZKSAmJiAoaXNMZWFwKHllYXIpKSkge1xuICAgICAgICBuRGF5cysrO1xuICAgIH1cbiAgICByZXR1cm4gW2RheSwgbkRheXNdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDYWxlbmRhckRhdGUge1xuICAgIGRhdGU6IERhdGU7XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG4gICAgaXNQcmV2TW9udGg6IGJvb2xlYW47XG4gICAgaXNOZXh0TW9udGg6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRlZFBhcnRzIHtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGxpdGVyYWw/OiBzdHJpbmc7XG4gICAgY29tYmluZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGVudW0gV0VFS0RBWVMge1xuICAgIFNVTkRBWSA9IDAsXG4gICAgTU9OREFZID0gMSxcbiAgICBUVUVTREFZID0gMixcbiAgICBXRURORVNEQVkgPSAzLFxuICAgIFRIVVJTREFZID0gNCxcbiAgICBGUklEQVkgPSA1LFxuICAgIFNBVFVSREFZID0gNlxufVxuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXIge1xuXG4gICAgcHJpdmF0ZSBfZmlyc3RXZWVrRGF5OiBudW1iZXIgfCBXRUVLREFZUztcblxuICAgIGNvbnN0cnVjdG9yKGZpcnN0V2Vla0RheTogbnVtYmVyIHwgV0VFS0RBWVMgPSBXRUVLREFZUy5TVU5EQVkpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RXZWVrRGF5ID0gZmlyc3RXZWVrRGF5O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZmlyc3RXZWVrRGF5KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdFdlZWtEYXkgJSA3O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZmlyc3RXZWVrRGF5KHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RXZWVrRGF5ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB3ZWVrZGF5cyBmb3Igb25lIHdlZWsgc3RhcnRpbmdcbiAgICAgKiB3aXRoIHRoZSBjdXJyZW50bHkgc2V0IGBmaXJzdFdlZWtEYXlgXG4gICAgICpcbiAgICAgKiB0aGlzLmZpcnN0V2Vla0RheSA9IDAgKFN1bmRheSkgLS0+IFswLCAxLCAyLCAzLCA0LCA1LCA2XVxuICAgICAqIHRoaXMuZmlyc3RXZWVrRGF5ID0gMSAoTW9uZGF5KSAtLT4gWzEsIDIsIDMsIDQsIDUsIDYsIDBdXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENhbGVuZGFyXG4gICAgICovXG4gICAgcHVibGljIHdlZWtkYXlzKCk6IG51bWJlcltdIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiByYW5nZSh0aGlzLmZpcnN0V2Vla0RheSwgdGhpcy5maXJzdFdlZWtEYXkgKyA3KSkge1xuICAgICAgICAgICAgcmVzLnB1c2goaSAlIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSB2YWx1ZXMgZm9yIG9uZSBtb250aC4gSXQgd2lsbCBhbHdheXMgaXRlcmF0ZSB0aHJvdWdodFxuICAgICAqIGNvbXBsZXRlIHdlZWtzLCBzbyBpdCB3aWxsIGNvbnRhaW4gZGF0ZXMgb3V0c2lkZSB0aGUgc3BlY2lmaWVkIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgKiBAcGFyYW0gYm9vbGVhblxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2FsZW5kYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgbW9udGhkYXRlcyh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGV4dHJhV2VlazogYm9vbGVhbiA9IGZhbHNlKTogSUNhbGVuZGFyRGF0ZVtdIHtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgIGxldCBkYXlzID0gKGRhdGUuZ2V0RGF5KCkgLSB0aGlzLmZpcnN0V2Vla0RheSkgJSA3O1xuICAgICAgICBpZiAoZGF5cyA8IDApIHtcbiAgICAgICAgICAgIGRheXMgPSA3IC0gTWF0aC5hYnMoZGF5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZSA9IHRoaXMudGltZWRlbHRhKGRhdGUsICdkYXknLCAtZGF5cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBsZXQgdmFsdWU6IElDYWxlbmRhckRhdGU7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdlbmVyYXRlSUNhbGVuZGFyRGF0ZShkYXRlLCB5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICByZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy50aW1lZGVsdGEoZGF0ZSwgJ2RheScsIDEpO1xuXG4gICAgICAgICAgICBpZiAoKGRhdGUuZ2V0TW9udGgoKSAhPT0gbW9udGgpICYmIChkYXRlLmdldERheSgpID09PSB0aGlzLmZpcnN0V2Vla0RheSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFXZWVrICYmIHJlcy5sZW5ndGggPD0gMzUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKDAsIDcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2VuZXJhdGVJQ2FsZW5kYXJEYXRlKGRhdGUsIHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IChhcnJheSBvZiBhcnJheXMpIHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIGZ1bGwgd2Vlazsgd2VlayBlbnRyaWVzIGFyZSBJQ2FsZW5kYXJEYXRlIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2FsZW5kYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgbW9udGhkYXRlc2NhbGVuZGFyKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZXh0cmFXZWVrOiBib29sZWFuID0gZmFsc2UpOiBJQ2FsZW5kYXJEYXRlW11bXSB7XG4gICAgICAgIGNvbnN0IGRhdGVzID0gdGhpcy5tb250aGRhdGVzKHllYXIsIG1vbnRoLCBleHRyYVdlZWspO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKDAsIGRhdGVzLmxlbmd0aCwgNykpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgdGltZWRlbHRhKGRhdGU6IERhdGUsIGludGVydmFsOiBzdHJpbmcsIHVuaXRzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tSb2xsb3ZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXQuZ2V0RGF0ZSgpICE9PSBkYXRlLmdldERhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldC5zZXREYXRlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoaW50ZXJ2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgcmV0LnNldEZ1bGxZZWFyKHJldC5nZXRGdWxsWWVhcigpICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIGNoZWNrUm9sbG92ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIDMgKiB1bml0cyk7XG4gICAgICAgICAgICAgICAgY2hlY2tSb2xsb3ZlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBjaGVja1JvbGxvdmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0RGF0ZShyZXQuZ2V0RGF0ZSgpICsgNyAqIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgcmV0LnNldERhdGUocmV0LmdldERhdGUoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDM2MDAwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0VGltZShyZXQuZ2V0VGltZSgpICsgdW5pdHMgKiA2MDAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZXJ2YWwgc3BlY2lmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9ybWF0VG9QYXJ0cyhkYXRlOiBEYXRlLCBsb2NhbGU6IHN0cmluZywgb3B0aW9uczogYW55LCBwYXJ0czogc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGZ1bGw6IGZvcm1hdHRlci5mb3JtYXQoZGF0ZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhcnRzID0gKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvVHlwZSA9IChwYXJ0VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmb3JtYXR0ZWRQYXJ0cy5maW5kSW5kZXgoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBwYXJ0VHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbzogSUZvcm1hdHRlZFBhcnRzID0geyB2YWx1ZTogJycsIGxpdGVyYWw6ICcnLCBjb21iaW5lZDogJyd9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRUeXBlID09PSAnZXJhJyAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG8udmFsdWUgPSBmb3JtYXR0ZWRQYXJ0c1tpbmRleF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydFR5cGUgPT09ICdlcmEnICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvLnZhbHVlID0gZm9ybWF0dGVkUGFydHNbaW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgIG8ubGl0ZXJhbCA9IGZvcm1hdHRlZFBhcnRzW2luZGV4ICsgMV0gPyBmb3JtYXR0ZWRQYXJ0c1tpbmRleCArIDFdLnZhbHVlIDogJyc7XG4gICAgICAgICAgICAgICAgby5jb21iaW5lZCA9IFtvLnZhbHVlLCBvLmxpdGVyYWxdLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlYWNoIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VhY2hdID0gdG9UeXBlKGVhY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlYWNoIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VhY2hdID0geyB2YWx1ZTogJycsIGxpdGVyYWw6ICcnLCBjb21iaW5lZDogJyd9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZTogRGF0ZSwgeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogSUNhbGVuZGFyRGF0ZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoLFxuICAgICAgICAgICAgaXNOZXh0TW9udGg6IHRoaXMuaXNOZXh0TW9udGgoZGF0ZSwgeWVhciwgbW9udGgpLFxuICAgICAgICAgICAgaXNQcmV2TW9udGg6IHRoaXMuaXNQcmV2aW91c01vbnRoKGRhdGUsIHllYXIsIG1vbnRoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNQcmV2aW91c01vbnRoKGRhdGU6IERhdGUsIHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpIDwgbW9udGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA8IHllYXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05leHRNb250aChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSA+IG1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA+IHllYXI7XG4gICAgfVxufVxuIl19