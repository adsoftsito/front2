"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const inquirer = require("inquirer");
const BaseComponent_1 = require("./BaseComponent");
const add_1 = require("./commands/add");
const start_1 = require("./commands/start");
const GoogleAnalytics_1 = require("./GoogleAnalytics");
const PackageManager_1 = require("./packages/PackageManager");
const ProjectConfig_1 = require("./ProjectConfig");
const Util_1 = require("./Util");
class PromptSession {
    constructor(templateManager) {
        this.templateManager = templateManager;
        this.WIZARD_BACK_OPTION = "Back";
    }
    static chooseTerm() {
        return __awaiter(this, void 0, void 0, function* () {
            const answers = yield inquirer.prompt({
                default: null,
                message: "Enter a search term",
                name: "term",
                type: "input"
            });
            if (answers.term) {
                return answers.term;
            }
            else {
                const retProm = yield this.chooseTerm();
                return retProm;
            }
        });
    }
    /**
     * Start questions session for project creation
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            GoogleAnalytics_1.GoogleAnalytics.post({ cd: "Wizard", t: "screenview" });
            let projLibrary;
            let theme;
            add_1.default.templateManager = this.templateManager;
            const config = ProjectConfig_1.ProjectConfig.getConfig();
            const defaultProjName = "IG Project";
            if (ProjectConfig_1.ProjectConfig.hasLocalConfig() && !config.project.isShowcase) {
                projLibrary = this.templateManager.getProjectLibrary(config.project.framework, config.project.projectType);
                theme = config.project.theme;
            }
            else {
                Util_1.Util.log(""); /* new line */
                let projectName;
                const availableDefaultName = Util_1.Util.getAvailableName(defaultProjName, true);
                while (!projectName) {
                    const defaultAppName = availableDefaultName;
                    const nameRes = yield this.getUserInput({
                        default: defaultAppName,
                        message: "Enter a name for your project:",
                        name: "projectName",
                        type: "input"
                    });
                    if (this.nameIsValid(nameRes)) {
                        projectName = nameRes;
                    }
                }
                const frameRes = yield this.getUserInput({
                    choices: this.templateManager.getFrameworkNames(),
                    default: "jQuery",
                    message: "Choose framework:",
                    name: "framework",
                    type: "list"
                });
                const framework = this.templateManager.getFrameworkByName(frameRes);
                //app name validation???
                projLibrary = yield this.getProjectLibrary(framework);
                theme = yield this.getTheme(projLibrary);
                const projTemplate = projLibrary.getProject();
                Util_1.Util.log("  Generating project structure.");
                yield projTemplate.generateFiles(process.cwd(), projectName, theme);
                Util_1.Util.log(Util_1.Util.greenCheck() + " Project structure generated.");
                if (!config.skipGit) {
                    Util_1.Util.gitInit(process.cwd(), projectName);
                }
                // move cwd to project folder
                process.chdir(projectName);
            }
            yield this.chooseActionLoop(projLibrary, theme);
            //TODO: restore cwd?
        });
    }
    /**
     * Starts a loop of 'Choose an action' questions
     * @param projectLibrary The framework to use
     * @param theme Theme to use
     */
    chooseActionLoop(projectLibrary, theme) {
        return __awaiter(this, void 0, void 0, function* () {
            let actionIsOver = false;
            while (!actionIsOver) {
                const actionChoices = this.generateActionChoices(projectLibrary);
                Util_1.Util.log(""); /* new line */
                const action = yield this.getUserInput({
                    choices: actionChoices,
                    default: "Complete & Run",
                    message: "Choose an action:",
                    name: "action",
                    type: "list"
                });
                switch (action) {
                    case "Add component": {
                        actionIsOver = yield this.addComponent(projectLibrary, theme);
                        break;
                    }
                    case "Add scenario": {
                        actionIsOver = yield this.addView(projectLibrary, theme);
                        break;
                    }
                    case "Complete & Run":
                        const config = ProjectConfig_1.ProjectConfig.getConfig();
                        const defaultPort = config.project.defaultPort;
                        let port;
                        let userPort;
                        while (!userPort) {
                            // tslint:disable-next-line:prefer-const
                            port = (yield inquirer.prompt({
                                default: defaultPort,
                                message: "Choose app host port:",
                                name: "port",
                                type: "input"
                            }))["port"];
                            if (!Number(port)) {
                                Util_1.Util.log(`port should be a number. Input valid port or use the suggested default port`, "yellow");
                            }
                            else {
                                userPort = true;
                            }
                        }
                    default: {
                        yield PackageManager_1.PackageManager.flushQueue(true);
                        if (true) { // TODO: Make conditional?
                            yield start_1.default.start({ port });
                            return;
                        }
                    }
                }
            }
            yield this.chooseActionLoop(projectLibrary, theme);
        });
    }
    /**
     * Returns a new array with inquirer.Separator() added between items
     * @param array The original array to add separator to
     */
    addSeparators(array) {
        const newArray = [];
        for (let i = 0; i < array.length; i++) {
            newArray.push(array[i]);
            if (i + 1 < array.length) {
                newArray.push(new inquirer.Separator());
            }
        }
        if (array.length > 4) {
            // additional separator after last item for lists that wrap around
            newArray.push(new inquirer.Separator(new Array(15).join("=")));
        }
        return newArray;
    }
    /**
     * Generate questions from extra configuration array
     * @param extraConfig
     */
    createQuestions(extraConfig) {
        const result = [];
        for (const element of extraConfig) {
            const currExtraConfig = {};
            switch (element.type) {
                case 0 /* Choice */:
                    currExtraConfig["type"] = "list";
                    break;
                case 1 /* MultiChoice */:
                    currExtraConfig["type"] = "checkbox";
                    break;
                case 2 /* Value */:
                default:
                    currExtraConfig["type"] = "input";
                    break;
            }
            currExtraConfig["default"] = element.default;
            currExtraConfig["message"] = element.message;
            currExtraConfig["name"] = element.key;
            currExtraConfig["choices"] = element.choices;
            result.push(currExtraConfig);
        }
        return result;
    }
    /**
     * Conversion placeholder
     * @param answers
     */
    parseAnswers(answers) {
        return answers;
    }
    /**
     * Add the component user has selected
     * @param projectLibrary to add component to
     * @param theme to use to style the project
     */
    addComponent(projectLibrary, theme) {
        return __awaiter(this, void 0, void 0, function* () {
            let addComponentIsOver = false;
            while (!addComponentIsOver) {
                const groups = projectLibrary.getComponentGroupNames();
                const groupRes = yield this.getUserInput({
                    choices: this.formatOutput(projectLibrary.getComponentGroups()),
                    default: groups.find(x => x.includes("Grids")) || groups[0],
                    message: "Choose a group:",
                    name: "componentGroup",
                    type: "list"
                }, true);
                if (groupRes === this.WIZARD_BACK_OPTION) {
                    return false;
                }
                addComponentIsOver = yield this.choseComponent(projectLibrary, theme, groupRes);
            }
            return true;
        });
    }
    /**
     * Select the component in the selected components group
     * @param projectLibrary to add component to
     * @param theme to use to style the project
     * @param groupName to chose components from
     */
    choseComponent(projectLibrary, theme, groupName) {
        return __awaiter(this, void 0, void 0, function* () {
            let choseComponentIsOver = false;
            while (!choseComponentIsOver) {
                const componentNameRes = yield this.getUserInput({
                    choices: this.formatOutput(projectLibrary.getComponentsByGroup(groupName)),
                    message: "Choose a component:",
                    name: "component",
                    type: "list"
                }, true);
                if (componentNameRes === this.WIZARD_BACK_OPTION) {
                    return false;
                }
                const component = projectLibrary.getComponentByName(componentNameRes);
                choseComponentIsOver = yield this.getTemplate(projectLibrary, theme, groupName, component);
            }
            return true;
        });
    }
    /**
     * Select template for provided component and set template's extra configurations if any
     * @param projectLibrary to add component to
     * @param theme to use to style the project
     * @param groupName to chose components from
     * @param component to get template for
     */
    getTemplate(projectLibrary, theme, groupName, component) {
        return __awaiter(this, void 0, void 0, function* () {
            let selectedTemplate;
            const templates = component.templates;
            const config = ProjectConfig_1.ProjectConfig.getConfig();
            if (templates.length === 1) {
                //get the only one template
                selectedTemplate = templates[0];
            }
            else {
                const templateRes = yield this.getUserInput({
                    choices: this.formatOutput(templates),
                    message: "Choose one:",
                    name: "template",
                    type: "list"
                }, true);
                if (templateRes === this.WIZARD_BACK_OPTION) {
                    return false;
                }
                selectedTemplate = templates.find((value, i, obj) => {
                    return value.name === templateRes;
                });
            }
            if (selectedTemplate) {
                let success = false;
                const availableDefaultName = Util_1.Util.getAvailableName(selectedTemplate.name, false, config.project.framework, config.project.projectType);
                while (!success) {
                    const templateName = yield this.getUserInput({
                        default: availableDefaultName,
                        message: "Name your component:",
                        name: "componentName",
                        type: "input"
                    });
                    if (selectedTemplate.hasExtraConfiguration) {
                        const extraPrompt = this.createQuestions(selectedTemplate.getExtraConfiguration());
                        const extraConfigAnswers = yield inquirer.prompt(extraPrompt);
                        const extraConfig = this.parseAnswers(extraConfigAnswers);
                        GoogleAnalytics_1.GoogleAnalytics.post({
                            ea: `extra configuration: ${JSON.stringify(extraConfig)}`,
                            ec: "$ig wizard",
                            el: "Extra configuration:",
                            t: "event"
                        });
                        selectedTemplate.setExtraConfiguration(extraConfig);
                    }
                    success = yield add_1.default.addTemplate(templateName, selectedTemplate);
                }
            }
            return true;
        });
    }
    /**
     * Add the view user has selected
     * @param projectLibrary to add component to
     * @param theme to use to style the project
     */
    addView(projectLibrary, theme) {
        return __awaiter(this, void 0, void 0, function* () {
            const customTemplates = projectLibrary.getCustomTemplates();
            const formatedOutput = this.formatOutput(customTemplates);
            const config = ProjectConfig_1.ProjectConfig.getConfig();
            const customTemplateNameRes = yield this.getUserInput({
                choices: formatedOutput,
                message: "Choose custom view:",
                name: "customTemplate",
                type: "list"
            }, true);
            if (customTemplateNameRes === this.WIZARD_BACK_OPTION) {
                return false;
            }
            const selectedTemplate = customTemplates.find((value, i, obj) => {
                return customTemplateNameRes === value.name;
            });
            if (selectedTemplate) {
                let success = false;
                const availableDefaultName = Util_1.Util.getAvailableName(selectedTemplate.name, false, config.project.framework, config.project.projectType);
                while (!success) {
                    const customViewNameRes = yield this.getUserInput({
                        default: availableDefaultName,
                        message: "Name your view:",
                        name: "customViewName",
                        type: "input"
                    });
                    success = yield add_1.default.addTemplate(customViewNameRes, selectedTemplate);
                }
            }
            return true;
        });
    }
    /**
     * Gets the user input according to provided @param options.
     * If @param withBackChoice is set to true adds Back option to the list
     * @param options to use for the user input
     * @param withBackChoice determines whether or not Back option should be added
     */
    getUserInput(options, withBackChoice = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.choices) {
                if (withBackChoice) {
                    options.choices.push(this.WIZARD_BACK_OPTION);
                }
                options.choices = this.addSeparators(options.choices);
            }
            const userInput = yield inquirer.prompt({
                choices: options.choices || [],
                default: options.default || "",
                message: options.message,
                name: options.name,
                type: options.type
            });
            const result = userInput[options.name];
            // post to GA everything but 'Back' user choice
            if (!withBackChoice || result !== this.WIZARD_BACK_OPTION) {
                GoogleAnalytics_1.GoogleAnalytics.post({
                    ea: `${options.name}: ${result}`,
                    ec: "$ig wizard",
                    el: options.message,
                    t: "event"
                });
            }
            else {
                GoogleAnalytics_1.GoogleAnalytics.post({
                    ea: `Back from ${options.name}`,
                    ec: "$ig wizard",
                    el: result,
                    t: "event"
                });
            }
            return result;
        });
    }
    /**
     * Check if provided @param name is valid for project name
     * @param name the name to check
     */
    nameIsValid(name) {
        if (!Util_1.Util.isAlphanumericExt(name)) {
            Util_1.Util.error(`Name '${name}' is not valid. `
                + "Name should start with a letter and can also contain numbers, dashes and spaces.", "red");
            return false;
        }
        if (Util_1.Util.directoryExists(name)) {
            Util_1.Util.error(`Folder "${name}" already exists!`, "red");
            return false;
        }
        return true;
    }
    /**
     * Gets the project library from the user input, or default if provided @param framework has single project library
     * @param framework to get project library for
     */
    getProjectLibrary(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            let projectLibrary;
            if (framework.projectLibraries.length > 1) {
                const projectRes = yield this.getUserInput({
                    choices: this.templateManager.getProjectLibraryNames(framework.id),
                    message: "Choose the type of project:",
                    name: "projectType",
                    type: "list"
                });
                projectLibrary = this.templateManager.getProjectLibraryByName(framework, projectRes);
            }
            else {
                projectLibrary = this.templateManager.getProjectLibrary(framework.id);
            }
            return projectLibrary;
        });
    }
    /**
     * Gets the them from the user input, or default if provided @param projectLibrary has single theme
     * @param projectLibrary to get theme for
     */
    getTheme(projectLibrary) {
        return __awaiter(this, void 0, void 0, function* () {
            let theme;
            if (projectLibrary.themes.length < 2) {
                theme = projectLibrary.themes[0] || "";
            }
            else {
                theme = yield this.getUserInput({
                    choices: projectLibrary.themes,
                    default: projectLibrary.themes[0],
                    message: "Choose the theme for the project:",
                    name: "theme",
                    type: "list"
                });
            }
            return theme;
        });
    }
    /**
     * Generates a list of options for chooseActionLoop
     * @param projectLibrary to generate options for
     */
    generateActionChoices(projectLibrary) {
        const actionChoices = [{
                name: "Complete & Run" + chalk_1.default.gray("..........install packages and run in the default browser"),
                short: "Complete & Run",
                value: "Complete & Run"
            }];
        if (projectLibrary.components.length > 0) {
            actionChoices.push({
                name: "Add component" + chalk_1.default.gray("...........add a specific component view (e.g a grid)"),
                short: "Add component",
                value: "Add component" // actual selection value
            });
        }
        if (projectLibrary.getCustomTemplateNames().length > 0) {
            actionChoices.push({
                name: "Add scenario " + chalk_1.default.gray("...........add a predefined scenario view (e.g grid or dashboard)"),
                short: "Add scenario",
                value: "Add scenario"
            });
        }
        return actionChoices;
    }
    formatOutput(items) {
        const choiceItems = [];
        const leftPadding = 2;
        const rightPadding = 1;
        const maxNameLength = Math.max(...items.map(x => x.name.length)) + 3;
        const targetNameLength = Math.max(18, maxNameLength);
        let description;
        for (const item of items) {
            const choiceItem = {
                name: "",
                short: item.name,
                value: item.name
            };
            choiceItem.name = item.name;
            if (item instanceof BaseComponent_1.BaseComponent && item.templates.length <= 1) {
                description = item.templates[0].description || "";
            }
            else {
                description = item.description || "";
            }
            if (description !== "") {
                choiceItem.name = item.name + Util_1.Util.addColor(".".repeat(targetNameLength - item.name.length), 0);
                const max = process.stdout.columns - targetNameLength - leftPadding - rightPadding;
                description = Util_1.Util.truncate(description, max, 3, ".");
                description = Util_1.Util.addColor(description, 0);
                choiceItem.name += description;
            }
            choiceItems.push(choiceItem);
        }
        return choiceItems;
    }
}
exports.PromptSession = PromptSession;
