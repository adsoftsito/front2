/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, forwardRef, Input, ViewChildren, QueryList, HostBinding } from '@angular/core';
import { IgxRowComponent } from '../row.component';
import { TransactionType } from '../../services';
var IgxTreeGridRowComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxTreeGridRowComponent, _super);
    function IgxTreeGridRowComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "treeRow", {
        get: /**
         * The `ITreeGridRecord` passed to the row component.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const treeRow = row.treeRow;
         * ```
         * @return {?}
         */
        function () {
            return this._treeRow;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._treeRow !== value) {
                this._treeRow = value;
                this.rowData = this._treeRow.data;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "expanded", {
        get: /**
         * Returns a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const expanded = row.expanded;
         * ```
         * @return {?}
         */
        function () {
            return this._treeRow.expanded;
        },
        /**
         * Sets a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.expanded = true;
         * ```
         */
        set: /**
         * Sets a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.expanded = true;
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            (/** @type {?} */ (this.gridAPI)).trigger_row_expansion_toggle(this.gridID, this._treeRow, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridRowComponent.prototype.resolveClasses = /**
     * @hidden
     * @return {?}
     */
    function () {
        var /** @type {?} */ classes = _super.prototype.resolveClasses.call(this);
        var /** @type {?} */ filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return classes + " " + filteredClass;
    };
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "deleted", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.hasDeletedParent(this.rowID) || _super.prototype.isRowDeleted.call(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} rowId
     * @return {?}
     */
    IgxTreeGridRowComponent.prototype.hasDeletedParent = /**
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        if (this.grid.cascadeOnDelete) {
            var /** @type {?} */ node = this.grid.records.get(rowId);
            try {
                for (var _a = tslib_1.__values(node.path), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var parentId = _b.value;
                    var /** @type {?} */ state = this.grid.transactions.getState(parentId);
                    if (state && state.type === TransactionType.DELETE) {
                        if (this.gridAPI.get_row_by_key(this.grid.id, parentId).deleted) {
                            return true;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return false;
        var e_1, _c;
    };
    IgxTreeGridRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tree-grid-row',
                    template: "<ng-container *ngIf=\"rowSelectable\">\n    <div class=\"igx-grid__cbx-selection\">\n        <igx-checkbox [checked]=\"isSelected\" (change)=\"onCheckboxClick($event)\" disableRipple=\"true\" [aria-label]=\"rowCheckboxAriaLabel\"></igx-checkbox>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <ng-template ngFor let-col [ngForOf]=\"notGroups(pinnedColumns)\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell [column]=\"col\" [row]=\"this\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\" [value]=\"rowData[col.field]\" [cellTemplate]=\"col.bodyTemplate\" #treeCell></igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell [column]=\"col\" [row]=\"this\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\" [value]=\"rowData[col.field]\" [cellTemplate]=\"col.bodyTemplate\" #treeCell></igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"notGroups(unpinnedColumns)\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell [column]=\"col\" [row]=\"this\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\" [value]=\"rowData[col.field]\" [cellTemplate]=\"col.bodyTemplate\" #treeCell></igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell [column]=\"col\" [row]=\"this\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\" [value]=\"rowData[col.field]\" [cellTemplate]=\"col.bodyTemplate\" #treeCell></igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n",
                    providers: [{ provide: IgxRowComponent, useExisting: forwardRef(function () { return IgxTreeGridRowComponent; }) }]
                },] },
    ];
    /** @nocollapse */
    IgxTreeGridRowComponent.propDecorators = {
        "cells": [{ type: ViewChildren, args: ['treeCell',] },],
        "treeRow": [{ type: Input },],
        "expanded": [{ type: HostBinding, args: ['attr.aria-expanded',] },],
    };
    return IgxTreeGridRowComponent;
}(IgxRowComponent));
export { IgxTreeGridRowComponent };
function IgxTreeGridRowComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTreeGridRowComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTreeGridRowComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxTreeGridRowComponent.propDecorators;
    /** @type {?} */
    IgxTreeGridRowComponent.prototype._treeRow;
    /**
     * The rendered cells in the row component.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1);
     * const cells = row.cells;
     * ```
     * @type {?}
     */
    IgxTreeGridRowComponent.prototype.cells;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLXJvdy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL3RyZWUtZ3JpZC90cmVlLWdyaWQtcm93LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFHbkQsT0FBTyxFQUFTLGVBQWUsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztJQWdDWCxtREFBcUM7Ozs7MEJBdUJuRSw0Q0FBTzs7Ozs7Ozs7Ozs7WUFDZCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7Ozs7O2tCQUVOLEtBQXNCO1lBQ3JDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7Z0JBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7YUFDckM7Ozs7OzBCQVlELDZDQUFROzs7Ozs7Ozs7OztZQUNSLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQzs7UUFHbEM7Ozs7Ozs7V0FPRzs7Ozs7Ozs7Ozs7UUFDSCxVQUFhLEtBQWM7WUFDdkIsbUJBQUMsSUFBSSxDQUFDLE9BQWdDLEVBQUMsQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0c7Ozs7SUFFRDs7T0FFRzs7Ozs7SUFDTyxnREFBYzs7OztJQUF4QjtRQUNJLHFCQUFNLE9BQU8sR0FBRyxpQkFBTSxjQUFjLFdBQUUsQ0FBQztRQUN2QyxxQkFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN2RixNQUFNLENBQUksT0FBTyxTQUFJLGFBQWUsQ0FBQztLQUN4QzswQkFHVSw0Q0FBTzs7Ozs7O1lBQ2QsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksaUJBQU0sWUFBWSxXQUFFLENBQUM7Ozs7Ozs7OztJQUc3RCxrREFBZ0I7Ozs7Y0FBQyxLQUFVO1FBQy9CLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUM1QixxQkFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDOztnQkFDMUMsR0FBRyxDQUFDLENBQW1CLElBQUEsS0FBQSxpQkFBQSxJQUFJLENBQUMsSUFBSSxDQUFBLGdCQUFBO29CQUEzQixJQUFNLFFBQVEsV0FBQTtvQkFDZixxQkFBTSxLQUFLLEdBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMvRCxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzt3QkFDakQsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQzs0QkFDOUQsTUFBTSxDQUFDLElBQUksQ0FBQzt5QkFDZjtxQkFDSjtpQkFDSjs7Ozs7Ozs7O1NBQ0o7UUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDOzs7O2dCQW5IcEIsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFFBQVEsRUFBRSwra0VBeUJiO29CQUNHLFNBQVMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLGNBQU0sT0FBQSx1QkFBdUIsRUFBdkIsQ0FBdUIsQ0FBQyxFQUFFLENBQUM7aUJBQ3BHOzs7OzBCQVlJLFlBQVksU0FBQyxVQUFVOzRCQVd2QixLQUFLOzZCQW1CTCxXQUFXLFNBQUMsb0JBQW9COztrQ0E5RXJDO0VBcUM2QyxlQUFlO1NBQS9DLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5wdXQsIFZpZXdDaGlsZHJlbiwgUXVlcnlMaXN0LCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRDb21wb25lbnQgfSBmcm9tICcuL3RyZWUtZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Um93Q29tcG9uZW50IH0gZnJvbSAnLi4vcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IElneFRyZWVHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IFN0YXRlLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZC1yb3cnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdJZj1cInJvd1NlbGVjdGFibGVcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2NieC1zZWxlY3Rpb25cIj5cbiAgICAgICAgPGlneC1jaGVja2JveCBbY2hlY2tlZF09XCJpc1NlbGVjdGVkXCIgKGNoYW5nZSk9XCJvbkNoZWNrYm94Q2xpY2soJGV2ZW50KVwiIGRpc2FibGVSaXBwbGU9XCJ0cnVlXCIgW2FyaWEtbGFiZWxdPVwicm93Q2hlY2tib3hBcmlhTGFiZWxcIj48L2lneC1jaGVja2JveD5cbiAgICA8L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiPlxuICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cIm5vdEdyb3VwcyhwaW5uZWRDb2x1bW5zKVwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2NlbGxUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxpZ3gtZ3JpZC1jZWxsIFtjb2x1bW5dPVwiY29sXCIgW3Jvd109XCJ0aGlzXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJjb2wud2lkdGhcIiBbdmFsdWVdPVwicm93RGF0YVtjb2wuZmllbGRdXCIgW2NlbGxUZW1wbGF0ZV09XCJjb2wuYm9keVRlbXBsYXRlXCIgI3RyZWVDZWxsPjwvaWd4LWdyaWQtY2VsbD5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjdHJlZUNlbGxUZW1wbGF0ZT5cbiAgICAgICAgICAgIDxpZ3gtdHJlZS1ncmlkLWNlbGwgW2NvbHVtbl09XCJjb2xcIiBbcm93XT1cInRoaXNcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT1cImNvbC53aWR0aFwiIFt2YWx1ZV09XCJyb3dEYXRhW2NvbC5maWVsZF1cIiBbY2VsbFRlbXBsYXRlXT1cImNvbC5ib2R5VGVtcGxhdGVcIiAjdHJlZUNlbGw+PC9pZ3gtdHJlZS1ncmlkLWNlbGw+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wudmlzaWJsZUluZGV4ID09PSAwID8gdHJlZUNlbGxUZW1wbGF0ZSA6IGNlbGxUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLWNvbnRhaW5lcj5cbjxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1jb2wgW2lneEdyaWRGb3JPZl09XCJub3RHcm91cHModW5waW5uZWRDb2x1bW5zKVwiIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwiZ3JpZC5wYXJlbnRWaXJ0RGlyXCIgbGV0LWNvbEluZGV4PVwiaW5kZXhcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvckNvbnRhaW5lclNpemVdPSdncmlkLnVucGlubmVkV2lkdGgnIFtpZ3hGb3JUcmFja0J5XT0nZ3JpZC50cmFja0NvbHVtbkNoYW5nZXMnICNpZ3hEaXJSZWY+XG4gICAgPG5nLXRlbXBsYXRlICNjZWxsVGVtcGxhdGU+XG4gICAgICAgIDxpZ3gtZ3JpZC1jZWxsIFtjb2x1bW5dPVwiY29sXCIgW3Jvd109XCJ0aGlzXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJjb2wud2lkdGhcIiBbdmFsdWVdPVwicm93RGF0YVtjb2wuZmllbGRdXCIgW2NlbGxUZW1wbGF0ZV09XCJjb2wuYm9keVRlbXBsYXRlXCIgI3RyZWVDZWxsPjwvaWd4LWdyaWQtY2VsbD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy10ZW1wbGF0ZSAjdHJlZUNlbGxUZW1wbGF0ZT5cbiAgICAgICAgPGlneC10cmVlLWdyaWQtY2VsbCBbY29sdW1uXT1cImNvbFwiIFtyb3ddPVwidGhpc1wiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPVwiY29sLndpZHRoXCIgW3ZhbHVlXT1cInJvd0RhdGFbY29sLmZpZWxkXVwiIFtjZWxsVGVtcGxhdGVdPVwiY29sLmJvZHlUZW1wbGF0ZVwiICN0cmVlQ2VsbD48L2lneC10cmVlLWdyaWQtY2VsbD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wudmlzaWJsZUluZGV4ID09PSAwID8gdHJlZUNlbGxUZW1wbGF0ZSA6IGNlbGxUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hSb3dDb21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneFRyZWVHcmlkUm93Q29tcG9uZW50KSB9XVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudCBleHRlbmRzIElneFJvd0NvbXBvbmVudDxJZ3hUcmVlR3JpZENvbXBvbmVudD4ge1xuICAgIHByaXZhdGUgX3RyZWVSb3c6IElUcmVlR3JpZFJlY29yZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlZCBjZWxscyBpbiB0aGUgcm93IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCByb3cgPSB0aGlzLmdyaWQuZ2V0Um93QnlLZXkoMSk7XG4gICAgICogY29uc3QgY2VsbHMgPSByb3cuY2VsbHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQFZpZXdDaGlsZHJlbigndHJlZUNlbGwnKVxuICAgIHB1YmxpYyBjZWxsczogUXVlcnlMaXN0PGFueT47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYElUcmVlR3JpZFJlY29yZGAgcGFzc2VkIHRvIHRoZSByb3cgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJvdyA9IHRoaXMuZ3JpZC5nZXRSb3dCeUtleSgxKSBhcyBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudDtcbiAgICAgKiBjb25zdCB0cmVlUm93ID0gcm93LnRyZWVSb3c7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHRyZWVSb3coKTogSVRyZWVHcmlkUmVjb3JkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVSb3c7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgdHJlZVJvdyh2YWx1ZTogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmVlUm93ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJlZVJvdyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yb3dEYXRhID0gdGhpcy5fdHJlZVJvdy5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcm93IGNvbXBvbmVudCBpcyBleHBhbmRlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCByb3cgPSB0aGlzLmdyaWQuZ2V0Um93QnlLZXkoMSkgYXMgSWd4VHJlZUdyaWRSb3dDb21wb25lbnQ7XG4gICAgICogY29uc3QgZXhwYW5kZWQgPSByb3cuZXhwYW5kZWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKVxuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVSb3cuZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcm93IGNvbXBvbmVudCBpcyBleHBhbmRlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCByb3cgPSB0aGlzLmdyaWQuZ2V0Um93QnlLZXkoMSkgYXMgSWd4VHJlZUdyaWRSb3dDb21wb25lbnQ7XG4gICAgICogcm93LmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgKHRoaXMuZ3JpZEFQSSBhcyBJZ3hUcmVlR3JpZEFQSVNlcnZpY2UpLnRyaWdnZXJfcm93X2V4cGFuc2lvbl90b2dnbGUodGhpcy5ncmlkSUQsIHRoaXMuX3RyZWVSb3csIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVDbGFzc2VzKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBzdXBlci5yZXNvbHZlQ2xhc3NlcygpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZENsYXNzID0gdGhpcy50cmVlUm93LmlzRmlsdGVyZWRPdXRQYXJlbnQgPyAnaWd4LWdyaWRfX3RyLS1maWx0ZXJlZCcgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke2NsYXNzZXN9ICR7ZmlsdGVyZWRDbGFzc31gO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBkZWxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNEZWxldGVkUGFyZW50KHRoaXMucm93SUQpIHx8IHN1cGVyLmlzUm93RGVsZXRlZCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzRGVsZXRlZFBhcmVudChyb3dJZDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuY2FzY2FkZU9uRGVsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ncmlkLnJlY29yZHMuZ2V0KHJvd0lkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyZW50SWQgb2Ygbm9kZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGU6IFN0YXRlID0gdGhpcy5ncmlkLnRyYW5zYWN0aW9ucy5nZXRTdGF0ZShwYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZEFQSS5nZXRfcm93X2J5X2tleSh0aGlzLmdyaWQuaWQsIHBhcmVudElkKS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=