/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, NgZone } from '@angular/core';
import { DOCUMENT, ÉµgetDOM as getDOM } from '@angular/platform-browser';
var /** @type {?} */ EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 * @hidden
 */
var HammerGesturesManager = /** @class */ (function () {
    function HammerGesturesManager(_zone, doc) {
        this._zone = _zone;
        this.doc = doc;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {
            // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
            // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
            inputClass: Hammer.TouchInput,
            recognizers: [
                [Hammer.Pan, { threshold: 0 }],
                [Hammer.Pinch, { enable: true }],
                [Hammer.Rotate, { enable: true }],
                [Hammer.Swipe, {
                        direction: Hammer.DIRECTION_HORIZONTAL
                    }]
            ]
        };
        this._hammerManagers = [];
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    HammerGesturesManager.prototype.supports = /**
     * @param {?} eventName
     * @return {?}
     */
    function (eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventHandler
     * @param {?=} options
     * @return {?}
     */
    HammerGesturesManager.prototype.addEventListener = /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventHandler
     * @param {?=} options
     * @return {?}
     */
    function (element, eventName, eventHandler, options) {
        var _this = this;
        if (options === void 0) { options = null; }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(function () {
            var /** @type {?} */ mc = _this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, _this.hammerOptions);
                _this.addManagerForElement(element, mc);
            }
            var /** @type {?} */ handler = function (eventObj) { _this._zone.run(function () { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return function () { mc.off(eventName, handler); };
        });
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param {?} target Can be one of either window, body or document(fallback default).
     * @param {?} eventName
     * @param {?} eventHandler
     * @return {?}
     */
    HammerGesturesManager.prototype.addGlobalEventListener = /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param {?} target Can be one of either window, body or document(fallback default).
     * @param {?} eventName
     * @param {?} eventHandler
     * @return {?}
     */
    function (target, eventName, eventHandler) {
        var /** @type {?} */ element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener(/** @type {?} */ (element), eventName, eventHandler);
    };
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param {?} target Target name
     * @return {?}
     */
    HammerGesturesManager.prototype.getGlobalEventTarget = /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param {?} target Target name
     * @return {?}
     */
    function (target) {
        return getDOM().getGlobalEventTarget(this.doc, target);
    };
    /**
     * Set HammerManager options.
     *
     * @param {?} element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     * @param {?} event
     * @param {?} options
     * @return {?}
     */
    HammerGesturesManager.prototype.setManagerOption = /**
     * Set HammerManager options.
     *
     * @param {?} element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     * @param {?} event
     * @param {?} options
     * @return {?}
     */
    function (element, event, options) {
        var /** @type {?} */ manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    };
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @param {?} manager
     * @return {?}
     */
    HammerGesturesManager.prototype.addManagerForElement = /**
     * Add an element and manager map to the internal collection.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @param {?} manager
     * @return {?}
     */
    function (element, manager) {
        this._hammerManagers.push({ element: element, manager: manager });
    };
    /**
     * Get HammerManager for the element or null
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    HammerGesturesManager.prototype.getManagerForElement = /**
     * Get HammerManager for the element or null
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ result = this._hammerManagers.filter(function (value, index, array) {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    };
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    HammerGesturesManager.prototype.removeManagerForElement = /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ index = null;
        for (var /** @type {?} */ i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            var /** @type {?} */ item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    };
    /**
     * Destroys all internally tracked HammerManagers, removing event listeners in the process.
     * @return {?}
     */
    HammerGesturesManager.prototype.destroy = /**
     * Destroys all internally tracked HammerManagers, removing event listeners in the process.
     * @return {?}
     */
    function () {
        try {
            for (var _a = tslib_1.__values(this._hammerManagers), _b = _a.next(); !_b.done; _b = _a.next()) {
                var item = _b.value;
                item.manager.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this._hammerManagers = [];
        var e_1, _c;
    };
    HammerGesturesManager.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HammerGesturesManager.ctorParameters = function () { return [
        { type: NgZone, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    return HammerGesturesManager;
}());
export { HammerGesturesManager };
function HammerGesturesManager_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    HammerGesturesManager.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    HammerGesturesManager.ctorParameters;
    /**
     * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
     * @type {?}
     */
    HammerGesturesManager.prototype.hammerOptions;
    /** @type {?} */
    HammerGesturesManager.prototype._hammerManagers;
    /** @type {?} */
    HammerGesturesManager.prototype._zone;
    /** @type {?} */
    HammerGesturesManager.prototype.doc;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG91Y2guanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdG91Y2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFeEUscUJBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQzs7Ozs7OztJQTRCM0IsK0JBQW9CLEtBQWEsRUFBNEI7UUFBekMsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUE0QixRQUFHLEdBQUgsR0FBRzs7Ozs2QkFoQnZCOzs7WUFHckMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLFdBQVcsRUFBRTtnQkFDVCxDQUFFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLENBQUU7Z0JBQ2hDLENBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBRTtnQkFDbEMsQ0FBRSxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFFO2dCQUNuQyxDQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUU7d0JBQ1osU0FBUyxFQUFFLE1BQU0sQ0FBQyxvQkFBb0I7cUJBQ3pDLENBQUM7YUFDTDtTQUNKOytCQUVtRixFQUFFO0tBR3JGOzs7OztJQUVNLHdDQUFROzs7O2NBQUMsU0FBaUI7UUFDN0IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7OztJQU96RCxnREFBZ0I7Ozs7Ozs7OztjQUFDLE9BQW9CLEVBQ3BCLFNBQWlCLEVBQ2pCLFlBQWdDLEVBQ2hDLE9BQXNCOztRQUF0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O1FBQ0QsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakIscUJBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7WUFFdEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMxQjs7Ozs7O0lBSUUsdUNBQU87Ozs7OztZQUNWLEdBQUcsQ0FBQyxDQUFlLElBQUEsS0FBQSxpQkFBQSxJQUFJLENBQUMsZUFBZSxDQUFBLGdCQUFBO2dCQUFsQyxJQUFNLElBQUksV0FBQTtnQkFDWCxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzFCOzs7Ozs7Ozs7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQzs7OztnQkF2SWpDLFVBQVU7Ozs7Z0JBVmtCLE1BQU07Z0RBK0JLLE1BQU0sU0FBQyxRQUFROztnQ0EvQnZEOztTQVdhLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCwgybVnZXRET00gYXMgZ2V0RE9NIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbmNvbnN0IEVWRU5UX1NVRkZJWCA9ICdwcmVjaXNlJztcblxuLyoqXG4gKiBUb3VjaCBnZXN0dXJlcyBtYW5hZ2VyIGJhc2VkIG9uIEhhbW1lci5qc1xuICogVXNlIHdpdGggY2F1dGlvbiwgdGhpcyB3aWxsIHRyYWNrIHJlZmVyZW5jZXMgZm9yIHNpbmdsZSBtYW5hZ2VyIHBlciBlbGVtZW50LiBWZXJ5IFRCRC4gTXVjaCBUT0RPLlxuICogQGhpZGRlblxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGFtbWVyR2VzdHVyZXNNYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBvcHRpb24gZGVmYXVsdHMgZm9yIGVhY2ggcmVjb2duaXplciwgc2VlIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vYXBpLyBmb3IgQVBJIGxpc3RpbmcuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGhhbW1lck9wdGlvbnM6IEhhbW1lck9wdGlvbnMgPSB7XG4gICAgICAgIC8vIEQuUC4gIzQ0NyBGb3JjZSBUb3VjaElucHV0IGR1ZSB0byBQb2ludGVyRXZlbnRJbnB1dCBidWcgKGh0dHBzOi8vZ2l0aHViLmNvbS9oYW1tZXJqcy9oYW1tZXIuanMvaXNzdWVzLzEwNjUpXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vSWduaXRlVUkvaWduaXRldWktYW5ndWxhci9pc3N1ZXMvNDQ3I2lzc3VlY29tbWVudC0zMjQ2MDE4MDNcbiAgICAgICAgaW5wdXRDbGFzczogSGFtbWVyLlRvdWNoSW5wdXQsXG4gICAgICAgIHJlY29nbml6ZXJzOiBbXG4gICAgICAgICAgICBbIEhhbW1lci5QYW4sIHsgdGhyZXNob2xkOiAwIH0gXSxcbiAgICAgICAgICAgIFsgSGFtbWVyLlBpbmNoLCB7IGVuYWJsZTogdHJ1ZSB9IF0sXG4gICAgICAgICAgICBbIEhhbW1lci5Sb3RhdGUsIHsgZW5hYmxlOiB0cnVlIH0gXSxcbiAgICAgICAgICAgIFsgSGFtbWVyLlN3aXBlLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUxcbiAgICAgICAgICAgIH1dXG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBfaGFtbWVyTWFuYWdlcnM6IEFycmF5PHsgZWxlbWVudDogRXZlbnRUYXJnZXQsIG1hbmFnZXI6IEhhbW1lck1hbmFnZXI7IH0+ID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF96b25lOiBOZ1pvbmUsIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgZG9jOiBhbnkpIHtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3VwcG9ydHMoZXZlbnROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuJyArIEVWRU5UX1NVRkZJWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGxpc3RlbmVyIGV4dGVuZGVkIHdpdGggb3B0aW9ucyBmb3IgSGFtbWVyLmpzLiBXaWxsIHVzZSBkZWZhdWx0cyBpZiBub25lIGFyZSBwcm92aWRlZC5cbiAgICAgKiBNb2RlbGluZyBhZnRlciBvdGhlciBldmVudCBwbHVnaW5zIGZvciBlYXN5IGZ1dHVyZSBtb2RpZmljYXRpb25zLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcjogKGV2ZW50T2JqKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9iamVjdCA9IG51bGwpOiAoKSA9PiB2b2lkIHtcblxuICAgICAgICAvLyBDcmVhdGluZyB0aGUgbWFuYWdlciBiaW5kIGV2ZW50cywgbXVzdCBiZSBkb25lIG91dHNpZGUgb2YgYW5ndWxhclxuICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWM6IEhhbW1lck1hbmFnZXIgPSB0aGlzLmdldE1hbmFnZXJGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKG1jID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IEhhbW1lciBpcyBhIHNob3J0Y3V0IGZvciBNYW5hZ2VyIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICAgICAgICBtYyA9IG5ldyBIYW1tZXIoZWxlbWVudCwgdGhpcy5oYW1tZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1hbmFnZXJGb3JFbGVtZW50KGVsZW1lbnQsIG1jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnRPYmopID0+IHsgdGhpcy5fem9uZS5ydW4oKCkgPT4geyBldmVudEhhbmRsZXIoZXZlbnRPYmopOyB9KTsgfTtcbiAgICAgICAgICAgIG1jLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBtYy5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGxpc3RlbmVyIGV4dGVuZGVkIHdpdGggb3B0aW9ucyBmb3IgSGFtbWVyLmpzLiBXaWxsIHVzZSBkZWZhdWx0cyBpZiBub25lIGFyZSBwcm92aWRlZC5cbiAgICAgKiBNb2RlbGluZyBhZnRlciBvdGhlciBldmVudCBwbHVnaW5zIGZvciBlYXN5IGZ1dHVyZSBtb2RpZmljYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCBDYW4gYmUgb25lIG9mIGVpdGhlciB3aW5kb3csIGJvZHkgb3IgZG9jdW1lbnQoZmFsbGJhY2sgZGVmYXVsdCkuXG4gICAgICovXG4gICAgcHVibGljIGFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGFyZ2V0OiBzdHJpbmcsIGV2ZW50TmFtZTogc3RyaW5nLCBldmVudEhhbmRsZXI6IChldmVudE9iaikgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQpO1xuXG4gICAgICAgIC8vIENyZWF0aW5nIHRoZSBtYW5hZ2VyIGJpbmQgZXZlbnRzLCBtdXN0IGJlIGRvbmUgb3V0c2lkZSBvZiBhbmd1bGFyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgW0RvbV1BZGFwdGVyLmdldEdsb2JhbEV2ZW50VGFyZ2V0IHRvIGdldCBnbG9iYWwgZXZlbnQgdGFyZ2V0cy5cbiAgICAgKiBTdXBwb3J0ZWQ6IHdpbmRvdywgZG9jdW1lbnQsIGJvZHkuIERlZmF1bHRzIHRvIGRvY3VtZW50IGZvciBpbnZhbGlkIGFyZ3MuXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgbmFtZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQ6IHN0cmluZyk6IEV2ZW50VGFyZ2V0IHtcbiAgICAgICAgcmV0dXJuIGdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRoaXMuZG9jLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBIYW1tZXJNYW5hZ2VyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdXNlZCB0byBjcmVhdGUgdGhlIG1hbmFnZXIgb24uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBtYW5hZ2VyLnNldE1hbmFnZXJPcHRpb24obXlFbGVtLCBcInBhblwiLCB7IHBvaW50ZXJzOiAxIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRNYW5hZ2VyT3B0aW9uKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0LCBldmVudDogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IHRoaXMuZ2V0TWFuYWdlckZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIG1hbmFnZXIuZ2V0KGV2ZW50KS5zZXQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGVsZW1lbnQgYW5kIG1hbmFnZXIgbWFwIHRvIHRoZSBpbnRlcm5hbCBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHVzZWQgdG8gY3JlYXRlIHRoZSBtYW5hZ2VyIG9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRNYW5hZ2VyRm9yRWxlbWVudChlbGVtZW50OiBFdmVudFRhcmdldCwgbWFuYWdlcjogSGFtbWVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5wdXNoKHtlbGVtZW50LCBtYW5hZ2VyfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IEhhbW1lck1hbmFnZXIgZm9yIHRoZSBlbGVtZW50IG9yIG51bGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFuYWdlciBvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TWFuYWdlckZvckVsZW1lbnQoZWxlbWVudDogRXZlbnRUYXJnZXQpOiBIYW1tZXJNYW5hZ2VyIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gIHRoaXMuX2hhbW1lck1hbmFnZXJzLmZpbHRlcigodmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdFswXS5tYW5hZ2VyIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgSGFtbWVyTWFuYWdlciBmb3IgdGhlIGVsZW1lbnQsIHJlbW92aW5nIGV2ZW50IGxpc3RlbmVycyBpbiB0aGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFuYWdlciBvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlTWFuYWdlckZvckVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2hhbW1lck1hbmFnZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5faGFtbWVyTWFuYWdlcnNbaV0uZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgLy8gZGVzdHJveSBhbHNvXG4gICAgICAgICAgICBpdGVtLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3lzIGFsbCBpbnRlcm5hbGx5IHRyYWNrZWQgSGFtbWVyTWFuYWdlcnMsIHJlbW92aW5nIGV2ZW50IGxpc3RlbmVycyBpbiB0aGUgcHJvY2Vzcy4gKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2hhbW1lck1hbmFnZXJzKSB7XG4gICAgICAgICAgICBpdGVtLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhbW1lck1hbmFnZXJzID0gW107XG4gICAgfVxufVxuIl19