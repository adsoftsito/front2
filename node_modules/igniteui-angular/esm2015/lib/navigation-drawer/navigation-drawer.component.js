/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, Renderer, ViewChild } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
let /** @type {?} */ NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
export class IgxNavigationDrawerComponent {
    /**
     * @param {?} elementRef
     * @param {?} _state
     * @param {?} renderer
     * @param {?} _touchManager
     */
    constructor(elementRef, _state, 
    // private animate: AnimationBuilder, TODO
    renderer, _touchManager) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.cssClass = 'igx-nav-drawer';
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * State of the drawer.
         *
         * ```typescript
         * // get
         * let navDrawerIsOpen = this.navdrawer.isOpen;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
         * ```
         */
        this.isOpen = false;
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 60px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '60px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            let /** @type {?} */ windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let /** @type {?} */ deltaX;
            let /** @type {?} */ startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            // TODO: test code
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const /** @type {?} */ startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.setElementClass(this.overlay, 'panning', true);
                this.renderer.setElementClass(this.drawer, 'panning', true);
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const /** @type {?} */ right = this.position === 'right';
            // when on the right use inverse of deltaX
            const /** @type {?} */ deltaX = right ? -evt.deltaX : evt.deltaX;
            let /** @type {?} */ visibleWidth;
            let /** @type {?} */ newX;
            let /** @type {?} */ percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const /** @type {?} */ deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const /** @type {?} */ visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     * @param {?} v
     * @return {?}
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     * @return {?}
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /**
     * @hidden
     * @return {?}
     */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     * @return {?}
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     * @return {?}
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     * @return {?}
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     * @return {?}
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @return {?}
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     * @return {?}
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     * @return {?}
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes["enableGestures"] && changes["enableGestures"].currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes["pin"] && changes["pin"].currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes["pinThreshold"]) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes["width"] && this.isOpen) {
            this.setDrawerWidth(changes["width"].currentValue);
        }
        if (changes["miniWidth"]) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes["miniWidth"].currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param {?=} mini
     * @return {?}
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                    this.renderer.setElementClass(this.styleDummy, this.css["mini"], false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css["drawer"], false);
                }
                return this._widthCache.width;
            }
        }
    }
    /**
     * @return {?}
     */
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     * @param {?} width
     * @return {?}
     */
    setDrawerWidth(width) {
        window.requestAnimationFrame(() => {
            if (this.drawer) {
                this.renderer.setElementStyle(this.drawer, 'width', width);
            }
        });
    }
    /**
     * Get current Drawer width.
     * @return {?}
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    /**
     * @return {?}
     */
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    /**
     * @return {?}
     */
    updateEdgeZone() {
        let /** @type {?} */ maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    /**
     * @return {?}
     */
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setElementStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setElementStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setElementStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setElementStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.decorators = [
    { type: Component, args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: `<ng-template #defaultItemsTemplate>
    <div igxDrawerItem [isHeader]="true">Navigation Drawer</div>
    <div igxDrawerItem> Start by adding</div>
    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>
    <div igxDrawerItem> And some items inside </div>
    <div igxDrawerItem> Style with igxDrawerItem </div>
    <div igxDrawerItem> and igxRipple directives</div>
</ng-template>

<div [hidden]="pin"
    class="igx-nav-drawer__overlay"
    [class.igx-nav-drawer__overlay--hidden]="!isOpen"
    (click)="close()" #overlay>
</div>
<aside role="navigation"
    class="igx-nav-drawer__aside"
    [class.igx-nav-drawer__aside--collapsed]="!miniTemplate && !isOpen"
    [class.igx-nav-drawer__aside--mini]="miniTemplate && !isOpen"
    [class.igx-nav-drawer__aside--normal]="!miniTemplate || isOpen"
    [class.igx-nav-drawer__aside--pinned]="pin"
    [class.igx-nav-drawer__aside--right]="position == 'right'" #aside>

    <ng-container *ngTemplateOutlet="template || defaultItemsTemplate"></ng-container>
</aside>
<div class="igx-nav-drawer__style-dummy" #dummy></div>
`
            },] },
];
/** @nocollapse */
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] },] },
    { type: IgxNavigationService, decorators: [{ type: Optional },] },
    { type: Renderer, },
    { type: HammerGesturesManager, },
];
IgxNavigationDrawerComponent.propDecorators = {
    "cssClass": [{ type: HostBinding, args: ['class',] },],
    "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
    "position": [{ type: Input },],
    "enableGestures": [{ type: Input },],
    "isOpen": [{ type: Input },],
    "pin": [{ type: Input },],
    "pinThreshold": [{ type: Input },],
    "width": [{ type: Input },],
    "miniWidth": [{ type: Input },],
    "pinChange": [{ type: Output },],
    "opening": [{ type: Output },],
    "opened": [{ type: Output },],
    "closing": [{ type: Output },],
    "closed": [{ type: Output },],
    "miniTemplate": [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] },],
    "contentTemplate": [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] },],
    "flexWidth": [{ type: HostBinding, args: ['style.flexBasis',] },],
    "isPinnedRight": [{ type: HostBinding, args: ['style.order',] },],
    "_drawer": [{ type: ViewChild, args: ['aside',] },],
    "_overlay": [{ type: ViewChild, args: ['overlay',] },],
    "_styleDummy": [{ type: ViewChild, args: ['dummy',] },],
};
function IgxNavigationDrawerComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxNavigationDrawerComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxNavigationDrawerComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxNavigationDrawerComponent.propDecorators;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.cssClass;
    /**
     * ID of the component
     *
     * ```typescript
     * // get
     * let myNavDrawerId = this.navdrawer.id;
     * ```
     *
     * ```html
     * <!--set-->
     *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.id;
    /**
     * Position of the Navigation Drawer. Can be "left"(default) or "right".
     *
     * ```typescript
     * // get
     * let myNavDrawerPosition = this.navdrawer.position;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.position;
    /**
     * Enables the use of touch gestures to manipulate the drawer:
     * - swipe/pan from edge to open, swipe-toggle and pan-drag.
     *
     * ```typescript
     * // get
     * let gesturesEnabled = this.navdrawer.enableGestures;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.enableGestures;
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.isOpen;
    /**
     * When pinned the drawer is relatively positioned instead of sitting above content.
     * May require additional layout styling.
     *
     * ```typescript
     * // get
     * let navDrawerIsPinned = this.navdrawer.pin;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pin;
    /**
     * Minimum device width required for automatic pin to be toggled.
     * Default is 1024, can be set to a falsy value to disable this behavior.
     *
     * ```typescript
     * // get
     * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinThreshold;
    /**
     * Width of the drawer in its open state. Defaults to "280px".
     *
     * ```typescript
     * // get
     * let navDrawerWidth = this.navdrawer.width;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.width;
    /**
     * Width of the drawer in its mini state. Defaults to 60px.
     *
     * ```typescript
     * // get
     * let navDrawerMiniWidth = this.navdrawer.miniWidth;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.miniWidth;
    /**
     * Pinned state change output for two-way binding.
     *
     * ```html
     * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinChange;
    /**
     * Event fired as the Navigation Drawer is about to open.
     *
     * ```html
     *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opening;
    /**
     * Event fired when the Navigation Drawer has opened.
     *
     * ```html
     * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opened;
    /**
     * Event fired as the Navigation Drawer is about to close.
     *
     * ```html
     * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closing;
    /**
     * Event fired when the Navigation Drawer has closed.
     *
     * ```html
     * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closed;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._miniTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.contentTemplate;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._gesturesAttached;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._widthCache;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._resizeObserver;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.css;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._drawer;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._overlay;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._styleDummy;
    /**
     * Pan animation properties
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype._panning;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._panStartWidth;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._panLimit;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._maxEdgeZone;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.checkPinThreshold;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.swipe;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.panstart;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.pan;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.panEnd;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.toggleOpenedEvent;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.toggleClosedEvent;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.elementRef;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._state;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.renderer;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype._touchManager;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9uYXZpZ2F0aW9uLWRyYXdlci9uYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLE1BQU0sRUFDTixRQUFRLEVBR1IsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sb0JBQW9CLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRWxILHFCQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EaEIsTUFBTTs7Ozs7OztJQW9WRixZQUNnQyxZQUNSOztJQUVWLFFBQWtCLEVBQ3BCO1FBSm9CLGVBQVUsR0FBVixVQUFVO1FBQ2xCLFdBQU0sR0FBTixNQUFNO1FBRWhCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDcEIsa0JBQWEsR0FBYixhQUFhO3dCQWxWZSxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7O2tCQWdCbkMsa0JBQWtCLE9BQU8sRUFBRSxFQUFFOzs7Ozs7Ozs7Ozs7Ozt3QkFldkIsTUFBTTs7Ozs7Ozs7Ozs7Ozs7OzhCQWdCQSxJQUFJOzs7Ozs7Ozs7Ozs7OztzQkFlWixLQUFLOzs7Ozs7Ozs7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d0JWLFNBQVMsU0FBQztnQkFDUCxTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQztnQkFDbEMsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUJiO2FBQ0E7Ozs7WUF2RUcsVUFBVSx1QkE2WkwsTUFBTSxTQUFDLFVBQVU7WUE1WWpCLG9CQUFvQix1QkE2WXBCLFFBQVE7WUFwWmIsUUFBUTtZQVFILHFCQUFxQjs7O3lCQTZEekIsV0FBVyxTQUFDLE9BQU87bUJBZW5CLFdBQVcsU0FBQyxTQUFTLGNBQ3JCLEtBQUs7eUJBZUwsS0FBSzsrQkFnQkwsS0FBSzt1QkFlTCxLQUFLO29CQWdCTCxLQUFLOzZCQWdCTCxLQUFLO3NCQXdCTCxLQUFLOzBCQWVMLEtBQUs7MEJBU0wsTUFBTTt3QkFRTixNQUFNO3VCQVFOLE1BQU07d0JBUU4sTUFBTTt1QkFRTixNQUFNOzZCQXdCTixZQUFZLFNBQUMsaUNBQWlDLEVBQUUsRUFBRSxJQUFJLEVBQUUsaUNBQWlDLEVBQUU7Z0NBVzNGLFlBQVksU0FBQyw2QkFBNkIsRUFBRSxFQUFFLElBQUksRUFBRSw2QkFBNkIsRUFBRTswQkFNbkYsV0FBVyxTQUFDLGlCQUFpQjs4QkFnQjdCLFdBQVcsU0FBQyxhQUFhO3dCQWV6QixTQUFTLFNBQUMsT0FBTzt5QkFDakIsU0FBUyxTQUFDLFNBQVM7NEJBQ25CLFNBQVMsU0FBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcixcbiAgICBTaW1wbGVDaGFuZ2UsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi9jb3JlL3RvdWNoJztcbmltcG9ydCB7IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL25hdmlnYXRpb24tZHJhd2VyLmRpcmVjdGl2ZXMnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIE5hdmlnYXRpb24gRHJhd2VyKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL25hdmRyYXdlci5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYSBjb2xsYXBzaWJsZSBzaWRlIG5hdmlnYXRpb24gY29udGFpbmVyIGNvbW1vbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgTmF2YmFyLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LW5hdi1kcmF3ZXIgaWQ9XCJuYXZpZ2F0aW9uXCIgW2lzT3Blbl09XCJ0cnVlXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXI+XG4gKiAgICAgPG5hdj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gW2lzSGVhZGVyXT1cInRydWVcIj5FbWFpbDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPkluYm94PC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+RGVsZXRlZDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPlNlbnQ8L3NwYW4+XG4gKiAgICAgPC9uYXY+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2lneC1uYXYtZHJhd2VyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtbmF2LWRyYXdlcicsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgI2RlZmF1bHRJdGVtc1RlbXBsYXRlPlxuICAgIDxkaXYgaWd4RHJhd2VySXRlbSBbaXNIZWFkZXJdPVwidHJ1ZVwiPk5hdmlnYXRpb24gRHJhd2VyPC9kaXY+XG4gICAgPGRpdiBpZ3hEcmF3ZXJJdGVtPiBTdGFydCBieSBhZGRpbmc8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IDxjb2RlPiZsdDtuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXImZ3Q7PC9jb2RlPiA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IEFuZCBzb21lIGl0ZW1zIGluc2lkZSA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IFN0eWxlIHdpdGggaWd4RHJhd2VySXRlbSA8L2Rpdj5cbiAgICA8ZGl2IGlneERyYXdlckl0ZW0+IGFuZCBpZ3hSaXBwbGUgZGlyZWN0aXZlczwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPGRpdiBbaGlkZGVuXT1cInBpblwiXG4gICAgY2xhc3M9XCJpZ3gtbmF2LWRyYXdlcl9fb3ZlcmxheVwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19vdmVybGF5LS1oaWRkZW5dPVwiIWlzT3BlblwiXG4gICAgKGNsaWNrKT1cImNsb3NlKClcIiAjb3ZlcmxheT5cbjwvZGl2PlxuPGFzaWRlIHJvbGU9XCJuYXZpZ2F0aW9uXCJcbiAgICBjbGFzcz1cImlneC1uYXYtZHJhd2VyX19hc2lkZVwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tY29sbGFwc2VkXT1cIiFtaW5pVGVtcGxhdGUgJiYgIWlzT3BlblwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tbWluaV09XCJtaW5pVGVtcGxhdGUgJiYgIWlzT3BlblwiXG4gICAgW2NsYXNzLmlneC1uYXYtZHJhd2VyX19hc2lkZS0tbm9ybWFsXT1cIiFtaW5pVGVtcGxhdGUgfHwgaXNPcGVuXCJcbiAgICBbY2xhc3MuaWd4LW5hdi1kcmF3ZXJfX2FzaWRlLS1waW5uZWRdPVwicGluXCJcbiAgICBbY2xhc3MuaWd4LW5hdi1kcmF3ZXJfX2FzaWRlLS1yaWdodF09XCJwb3NpdGlvbiA9PSAncmlnaHQnXCIgI2FzaWRlPlxuXG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlIHx8IGRlZmF1bHRJdGVtc1RlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG48L2FzaWRlPlxuPGRpdiBjbGFzcz1cImlneC1uYXYtZHJhd2VyX19zdHlsZS1kdW1teVwiICNkdW1teT48L2Rpdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4TmF2aWdhdGlvbkRyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzXG4gICAgSVRvZ2dsZVZpZXcsXG4gICAgT25Jbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uQ2hhbmdlcyB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcHVibGljIGNzc0NsYXNzID0gJ2lneC1uYXYtZHJhd2VyJztcblxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbXlOYXZEcmF3ZXJJZCA9IHRoaXMubmF2ZHJhd2VyLmlkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIGlkPSduYXZkcmF3ZXInPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKSBwdWJsaWMgaWQgPSBgaWd4LW5hdi1kcmF3ZXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gQ2FuIGJlIFwibGVmdFwiKGRlZmF1bHQpIG9yIFwicmlnaHRcIi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbXlOYXZEcmF3ZXJQb3NpdGlvbiA9IHRoaXMubmF2ZHJhd2VyLnBvc2l0aW9uO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3Bvc2l0aW9uXT1cIidsZWZ0J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgdXNlIG9mIHRvdWNoIGdlc3R1cmVzIHRvIG1hbmlwdWxhdGUgdGhlIGRyYXdlcjpcbiAgICAgKiAtIHN3aXBlL3BhbiBmcm9tIGVkZ2UgdG8gb3Blbiwgc3dpcGUtdG9nZ2xlIGFuZCBwYW4tZHJhZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgZ2VzdHVyZXNFbmFibGVkID0gdGhpcy5uYXZkcmF3ZXIuZW5hYmxlR2VzdHVyZXM7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbZW5hYmxlR2VzdHVyZXNdPSd0cnVlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBlbmFibGVHZXN0dXJlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgZHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJJc09wZW4gPSB0aGlzLm5hdmRyYXdlci5pc09wZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbaXNPcGVuXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGlzT3BlbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwaW5uZWQgdGhlIGRyYXdlciBpcyByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgaW5zdGVhZCBvZiBzaXR0aW5nIGFib3ZlIGNvbnRlbnQuXG4gICAgICogTWF5IHJlcXVpcmUgYWRkaXRpb25hbCBsYXlvdXQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNQaW5uZWQgPSB0aGlzLm5hdmRyYXdlci5waW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBkZXZpY2Ugd2lkdGggcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBwaW4gdG8gYmUgdG9nZ2xlZC5cbiAgICAgKiBEZWZhdWx0IGlzIDEwMjQsIGNhbiBiZSBzZXQgdG8gYSBmYWxzeSB2YWx1ZSB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlclBpblRyZXNob2xkID0gdGhpcy5uYXZkcmF3ZXIucGluVGhyZXNob2xkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3BpblRyZXNob2xkXT0nMTAyNCc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGluVGhyZXNob2xkID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlRWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIGRyYXdlciBpbiBpdHMgb3BlbiBzdGF0ZS4gRGVmYXVsdHMgdG8gXCIyODBweFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJXaWR0aCA9IHRoaXMubmF2ZHJhd2VyLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3dpZHRoXT1cIicyMjhweCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aCA9ICcyODBweCc7XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2MHB4LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJNaW5pV2lkdGggPSB0aGlzLm5hdmRyYXdlci5taW5pV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbbWluaVdpZHRoXT1cIiczNHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG1pbmlXaWR0aCA9ICc2MHB4JztcblxuICAgIC8qKlxuICAgICAqIFBpbm5lZCBzdGF0ZSBjaGFuZ2Ugb3V0cHV0IGZvciB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsocGluKV09J2lzUGlubmVkJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcGluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBhcyB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIChvcGVuaW5nKT0nb25PcGVuaW5nKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChvcGVuZWQpPSdvbk9wZW5lZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGFzIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NpbmcpPSdvbkNsb3NpbmcoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaGFzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NlZCk9J29uQ2xvc2VkKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX21pbmlUZW1wbGF0ZTogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbmlUZW1wbGF0ZSgpOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgc2V0IG1pbmlUZW1wbGF0ZSh2OiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh2ID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWluaVRlbXBsYXRlID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBjb250ZW50VGVtcGxhdGU6IElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleEJhc2lzJylcbiAgICBnZXQgZmxleFdpZHRoKCkge1xuICAgICAgICBpZiAoIXRoaXMucGluKSB7XG4gICAgICAgICAgICByZXR1cm4gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgdGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnMHB4JztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIGdldCBpc1Bpbm5lZFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gJiYgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICAnMScgOiAnMCc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2VzdHVyZXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3dpZHRoQ2FjaGU6IHsgd2lkdGg6IG51bWJlciwgbWluaVdpZHRoOiBudW1iZXIsIHdpbmRvd1dpZHRoOiBudW1iZXIgfSA9IHsgd2lkdGg6IG51bGwsIG1pbmlXaWR0aDogbnVsbCwgd2luZG93V2lkdGg6IG51bGwgfTtcbiAgICBwcml2YXRlIF9yZXNpemVPYnNlcnZlcjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgY3NzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7XG4gICAgICAgIGRyYXdlcjogJ2lneC1uYXYtZHJhd2VyX19hc2lkZScsXG4gICAgICAgIG1pbmk6ICdpZ3gtbmF2LWRyYXdlcl9fYXNpZGUtLW1pbmknLFxuICAgICAgICBvdmVybGF5OiAnaWd4LW5hdi1kcmF3ZXJfX292ZXJsYXknLFxuICAgICAgICBzdHlsZUR1bW15OiAnaWd4LW5hdi1kcmF3ZXJfX3N0eWxlLWR1bW15J1xuICAgIH07XG5cbiAgICBAVmlld0NoaWxkKCdhc2lkZScpIHByaXZhdGUgX2RyYXdlcjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JykgcHJpdmF0ZSBfb3ZlcmxheTogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdkdW1teScpIHByaXZhdGUgX3N0eWxlRHVtbXk6IEVsZW1lbnRSZWY7XG5cbiAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZHJhd2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd2VyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBvdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc3R5bGVEdW1teSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRHVtbXkubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogUGFuIGFuaW1hdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgcHJpdmF0ZSBfcGFubmluZyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3BhblN0YXJ0V2lkdGg6IG51bWJlcjtcbiAgICBwcml2YXRlIF9wYW5MaW1pdDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY2hhbmdlIHdpZHRoIG9yIHRyYW5zbGF0ZSB0aGUgZHJhd2VyIGZyb20gcGFuIGdlc3R1cmUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNBbmltYXRlV2lkdGgoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbiB8fCAhIXRoaXMubWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21heEVkZ2Vab25lID0gNTA7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdG91Y2ggZ2VzdHVyZXMgKHN3aXBlIGFuZCBwYW4pLlxuICAgICAqIERlZmF1bHRzIHRvIDUwIChpbiBweCkgYW5kIGlzIGV4dGVuZGVkIHRvIGF0IGxlYXN0IDExMCUgb2YgdGhlIG1pbmkgdGVtcGxhdGUgd2lkdGggaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4RWRnZVpvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhFZGdlWm9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBlY3RlZFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciBtaW5pIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkTWluaVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VzIG9wdGlvbmFsIG5hdmlnYXRpb24gc2VydmljZVxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3N0YXRlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgLy8gcHJpdmF0ZSBhbmltYXRlOiBBbmltYXRpb25CdWlsZGVyLCBUT0RPXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIsXG4gICAgICAgIHByaXZhdGUgX3RvdWNoTWFuYWdlcjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgLy8gRE9NIGFuZCBASW5wdXQoKS1zIGluaXRpYWxpemVkXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHRoaXMuaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyB3YWl0IGZvciB0ZW1wbGF0ZSBhbmQgbmctY29udGVudCB0byBiZSByZWFkeVxuICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIHRoaXMuY2hlY2tQaW5UaHJlc2hvbGQoKTtcblxuICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFRPRE86IGFwcGx5IHBsYXRmb3JtLXNhZmUgUnVsZXIgZnJvbSBodHRwOi8vcGxua3IuY28vZWRpdC84MW5XRHlyZVlNemt1bmloZlJnWD9wPXByZXZpZXdcbiAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY1MTUpLCBibG9ja2VkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5MDRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xuICAgICAgICAvLyBzaW1wbGUgc2V0dGluZ3MgY2FuIGNvbWUgZnJvbSBhdHRyaWJ1dGUgc2V0IChyYXRoZXIgdGhhbiBiaW5kaW5nKSwgbWFrZSBzdXJlIGJvb2xlYW4gcHJvcHMgYXJlIGNvbnZlcnRlZFxuICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVHZXN0dXJlcyAmJiBjaGFuZ2VzLmVuYWJsZUdlc3R1cmVzLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUdlc3R1cmVzID0gISEodGhpcy5lbmFibGVHZXN0dXJlcyAmJiB0aGlzLmVuYWJsZUdlc3R1cmVzLnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnBpbiAmJiBjaGFuZ2VzLnBpbi5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5waW4gPSAhISh0aGlzLnBpbiAmJiB0aGlzLnBpbi50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGluKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMud2lkdGggJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlcy53aWR0aC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMubWluaVdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aChjaGFuZ2VzLm1pbmlXaWR0aC5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVFZGdlWm9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBvcGVuIHN0YXRlIG9mIHRoZSBOYXZpZ2F0aW9uIERyYXdlci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIEhhcyBubyBlZmZlY3QgaWYgYWxyZWFkeSBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIub3BlbigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBvcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbmluZy5lbWl0KCk7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gYW5pbWF0ZSBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdmFyIGFuaW1hdGlvbkNzcyA9IHRoaXMuYW5pbWF0ZS5jc3MoKTtcbiAgICAgICAgLy8gICAgIGFuaW1hdGlvbkNzc1xuICAgICAgICAvLyAgICAgICAgIC5zZXRTdHlsZXMoeyd3aWR0aCc6JzUwcHgnfSwgeyd3aWR0aCc6JzQwMHB4J30pXG4gICAgICAgIC8vICAgICAgICAgLnN0YXJ0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgICAvLyAgICAgICAgIC5vbkNvbXBsZXRlKCgpID0+IGFuaW1hdGlvbkNzcy5zZXRUb1N0eWxlcyh7J3dpZHRoJzonYXV0byd9KS5zdGFydCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy53aWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NpbmcuZW1pdCgpO1xuXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy5taW5pVGVtcGxhdGUgPyB0aGlzLm1pbmlXaWR0aCA6ICcnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNldF9tYXhFZGdlWm9uZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21heEVkZ2Vab25lID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gW21pbmldIC0gUmVxdWVzdCBtaW5pIHdpZHRoIGluc3RlYWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RXhwZWN0ZWRXaWR0aChtaW5pPzogYm9vbGVhbik6IG51bWJlciB7XG4gICAgICAgIGlmIChtaW5pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLm1pbmlXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmICghdGhpcy5pc09wZW4pIHsgLy8gVGhpcyBXT04nVCB3b3JrIGR1ZSB0byB0cmFuc2l0aW9uIHRpbWluZ3MuLi5cbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzFdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MubWluaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLm1pbmksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUubWluaVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoQ2FjaGUud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS53aWR0aCA9IHRoaXMuc3R5bGVEdW1teS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoQ2FjaGUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFdpbmRvd1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5pbm5lcldpZHRoID4gMCkgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHNjcmVlbi53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXREcmF3ZXJXaWR0aCh3aWR0aDogc3RyaW5nKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgRHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RHJhd2VyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2VyLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5zdXJlRXZlbnRzKCkge1xuICAgICAgICAvLyBzZXQgbGlzdGVuZXJzIGZvciBzd2lwZS9wYW4gb25seSBpZiBuZWVkZWQsIGJ1dCBqdXN0IG9uY2VcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2VzdHVyZXMgJiYgIXRoaXMucGluICYmICF0aGlzLl9nZXN0dXJlc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAvLyBCdWlsdC1pbiBtYW5hZ2VyIGhhbmRsZXIoTDIwODg3KSBjYXVzZXMgZW5kbGVzcyBsb29wIGFuZCBtYXggc3RhY2sgZXhjZXB0aW9uLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjk5M1xuICAgICAgICAgICAgLy8gVXNlIG91cnMgZm9yIG5vdyAodW50aWwgYmV0YS4xMCk6XG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJzd2lwZVwiLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdzd2lwZScsIHRoaXMuc3dpcGUpO1xuICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInBhbnN0YXJ0XCIsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwicGFuXCIsIHRoaXMucGFuKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5zdGFydCcsIHRoaXMucGFuc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3Bhbm1vdmUnLCB0aGlzLnBhbik7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFuZW5kJywgdGhpcy5wYW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTUwKSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUVkZ2Vab25lKCkge1xuICAgICAgICBsZXQgbWF4VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heEVkZ2Vab25lLCB0aGlzLmdldEV4cGVjdGVkV2lkdGgodHJ1ZSkgKiAxLjEpO1xuICAgICAgICAgICAgdGhpcy5zZXRfbWF4RWRnZVpvbmUobWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjaGVja1BpblRocmVzaG9sZCA9IChldnQ/OiBFdmVudCkgPT4ge1xuICAgICAgICBsZXQgd2luZG93V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgd2luZG93V2lkdGggPSB0aGlzLmdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgICAgICBpZiAoZXZ0ICYmIHRoaXMuX3dpZHRoQ2FjaGUud2luZG93V2lkdGggPT09IHdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS53aW5kb3dXaWR0aCA9IHdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBpbiAmJiB3aW5kb3dXaWR0aCA+PSB0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbkNoYW5nZS5lbWl0KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBpbiAmJiB3aW5kb3dXaWR0aCA8IHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbkNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3dpcGUgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBDb3VsZCBhbHNvIGZvcmNlIGlucHV0IHR5cGU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MTA4MDUyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVHZXN0dXJlcyB8fCBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbW1lckpTIHN3aXBlIGlzIGhvcml6b250YWwtb25seSBieSBkZWZhdWx0LCBkb24ndCBjaGVjayBkZWx0YVlcbiAgICAgICAgbGV0IGRlbHRhWDtcbiAgICAgICAgbGV0IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyB3aGVuIG9uIHRoZSByaWdodCB1c2UgaW52ZXJzZSBvZiBkZWx0YVhcbiAgICAgICAgICAgIGRlbHRhWCA9IC1ldnQuZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuZ2V0V2luZG93V2lkdGgoKSAtIChldnQuY2VudGVyLnggKyBldnQuZGlzdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBldnQuY2VudGVyLnggLSBldnQuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBhY2NlcHQgY2xvc2luZyBzd2lwZSAoaWdub3JpbmcgbWluRWRnZVpvbmUpIHdoZW4gdGhlIGRyYXdlciBpcyBleHBhbmRlZDpcbiAgICAgICAgaWYgKCh0aGlzLmlzT3BlbiAmJiBkZWx0YVggPCAwKSB8fFxuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZGVsdGFYIGZyb20gdGhlIGVkZ2U6XG4gICAgICAgICAgICAoZGVsdGFYID4gMCAmJiBzdGFydFBvc2l0aW9uIDwgdGhpcy5tYXhFZGdlWm9uZSkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbnN0YXJ0ID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHsgLy8gVE9ETzogdGVzdCBjb2RlXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVHZXN0dXJlcyB8fCB0aGlzLnBpbiB8fCBldnQucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IHRoaXMuZ2V0V2luZG93V2lkdGgoKSAtIChldnQuY2VudGVyLnggKyBldnQuZGlzdGFuY2UpXG4gICAgICAgICAgICA6IGV2dC5jZW50ZXIueCAtIGV2dC5kaXN0YW5jZTtcblxuICAgICAgICAvLyBjYWNoZSB3aWR0aCBkdXJpbmcgYW5pbWF0aW9uLCBmbGFnIHRvIGFsbG93IGZ1cnRoZXIgaGFuZGxpbmdcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuIHx8IChzdGFydFBvc2l0aW9uIDwgdGhpcy5tYXhFZGdlWm9uZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcGFuU3RhcnRXaWR0aCA9IHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCghdGhpcy5pc09wZW4pO1xuICAgICAgICAgICAgdGhpcy5fcGFuTGltaXQgPSB0aGlzLmdldEV4cGVjdGVkV2lkdGgodGhpcy5pc09wZW4pO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLm92ZXJsYXksICdwYW5uaW5nJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLmRyYXdlciwgJ3Bhbm5pbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgLy8gVE9ETzogaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gICAgICAgIC8vIGdldCBhY3R1YWwgZGVsdGEgKG5vdCB0b3RhbCBzZXNzaW9uIG9uZSkgZnJvbSBldmVudD9cbiAgICAgICAgLy8gcGFuIFdJTEwgYWxzbyBmaXJlIGFmdGVyIGEgZnVsbCBzd2lwZSwgb25seSByZXNpemUgb24gZmxhZ1xuICAgICAgICBpZiAoIXRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodDogYm9vbGVhbiA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgICAgIC8vIHdoZW4gb24gdGhlIHJpZ2h0IHVzZSBpbnZlcnNlIG9mIGRlbHRhWFxuICAgICAgICBjb25zdCBkZWx0YVggPSByaWdodCA/IC1ldnQuZGVsdGFYIDogZXZ0LmRlbHRhWDtcbiAgICAgICAgbGV0IHZpc2libGVXaWR0aDtcbiAgICAgICAgbGV0IG5ld1g7XG4gICAgICAgIGxldCBwZXJjZW50O1xuXG4gICAgICAgIHZpc2libGVXaWR0aCA9IHRoaXMuX3BhblN0YXJ0V2lkdGggKyBkZWx0YVg7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZVdpZHRoIGhpdHMgbGltaXQgLSBzdG9wIGFuaW1hdGluZ1xuICAgICAgICAgICAgaWYgKHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5MaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICh2aXNpYmxlV2lkdGggLSB0aGlzLl9wYW5MaW1pdCkgLyAodGhpcy5fcGFuU3RhcnRXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuU3RhcnRXaWR0aDtcbiAgICAgICAgICAgICAgICBuZXdYID0gZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgZGVsdGFYID4gMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmxlV2lkdGggaGl0cyBsaW1pdCAtIHN0b3AgYW5pbWF0aW5nXG4gICAgICAgICAgICBpZiAodmlzaWJsZVdpZHRoID49IHRoaXMuX3BhbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZpc2libGVXaWR0aCAtIHRoaXMuX3BhblN0YXJ0V2lkdGgpIC8gKHRoaXMuX3BhbkxpbWl0IC0gdGhpcy5fcGFuU3RhcnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgbmV3WCA9IHZpc2libGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHZpc2libGVXaWR0aCAvIHRoaXMuX3BhbkxpbWl0O1xuICAgICAgICAgICAgICAgIG5ld1ggPSAodGhpcy5fcGFuTGltaXQgLSB2aXNpYmxlV2lkdGgpICogKHJpZ2h0ID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0WFNpemUobmV3WCwgcGVyY2VudC50b1ByZWNpc2lvbigyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbkVuZCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gLWV2dC5kZWx0YVggOiBldnQuZGVsdGFYO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVdpZHRoOiBudW1iZXIgPSB0aGlzLl9wYW5TdGFydFdpZHRoICsgZGVsdGFYO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBhbigpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwYW4gYnJvdWdodCB0aGUgZHJhd2VyIHRvIDUwJVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA8PSB0aGlzLl9wYW5TdGFydFdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNPcGVuICYmIHZpc2libGVXaWR0aCA+PSB0aGlzLl9wYW5MaW1pdCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhblN0YXJ0V2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldFBhbigpIHtcbiAgICAgICAgdGhpcy5fcGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKiBzdHlsZXMgZmFpbCB0byBhcHBseSB3aGVuIHNldCBvbiBwYXJlbnQgZHVlIHRvIGV4dHJhIGF0dHJpYnV0ZXMsIHByb2IgbmcgYnVnICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMub3ZlcmxheSwgJ3Bhbm5pbmcnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuZHJhd2VyLCAncGFubmluZycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRYU2l6ZSgwLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb3Igd2lkdGggaW4gY2FzZSB0aGUgZHJhd2VyIGRvZXNuJ3QgY2hhbmdlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB4IHRoZSBudW1iZXIgcGl4ZWxzIHRvIHRyYW5zbGF0ZSBvbiB0aGUgWCBheGlzIG9yIHRoZSB3aWR0aCB0byBzZXQuIDAgd2lkdGggd2lsbCBjbGVhciB0aGUgc3R5bGUgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gb3BhY2l0eSBvcHRpb25hbCB2YWx1ZSB0byBhcHBseSB0byB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0WFNpemUoeDogbnVtYmVyLCBvcGFjaXR5Pzogc3RyaW5nKSB7XG4gICAgICAgIC8vIEFuZ3VsYXIgcG9seWZpbGxzIHBhdGNoZXMgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgYnV0IHN3aXRjaCB0byBEb21BZGFwdGVyIEFQSSAoVE9ETylcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgJ3dpZHRoJywgeCA/IE1hdGguYWJzKHgpICsgJ3B4JyA6ICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd0cmFuc2Zvcm0nLCB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJycpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICAgICAgICAgICAgICAgICAgICB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMub3ZlcmxheSwgJ29wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVPcGVuZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMub3BlbmVkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUNsb3NlZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdCgpO1xuICAgIH1cbn1cbiJdfQ==