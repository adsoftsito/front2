import { IFilteringState } from './filtering-state.interface';
import { ISortingState } from './sorting-state.interface';
import { IGroupByResult } from './sorting-strategy';
import { IPagingState } from './paging-state.interface';
import { IDataState } from './data-state.interface';
import { IGroupByKey } from './groupby-expand-state.interface';
import { IGroupByRecord } from './groupby-record.interface';
import { IGroupingState } from './groupby-state.interface';
import { Transaction, HierarchicalTransaction } from '../services';
import { ITreeGridRecord } from '../grids/tree-grid/tree-grid.interfaces';
/**
 * @hidden
 */
export declare enum DataType {
    String = "string",
    Number = "number",
    Boolean = "boolean",
    Date = "date",
}
/**
 * @hidden
 */
export declare class DataUtil {
    static mergeDefaultProperties(target: object, defaults: object): object;
    static sort<T>(data: T[], state: ISortingState): T[];
    static hierarchicalSort(hierarchicalData: ITreeGridRecord[], state: ISortingState, parent: ITreeGridRecord): ITreeGridRecord[];
    static cloneTreeGridRecord(hierarchicalRecord: ITreeGridRecord): ITreeGridRecord;
    static group<T>(data: T[], state: IGroupingState): IGroupByResult;
    static restoreGroups(groupData: IGroupByResult, state: IGroupingState, groupsRecords?: any[]): any[];
    private static restoreGroupsRecursive(groupData, level, depth, expansion, defaultExpanded, groupsRecords);
    static page<T>(data: T[], state: IPagingState): T[];
    static filter<T>(data: T[], state: IFilteringState): T[];
    static process<T>(data: T[], state: IDataState): T[];
    static getHierarchy(gRow: IGroupByRecord): Array<IGroupByKey>;
    static isHierarchyMatch(h1: Array<IGroupByKey>, h2: Array<IGroupByKey>): boolean;
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     */
    static mergeTransactions<T>(data: T[], transactions: Transaction[], primaryKey?: any): T[];
    /** @experimental @hidden */
    static mergeHierarchicalTransactions(data: any[], transactions: HierarchicalTransaction[], childDataKey: any, primaryKey?: any, parentKey?: any): any[];
}
