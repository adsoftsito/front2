/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Pipe } from '@angular/core';
import { cloneArray } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { GridBaseAPIService } from '../api.service';
/**
 * @hidden
 */
export class IgxGridSortingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expressions, id, pipeTrigger) {
        let /** @type {?} */ strategy;
        const /** @type {?} */ state = { expressions: [], strategy };
        state.expressions = this.gridAPI.get(id).sortingExpressions;
        if (!state.expressions.length) {
            return collection;
        }
        // DataUtil.sort needs a sorting strategy to start with, so it makes sense to start with the strategy from the first expression
        // sorting-strategy.ts, sortDataRecursive method then takes care and use the corresponding strategy for each expression
        strategy = expressions[0].strategy;
        state.strategy = strategy;
        return DataUtil.sort(cloneArray(collection), state);
    }
}
IgxGridSortingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridSort',
                pure: true
            },] },
];
/** @nocollapse */
IgxGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService, },
];
function IgxGridSortingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridSortingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridSortingPipe.ctorParameters;
    /** @type {?} */
    IgxGridSortingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
export class IgxGridPreGroupingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expression, expansion, defaultExpanded, id, pipeTrigger) {
        const /** @type {?} */ state = { expressions: [], expansion: [], defaultExpanded };
        const /** @type {?} */ grid = this.gridAPI.get(id);
        state.expressions = grid.groupingExpressions;
        if (!state.expressions.length) {
            return {
                data: collection,
                metadata: collection
            };
        }
        state.expansion = grid.groupingExpansionState;
        state.defaultExpanded = grid.groupsExpanded;
        return DataUtil.group(cloneArray(collection), state);
    }
}
IgxGridPreGroupingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridPreGroupBy',
                pure: true
            },] },
];
/** @nocollapse */
IgxGridPreGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService, },
];
function IgxGridPreGroupingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPreGroupingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPreGroupingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPreGroupingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
export class IgxGridPostGroupingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        const /** @type {?} */ state = { expressions: [], expansion: [], defaultExpanded };
        const /** @type {?} */ grid = this.gridAPI.get(id);
        state.expressions = grid.groupingExpressions;
        if (!state.expressions.length) {
            return collection.data;
        }
        state.expansion = grid.groupingExpansionState;
        state.defaultExpanded = grid.groupsExpanded;
        return DataUtil.restoreGroups({
            data: cloneArray(collection.data),
            metadata: cloneArray(collection.metadata)
        }, state, groupsRecords);
    }
}
IgxGridPostGroupingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridPostGroupBy',
                pure: true
            },] },
];
/** @nocollapse */
IgxGridPostGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService, },
];
function IgxGridPostGroupingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPostGroupingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPostGroupingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPostGroupingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
export class IgxGridPagingPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.get(id).paging) {
            return collection;
        }
        const /** @type {?} */ state = {
            index: page,
            recordsPerPage: perPage
        };
        const /** @type {?} */ result = {
            data: DataUtil.page(cloneArray(collection.data), state),
            metadata: DataUtil.page(cloneArray(collection.metadata), state)
        };
        this.gridAPI.get(id).pagingState = state;
        return result;
    }
}
IgxGridPagingPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridPaging',
                pure: true
            },] },
];
/** @nocollapse */
IgxGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService, },
];
function IgxGridPagingPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridPagingPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridPagingPipe.ctorParameters;
    /** @type {?} */
    IgxGridPagingPipe.prototype.gridAPI;
}
/**
 * @hidden
 */
export class IgxGridFilteringPipe {
    /**
     * @param {?} gridAPI
     */
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    transform(collection, expressionsTree, id, pipeTrigger) {
        const /** @type {?} */ grid = this.gridAPI.get(id);
        const /** @type {?} */ state = { expressionsTree: expressionsTree };
        if (!state.expressionsTree ||
            !state.expressionsTree.filteringOperands ||
            state.expressionsTree.filteringOperands.length === 0) {
            return collection;
        }
        const /** @type {?} */ result = DataUtil.filter(cloneArray(collection), state);
        grid.filteredData = result;
        return result;
    }
}
IgxGridFilteringPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gridFiltering',
                pure: true
            },] },
];
/** @nocollapse */
IgxGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService, },
];
function IgxGridFilteringPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridFilteringPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridFilteringPipe.ctorParameters;
    /** @type {?} */
    IgxGridFilteringPipe.prototype.gridAPI;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC9ncmlkLnBpcGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDOUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBTzNELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBVXBELE1BQU07Ozs7SUFFRixZQUFvQixPQUFpRDtRQUFqRCxZQUFPLEdBQVAsT0FBTyxDQUEwQztLQUFLOzs7Ozs7OztJQUVuRSxTQUFTLENBQUMsVUFBaUIsRUFBRSxXQUFzRCxFQUN0RixFQUFVLEVBQUUsV0FBbUI7UUFDL0IscUJBQUksUUFBMEIsQ0FBQztRQUMvQix1QkFBTSxLQUFLLEdBQUcsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO1FBQzVDLEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsa0JBQWtCLENBQUM7UUFFNUQsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDNUIsTUFBTSxDQUFDLFVBQVUsQ0FBQztTQUNyQjs7O1FBSUQsUUFBUSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDbkMsS0FBSyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFFMUIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7O1lBdkIzRCxJQUFJLFNBQUM7Z0JBQ0Ys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S0FBSyxDQUFDLGVBQWU7WUFDdEIsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLGlCQUFpQjtZQUN4QyxLQUFLLENBQUMsZUFBZSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxVQUFVLENBQUM7U0FDckI7UUFFRCx1QkFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7UUFDM0IsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7OztZQXJCckIsSUFBSSxTQUFDO2dCQUNGLElBQUksRUFBRSxlQUFlO2dCQUNyQixJQUFJLEVBQUUsSUFBSTthQUNiOzs7O1lBOUlRLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNsb25lQXJyYXkgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERhdGFVdGlsIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQgeyBJR3JvdXBCeUV4cGFuZFN0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlc3VsdCwgSVNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWV4cHJlc3Npb25zLXRyZWUnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JpZENvbXBvbmVudCB9IGZyb20gJy4vZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi9ncmlkLWFwaS5zZXJ2aWNlJztcblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdncmlkU29ydCcsXG4gICAgcHVyZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkU29ydGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50PikgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IGFueVtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uIHwgSVNvcnRpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIGlkOiBzdHJpbmcsIHBpcGVUcmlnZ2VyOiBudW1iZXIpOiBhbnlbXSB7XG4gICAgICAgIGxldCBzdHJhdGVneTogSVNvcnRpbmdTdHJhdGVneTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGV4cHJlc3Npb25zOiBbXSwgc3RyYXRlZ3kgfTtcbiAgICAgICAgc3RhdGUuZXhwcmVzc2lvbnMgPSB0aGlzLmdyaWRBUEkuZ2V0KGlkKS5zb3J0aW5nRXhwcmVzc2lvbnM7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGF0YVV0aWwuc29ydCBuZWVkcyBhIHNvcnRpbmcgc3RyYXRlZ3kgdG8gc3RhcnQgd2l0aCwgc28gaXQgbWFrZXMgc2Vuc2UgdG8gc3RhcnQgd2l0aCB0aGUgc3RyYXRlZ3kgZnJvbSB0aGUgZmlyc3QgZXhwcmVzc2lvblxuICAgICAgICAvLyBzb3J0aW5nLXN0cmF0ZWd5LnRzLCBzb3J0RGF0YVJlY3Vyc2l2ZSBtZXRob2QgdGhlbiB0YWtlcyBjYXJlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgc3RyYXRlZ3kgZm9yIGVhY2ggZXhwcmVzc2lvblxuICAgICAgICBzdHJhdGVneSA9IGV4cHJlc3Npb25zWzBdLnN0cmF0ZWd5O1xuICAgICAgICBzdGF0ZS5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuXG4gICAgICAgIHJldHVybiBEYXRhVXRpbC5zb3J0KGNsb25lQXJyYXkoY29sbGVjdGlvbiksIHN0YXRlKTtcbiAgICB9XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZ3JpZFByZUdyb3VwQnknLFxuICAgIHB1cmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZFByZUdyb3VwaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHByaXZhdGUgZ3JpZEFQSTogSWd4R3JpZEFQSVNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQ+KSB7XG4gICAgICAgIHRoaXMuZ3JpZEFQSSA9IDxJZ3hHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogYW55W10sIGV4cHJlc3Npb246IElTb3J0aW5nRXhwcmVzc2lvbiB8IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBleHBhbnNpb246IElHcm91cEJ5RXhwYW5kU3RhdGUgfCBJR3JvdXBCeUV4cGFuZFN0YXRlW10sIGRlZmF1bHRFeHBhbmRlZDogYm9vbGVhbixcbiAgICAgICAgaWQ6IHN0cmluZywgcGlwZVRyaWdnZXI6IG51bWJlcik6IElHcm91cEJ5UmVzdWx0IHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgZXhwcmVzc2lvbnM6IFtdLCBleHBhbnNpb246IFtdLCBkZWZhdWx0RXhwYW5kZWQgfTtcbiAgICAgICAgY29uc3QgZ3JpZDogSWd4R3JpZENvbXBvbmVudCA9IHRoaXMuZ3JpZEFQSS5nZXQoaWQpO1xuICAgICAgICBzdGF0ZS5leHByZXNzaW9ucyA9IGdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucztcblxuICAgICAgICBpZiAoIXN0YXRlLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBjb2xsZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZXhwYW5zaW9uID0gZ3JpZC5ncm91cGluZ0V4cGFuc2lvblN0YXRlO1xuICAgICAgICBzdGF0ZS5kZWZhdWx0RXhwYW5kZWQgPSBncmlkLmdyb3Vwc0V4cGFuZGVkO1xuXG4gICAgICAgIHJldHVybiBEYXRhVXRpbC5ncm91cChjbG9uZUFycmF5KGNvbGxlY3Rpb24pLCBzdGF0ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2dyaWRQb3N0R3JvdXBCeScsXG4gICAgcHVyZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkUG9zdEdyb3VwaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHByaXZhdGUgZ3JpZEFQSTogSWd4R3JpZEFQSVNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VDb21wb25lbnQ+KSB7XG4gICAgICAgIHRoaXMuZ3JpZEFQSSA9IDxJZ3hHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogSUdyb3VwQnlSZXN1bHQsIGV4cHJlc3Npb246IElTb3J0aW5nRXhwcmVzc2lvbiB8IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBleHBhbnNpb246IElHcm91cEJ5RXhwYW5kU3RhdGUgfCBJR3JvdXBCeUV4cGFuZFN0YXRlW10sIGRlZmF1bHRFeHBhbmRlZDogYm9vbGVhbixcbiAgICAgICAgaWQ6IHN0cmluZywgZ3JvdXBzUmVjb3JkczogYW55W10sIHBpcGVUcmlnZ2VyOiBudW1iZXIpOiBhbnlbXSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGV4cHJlc3Npb25zOiBbXSwgZXhwYW5zaW9uOiBbXSwgZGVmYXVsdEV4cGFuZGVkIH07XG4gICAgICAgIGNvbnN0IGdyaWQ6IElneEdyaWRDb21wb25lbnQgPSB0aGlzLmdyaWRBUEkuZ2V0KGlkKTtcbiAgICAgICAgc3RhdGUuZXhwcmVzc2lvbnMgPSBncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5leHBhbnNpb24gPSBncmlkLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGU7XG4gICAgICAgIHN0YXRlLmRlZmF1bHRFeHBhbmRlZCA9IGdyaWQuZ3JvdXBzRXhwYW5kZWQ7XG5cbiAgICAgICAgcmV0dXJuIERhdGFVdGlsLnJlc3RvcmVHcm91cHMoe1xuICAgICAgICAgICAgZGF0YTogY2xvbmVBcnJheShjb2xsZWN0aW9uLmRhdGEpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNsb25lQXJyYXkoY29sbGVjdGlvbi5tZXRhZGF0YSlcbiAgICAgICAgfSwgc3RhdGUsIGdyb3Vwc1JlY29yZHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdncmlkUGFnaW5nJyxcbiAgICBwdXJlOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRQYWdpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4pIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBJR3JvdXBCeVJlc3VsdCwgcGFnZSA9IDAsIHBlclBhZ2UgPSAxNSwgaWQ6IHN0cmluZywgcGlwZVRyaWdnZXI6IG51bWJlcik6IElHcm91cEJ5UmVzdWx0IHtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JpZEFQSS5nZXQoaWQpLnBhZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBwYWdlLFxuICAgICAgICAgICAgcmVjb3Jkc1BlclBhZ2U6IHBlclBhZ2VcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0YTogRGF0YVV0aWwucGFnZShjbG9uZUFycmF5KGNvbGxlY3Rpb24uZGF0YSksIHN0YXRlKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBEYXRhVXRpbC5wYWdlKGNsb25lQXJyYXkoY29sbGVjdGlvbi5tZXRhZGF0YSksIHN0YXRlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWRBUEkuZ2V0KGlkKS5wYWdpbmdTdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdncmlkRmlsdGVyaW5nJyxcbiAgICBwdXJlOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRGaWx0ZXJpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4pIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgZXhwcmVzc2lvbnNUcmVlOiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLFxuICAgICAgICBpZDogc3RyaW5nLCBwaXBlVHJpZ2dlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdyaWRBUEkuZ2V0KGlkKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IGV4cHJlc3Npb25zVHJlZTogZXhwcmVzc2lvbnNUcmVlIH07XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5leHByZXNzaW9uc1RyZWUgfHxcbiAgICAgICAgICAgICFzdGF0ZS5leHByZXNzaW9uc1RyZWUuZmlsdGVyaW5nT3BlcmFuZHMgfHxcbiAgICAgICAgICAgIHN0YXRlLmV4cHJlc3Npb25zVHJlZS5maWx0ZXJpbmdPcGVyYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRGF0YVV0aWwuZmlsdGVyKGNsb25lQXJyYXkoY29sbGVjdGlvbiksIHN0YXRlKTtcbiAgICAgICAgZ3JpZC5maWx0ZXJlZERhdGEgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl19