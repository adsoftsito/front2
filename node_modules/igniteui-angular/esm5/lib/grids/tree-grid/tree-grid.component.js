/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ElementRef, HostBinding, Input, IterableDiffers, ViewContainerRef, Output, EventEmitter, Inject, NgZone, forwardRef } from '@angular/core';
import { IgxSelectionAPIService } from '../../core/selection';
import { IgxTreeGridAPIService } from './tree-grid-api.service';
import { IgxGridBaseComponent, IgxGridTransaction } from '../grid-base.component';
import { GridBaseAPIService } from '../api.service';
import { TransactionType } from '../../services/transaction/transaction';
import { DOCUMENT } from '@angular/common';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { mergeObjects } from '../../core/utils';
import { IgxHierarchicalTransactionService } from '../../services';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
var /** @type {?} */ NEXT_ID = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
var IgxTreeGridComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxTreeGridComponent, _super);
    function IgxTreeGridComponent(gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService) {
        var _this = _super.call(this, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService) || this;
        _this._transactions = _transactions;
        _this.document = document;
        _this._id = "igx-tree-grid-" + NEXT_ID++;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.processedRecords = new Map();
        /**
         * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="employeeID" [foreignKey]="parentID" cascadeOnDelete="false" [autoGenerate]="true">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.cascadeOnDelete = true;
        _this._expansionDepth = Infinity;
        _this._expansionStates = new Map();
        /**
         * Emitted when the expanded state of a row gets changed.
         * ```typescript
         * rowToggle(event: IRowToggleEventArgs){
         *  // the id of the row
         *  const rowID = event.rowID;
         *  // the new expansion state
         *  const newExpandedState = event.expanded;
         *  // the original event that triggered onRowToggle
         *  const originalEvent = event.event;
         *  // whether the event should be cancelled
         *  event.cancel = true;
         * }
         * ```
         * ```html
         * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.onRowToggle = new EventEmitter();
        _this._gridAPI = /** @type {?} */ (gridAPI);
        return _this;
    }
    Object.defineProperty(IgxTreeGridComponent.prototype, "id", {
        get: /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._id !== value) {
                var /** @type {?} */ oldId = this._id;
                this._id = value;
                this._gridAPI.reset(oldId, this._id);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "transactions", {
        /**
         * Get transactions service for the grid.
         * @experimental @hidden
         */
        get: /**
         * Get transactions service for the grid.
         * \@experimental \@hidden
         * @return {?}
         */
        function () {
            return this._transactions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "expansionDepth", {
        get: /**
         * An \@Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
         * set to `Infinity` which means all levels would be expanded.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="employees" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._expansionDepth;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expansionDepth = value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "expansionStates", {
        get: /**
         * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
         * ```typescript
         * const expansionStates = this.grid.expansionStates;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._expansionStates;
        },
        set: /**
         * Sets a list of key-value pairs [row ID, expansion state].
         * ```typescript
         * const states = new Map<any, boolean>();
         * states.set(1, true);
         * this.grid.expansionStates = states;
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expansionStates = this.cloneMap(value);
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "hasSummarizedColumns", {
        /**
         * @hidden
         * Returns if the `IgxTreeGridComponent` has summarized columns.
         * ```typescript
         * const summarizedGrid = this.grid.hasSummarizedColumns;
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * @hidden
         * Returns if the `IgxTreeGridComponent` has summarized columns.
         * ```typescript
         * const summarizedGrid = this.grid.hasSummarizedColumns;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} mapIn
     * @return {?}
     */
    IgxTreeGridComponent.prototype.cloneMap = /**
     * @param {?} mapIn
     * @return {?}
     */
    function (mapIn) {
        var /** @type {?} */ mapCloned = new Map();
        mapIn.forEach(function (value, key, mapObj) {
            mapCloned.set(key, value);
        });
        return mapCloned;
    };
    /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.expandRow = /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.expand_row(this.id, rowID);
    };
    /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.collapseRow = /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.collapse_row(this.id, rowID);
    };
    /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.toggleRow = /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.toggle_row_expansion(this.id, rowID);
    };
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    IgxTreeGridComponent.prototype.expandAll = /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    function () {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    };
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    IgxTreeGridComponent.prototype.collapseAll = /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    function () {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    };
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    IgxTreeGridComponent.prototype.addRow = /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    function (data, parentRowID) {
        if (parentRowID) {
            var /** @type {?} */ parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                _super.prototype.addRow.call(this, data);
            }
            else {
                var /** @type {?} */ parentData = parentRecord.data;
                var /** @type {?} */ childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    var /** @type {?} */ rowId = this.primaryKey ? data[this.primaryKey] : data;
                    this.transactions.add(/** @type {?} */ ({
                        id: rowId,
                        parentId: parentRowID,
                        newValue: data,
                        type: TransactionType.ADD
                    }), null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data: data });
                this._pipeTrigger++;
                this.cdr.markForCheck();
                this.refreshSearch();
            }
        }
        else {
            _super.prototype.addRow.call(this, data);
        }
    };
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    IgxTreeGridComponent.prototype.deleteRowById = /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        if (this.transactions.enabled && this.cascadeOnDelete) {
            this.transactions.startPending();
        }
        _super.prototype.deleteRowById.call(this, rowId);
        if (this.transactions.enabled && this.cascadeOnDelete) {
            this.transactions.endPending(true);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    IgxTreeGridComponent.prototype.deleteRowFromData = /**
     * @hidden
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (rowID, index) {
        var _this = this;
        if (this.primaryKey && this.foreignKey) {
            _super.prototype.deleteRowFromData.call(this, rowID, index);
            if (this.cascadeOnDelete) {
                var /** @type {?} */ treeRecord = this.records.get(rowID);
                if (treeRecord && treeRecord.children && treeRecord.children.length > 0) {
                    for (var /** @type {?} */ i = 0; i < treeRecord.children.length; i++) {
                        var /** @type {?} */ child = treeRecord.children[i];
                        _super.prototype.deleteRowById.call(this, child.rowID);
                    }
                }
            }
        }
        else {
            var /** @type {?} */ record = this.records.get(rowID);
            var /** @type {?} */ childData = record.parent ? record.parent.data[this.childDataKey] : this.data;
            index = this.primaryKey ? childData.map(function (c) { return c[_this.primaryKey]; }).indexOf(rowID) :
                childData.indexOf(rowID);
            if (this.transactions.enabled) {
                this.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    parentId: record.parent ? record.parent.rowID : undefined
                }, this.data);
            }
            else {
                childData.splice(index, 1);
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.calcMaxSummaryHeight = /**
     * @hidden
     * @return {?}
     */
    function () {
        return 0;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.getExportExcel = /**
     * @hidden
     * @return {?}
     */
    function () {
        return false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.getExportCsv = /**
     * @hidden
     * @return {?}
     */
    function () {
        return false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.restoreHighlight = /**
     * @hidden
     * @return {?}
     */
    function () {
    };
    /**
     * @hidden
     * @param {?=} updateActiveInfo
     * @return {?}
     */
    IgxTreeGridComponent.prototype.refreshSearch = /**
     * @hidden
     * @param {?=} updateActiveInfo
     * @return {?}
     */
    function (updateActiveInfo) {
        return 0;
    };
    /**
     * @hidden
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    IgxTreeGridComponent.prototype.findNext = /**
     * @hidden
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        return 0;
    };
    /**
     * @hidden
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    IgxTreeGridComponent.prototype.findPrev = /**
     * @hidden
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        return 0;
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.clearSearch = /**
     * @hidden
     * @return {?}
     */
    function () {
    };
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    IgxTreeGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        return {
            $implicit: rowData,
            templateID: 'dataRow'
        };
    };
    /**
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    IgxTreeGridComponent.prototype.writeToData = /**
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    function (rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    };
    IgxTreeGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-tree-grid',
                    template: "<igx-grid-toolbar role=\"rowgroup\" [style.width.px]=\"calcWidth\" *ngIf=\"shouldShowToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div class=\"igx-grid__thead\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n    <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-container *ngIf=\"rowSelectable\">\n            <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer>\n                <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"pinnedColumns.length > 0\">\n            <ng-template ngFor let-col [ngForOf]=\"onlyTopLevel(pinnedColumns)\">\n                <div class=\"igx-grid__thead-item igx-grid__th--pinned\">\n                    <igx-grid-header [igxColumnMovingDrag]=\"col\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"col\" [gridID]=\"id\"\n                        [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]=\"col.width\"></igx-grid-header>\n                    <igx-grid-filtering-cell *ngIf=\"allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col\"\n                        [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>\n                </div>\n            </ng-template>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"onlyTopLevel(unpinnedColumns)\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n            [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #headerContainer>\n            <div class=\"igx-grid__thead-item\">\n                <igx-grid-header [igxColumnMovingDrag]=\"col\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"col\" [gridID]=\"id\" [column]=\"col\"\n                    [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width'></igx-grid-header>\n                <igx-grid-filtering-cell *ngIf=\"allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col\"\n                    [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>\n            </div>\n        </ng-template>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    </div>\n    <igx-grid-filtering-row *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n</div>\n\n<div class=\"igx-grid__tbody\" role=\"rowgroup\" [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)' (wheel)=\"wheelHandler()\">\n    <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n    <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-template igxGridFor let-rowData [igxGridForOf]=\"data \n\t| treeGridTransaction:id:pipeTrigger\t\n\t| treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n    | treeGridFiltering:filteringExpressionsTree:id:pipeTrigger \n    | treeGridSorting:sortingExpressions:id:pipeTrigger\n    | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n    | treeGridPaging:page:perPage:id:pipeTrigger\"\n\n    let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"\n    [igxForContainerSize]='calcHeight' [igxForItemSize]=\"rowHeight\" #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n        <ng-template #record_template>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n     \n        <ng-container *igxTemplateOutlet=\"record_template; context: getContext(rowData) \"></ng-container>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.width.px]='calcWidth' #tfoot>\n    <!-- Hiding until summaries are implemented for TreeGrid -->\n    <!-- <div *ngIf=\"hasSummarizedColumns\" class=\"igx-grid__summaries\" [style.height.px]=\"summariesHeight\" role=\"row\" #summaries>\n        <ng-container *ngIf=\"summariesMargin\">\n            <div\n            class=\"igx-grid__summaries-patch\"\n            [style.min-width.px]=\"summariesMargin\"\n            [style.flex-basis.px]=\"summariesMargin\"\n            ></div>\n        </ng-container>\n        <ng-container *ngIf=\"pinnedColumns.length > 0\">\n            <igx-grid-summary [gridID]=\"id\" *ngFor=\"let col of notGroups(pinnedColumns)\"  [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width'></igx-grid-summary>\n        </ng-container>\n        <ng-template igxGridFor let-col [igxGridForOf]=\"notGroups(unpinnedColumns)\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\" [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #summaryContainer>\n            <igx-grid-summary [gridID]=\"id\" [column]=\"col\" [style.min-width.px]=\"col.width\" [style.flex-basis.px]='col.width'></igx-grid-summary>\n        </ng-template>\n    </div> -->\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\"> \n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditTemplate >\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">You have {{ rowChangesCount }} changes in this row</span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n            <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n        </div>\n    </div>\n</ng-template>\n\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                    providers: [IgxGridNavigationService, { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxTreeGridComponent; }) }, IgxFilteringService]
                },] },
    ];
    /** @nocollapse */
    IgxTreeGridComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService, },
        { type: IgxSelectionAPIService, },
        { type: IgxHierarchicalTransactionService, decorators: [{ type: Inject, args: [IgxGridTransaction,] },] },
        { type: ElementRef, },
        { type: NgZone, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: ChangeDetectorRef, },
        { type: ComponentFactoryResolver, },
        { type: IterableDiffers, },
        { type: ViewContainerRef, },
        { type: IgxGridNavigationService, },
        { type: IgxFilteringService, },
    ]; };
    IgxTreeGridComponent.propDecorators = {
        "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
        "childDataKey": [{ type: Input },],
        "foreignKey": [{ type: Input },],
        "cascadeOnDelete": [{ type: Input },],
        "expansionDepth": [{ type: Input },],
        "expansionStates": [{ type: Input },],
        "onRowToggle": [{ type: Output },],
    };
    return IgxTreeGridComponent;
}(IgxGridBaseComponent));
export { IgxTreeGridComponent };
function IgxTreeGridComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxTreeGridComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxTreeGridComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxTreeGridComponent.propDecorators;
    /** @type {?} */
    IgxTreeGridComponent.prototype._id;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridComponent.prototype.flatData;
    /**
     * Returns an array of the root level `ITreeGridRecord`s.
     * ```typescript
     * // gets the root record with index=2
     * const states = this.grid.rootRecords[2];
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.rootRecords;
    /**
     * Returns a map of all `ITreeGridRecord`s.
     * ```typescript
     * // gets the record with primaryKey=2
     * const states = this.grid.records.get(2);
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.records;
    /**
     * Returns an array of processed (filtered and sorted) root `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed root record with index=2
     * const states = this.grid.processedRootRecords[2];
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.processedRootRecords;
    /**
     * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed record with primaryKey=2
     * const states = this.grid.processedRecords.get(2);
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.processedRecords;
    /**
     * An \@Input property that sets the child data key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="employees" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.childDataKey;
    /**
     * An \@Input property that sets the foreign key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="employeeID" [foreignKey]="parentID" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.foreignKey;
    /**
     * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
     * By default it is set to true and deletes all children along with the parent.
     * ```html
     * <igx-tree-grid [data]="employeeData" [primaryKey]="employeeID" [foreignKey]="parentID" cascadeOnDelete="false" [autoGenerate]="true">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.cascadeOnDelete;
    /** @type {?} */
    IgxTreeGridComponent.prototype._expansionDepth;
    /** @type {?} */
    IgxTreeGridComponent.prototype._expansionStates;
    /**
     * Emitted when the expanded state of a row gets changed.
     * ```typescript
     * rowToggle(event: IRowToggleEventArgs){
     *  // the id of the row
     *  const rowID = event.rowID;
     *  // the new expansion state
     *  const newExpandedState = event.expanded;
     *  // the original event that triggered onRowToggle
     *  const originalEvent = event.event;
     *  // whether the event should be cancelled
     *  event.cancel = true;
     * }
     * ```
     * ```html
     * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.onRowToggle;
    /** @type {?} */
    IgxTreeGridComponent.prototype._gridAPI;
    /** @type {?} */
    IgxTreeGridComponent.prototype._transactions;
    /** @type {?} */
    IgxTreeGridComponent.prototype.document;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1Qsd0JBQXdCLEVBQ3hCLFVBQVUsRUFDVixXQUFXLEVBQ1gsS0FBSyxFQUNMLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsTUFBTSxFQUNOLFlBQVksRUFDWixNQUFNLEVBQ04sTUFBTSxFQUNOLFVBQVUsRUFDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNsRixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUdwRCxPQUFPLEVBQWtFLGVBQWUsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ3pJLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGlDQUFpQyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFMUUscUJBQUksT0FBTyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0swQixnREFBb0I7SUFvTDFELDhCQUNJLE9BQWlELEVBQ2pELFNBQWlD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SGxCLHNCQUFzQjtnQkFVdEIsaUNBQWlDLHVCQThWakMsTUFBTSxTQUFDLGtCQUFrQjtnQkFuWDlCLFVBQVU7Z0JBUVYsTUFBTTtnREE4V0QsTUFBTSxTQUFDLFFBQVE7Z0JBelhwQixpQkFBaUI7Z0JBRWpCLHdCQUF3QjtnQkFJeEIsZUFBZTtnQkFDZixnQkFBZ0I7Z0JBZVgsd0JBQXdCO2dCQUd4QixtQkFBbUI7Ozt1QkFnTHZCLFdBQVcsU0FBQyxTQUFTLGNBQ3JCLEtBQUs7aUNBd0VMLEtBQUs7K0JBVUwsS0FBSztvQ0FZTCxLQUFLO21DQWFMLEtBQUs7b0NBbUJMLEtBQUs7Z0NBc0NMLE1BQU07OytCQWhYWDtFQWlNMEMsb0JBQW9CO1NBQWpELG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBFbGVtZW50UmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5qZWN0LFxuICAgIE5nWm9uZSxcbiAgICBmb3J3YXJkUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4U2VsZWN0aW9uQVBJU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvc2VsZWN0aW9uJztcbmltcG9ydCB7IElneFRyZWVHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlQ29tcG9uZW50LCBJZ3hHcmlkVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElUcmVlR3JpZFJlY29yZCB9IGZyb20gJy4vdHJlZS1ncmlkLmludGVyZmFjZXMnO1xuaW1wb3J0IHsgSVJvd1RvZ2dsZUV2ZW50QXJncyB9IGZyb20gJy4vdHJlZS1ncmlkLmludGVyZmFjZXMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TZXJ2aWNlLCBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiwgSGllcmFyY2hpY2FsU3RhdGUsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IG1lcmdlT2JqZWN0cyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4SGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xuaW1wb3J0IHsgSWd4RmlsdGVyaW5nU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlcmluZy9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcblxubGV0IE5FWFRfSUQgPSAwO1xuXG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIFRyZWUgR3JpZCoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBUcmVlIEdyaWQgZGlzcGxheXMgYW5kIG1hbmlwdWxhdGVzIGhpZXJhcmNoaWNhbCBkYXRhIHdpdGggY29uc2lzdGVudCBzY2hlbWEgZm9ybWF0dGVkIGFzIGEgdGFibGUgYW5kXG4gKiBwcm92aWRlcyBmZWF0dXJlcyBzdWNoIGFzIHNvcnRpbmcsIGZpbHRlcmluZywgZWRpdGluZywgY29sdW1uIHBpbm5pbmcsIHBhZ2luZywgY29sdW1uIG1vdmluZyBhbmQgaGlkaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBwcmltYXJ5S2V5PVwiZW1wbG95ZWVJRFwiIGZvcmVpZ25LZXk9XCJQSURcIiBhdXRvR2VuZXJhdGU9XCJmYWxzZVwiPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImZpcnN0XCIgaGVhZGVyPVwiRmlyc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJsYXN0XCIgaGVhZGVyPVwiTGFzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cInJvbGVcIiBoZWFkZXI9XCJSb2xlXCI+PC9pZ3gtY29sdW1uPlxuICogPC9pZ3gtdHJlZS1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZCcsXG4gICAgdGVtcGxhdGU6IGA8aWd4LWdyaWQtdG9vbGJhciByb2xlPVwicm93Z3JvdXBcIiBbc3R5bGUud2lkdGgucHhdPVwiY2FsY1dpZHRoXCIgKm5nSWY9XCJzaG91bGRTaG93VG9vbGJhclwiIFtncmlkSURdPVwiaWRcIiBbZGlzcGxheURlbnNpdHldPVwiZGlzcGxheURlbnNpdHlcIiAjdG9vbGJhcj5cbjwvaWd4LWdyaWQtdG9vbGJhcj5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0UGFnZXIgbGV0LWFwaT5cbiAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCJhcGkuaXNGaXJzdFBhZ2VcIiAoY2xpY2spPVwiYXBpLnBhZ2luYXRlKDApXCIgaWd4QnV0dG9uPVwiaWNvblwiIGlneFJpcHBsZSBpZ3hSaXBwbGVDZW50ZXJlZD1cInRydWVcIj5cbiAgICAgICAgPGlneC1pY29uIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmZpcnN0X3BhZ2U8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImFwaS5pc0ZpcnN0UGFnZVwiIChjbGljayk9XCJhcGkucHJldmlvdXNQYWdlKClcIiBpZ3hCdXR0b249XCJpY29uXCIgaWd4UmlwcGxlIGlneFJpcHBsZUNlbnRlcmVkPVwidHJ1ZVwiPlxuICAgICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+Y2hldnJvbl9sZWZ0PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8c3Bhbj57eyBhcGkucGFnZSArIDEgfX0gb2Yge3sgYXBpLnRvdGFsUGFnZXMgfX08L3NwYW4+XG4gICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiYXBpLmlzTGFzdFBhZ2VcIiAoY2xpY2spPVwiYXBpLm5leHRQYWdlKClcIiBpZ3hSaXBwbGUgaWd4UmlwcGxlQ2VudGVyZWQ9XCJ0cnVlXCIgaWd4QnV0dG9uPVwiaWNvblwiPlxuICAgICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+Y2hldnJvbl9yaWdodDwvaWd4LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImFwaS5pc0xhc3RQYWdlXCIgKGNsaWNrKT1cImFwaS5wYWdpbmF0ZShhcGkudG90YWxQYWdlcyAtIDEpXCIgaWd4QnV0dG9uPVwiaWNvblwiIGlneFJpcHBsZSBpZ3hSaXBwbGVDZW50ZXJlZD1cInRydWVcIj5cbiAgICAgICAgPGlneC1pY29uIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmxhc3RfcGFnZTwvaWd4LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPHNlbGVjdCBzdHlsZT1cIm1hcmdpbi1sZWZ0OiAxcmVtO1wiIChjaGFuZ2UpPVwiYXBpLnBlclBhZ2UgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXCI+XG4gICAgICAgICAgICA8b3B0aW9uIFt2YWx1ZV09XCJ2YWxcIiBbc2VsZWN0ZWRdPVwiYXBpLnBlclBhZ2UgPT0gdmFsXCIgKm5nRm9yPVwibGV0IHZhbCBvZiBbNSwgMTAsIDE1LCAyNSwgNTAsIDEwMCwgNTAwXVwiPnt7IHZhbCB9fTwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuPC9uZy10ZW1wbGF0ZT5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX190aGVhZFwiIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgI3RoZWFkUm93PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJcIiBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnIHJvbGU9XCJyb3dcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoIDw9IDBcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1sZWZ0XCI+PC9zcGFuPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW4gJiYgcGlubmVkQ29sdW1ucy5sZW5ndGggPiAwXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJsZWZ0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcGlubmVkXCIgW3N0eWxlLmxlZnQucHhdPVwicGlubmVkV2lkdGhcIj48L3NwYW4+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyb3dTZWxlY3RhYmxlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2NieC1zZWxlY3Rpb25cIiAjaGVhZGVyQ2hlY2tib3hDb250YWluZXI+XG4gICAgICAgICAgICAgICAgPGlneC1jaGVja2JveCBbY2hlY2tlZF09XCJhbGxSb3dzU2VsZWN0ZWRcIiAoY2hhbmdlKT1cIm9uSGVhZGVyQ2hlY2tib3hDbGljaygkZXZlbnQpXCIgZGlzYWJsZVJpcHBsZT1cInRydWVcIiBbYXJpYS1sYWJlbF09XCJoZWFkZXJDaGVja2JveEFyaWFMYWJlbFwiICNoZWFkZXJDaGVja2JveD48L2lneC1jaGVja2JveD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2wgW25nRm9yT2ZdPVwib25seVRvcExldmVsKHBpbm5lZENvbHVtbnMpXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190aGVhZC1pdGVtIGlneC1ncmlkX190aC0tcGlubmVkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtZ3JpZC1oZWFkZXIgW2lneENvbHVtbk1vdmluZ0RyYWddPVwiY29sXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJjb2xcIiBbZ3JpZElEXT1cImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJjb2wud2lkdGhcIj48L2lneC1ncmlkLWhlYWRlcj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWZpbHRlcmluZy1jZWxsICpuZ0lmPVwiYWxsb3dGaWx0ZXJpbmcgJiYgIWNvbC5jb2x1bW5Hcm91cCAmJiBmaWx0ZXJpbmdTZXJ2aWNlLmZpbHRlcmVkQ29sdW1uICE9PSBjb2xcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2xcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT0nY29sLndpZHRoJyBbc3R5bGUubWF4LXdpZHRoLnB4XT0nY29sLndpZHRoJz48L2lneC1ncmlkLWZpbHRlcmluZy1jZWxsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1jb2wgW2lneEdyaWRGb3JPZl09XCJvbmx5VG9wTGV2ZWwodW5waW5uZWRDb2x1bW5zKVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cInBhcmVudFZpcnREaXJcIlxuICAgICAgICAgICAgW2lneEZvckNvbnRhaW5lclNpemVdPSd1bnBpbm5lZFdpZHRoJyBbaWd4Rm9yVHJhY2tCeV09J3RyYWNrQ29sdW1uQ2hhbmdlcycgI2hlYWRlckNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGhlYWQtaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxpZ3gtZ3JpZC1oZWFkZXIgW2lneENvbHVtbk1vdmluZ0RyYWddPVwiY29sXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJjb2xcIiBbZ3JpZElEXT1cImlkXCIgW2NvbHVtbl09XCJjb2xcIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUubWluLXdpZHRoLnB4XT1cImNvbC53aWR0aFwiIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT0nY29sLndpZHRoJz48L2lneC1ncmlkLWhlYWRlcj5cbiAgICAgICAgICAgICAgICA8aWd4LWdyaWQtZmlsdGVyaW5nLWNlbGwgKm5nSWY9XCJhbGxvd0ZpbHRlcmluZyAmJiAhY29sLmNvbHVtbkdyb3VwICYmIGZpbHRlcmluZ1NlcnZpY2UuZmlsdGVyZWRDb2x1bW4gIT09IGNvbFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09J2NvbC53aWR0aCcgW3N0eWxlLm1heC13aWR0aC5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1maWx0ZXJpbmctY2VsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW5cIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cInJpZ2h0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcmlnaHRcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGlneC1ncmlkLWZpbHRlcmluZy1yb3cgKm5nSWY9XCJmaWx0ZXJpbmdTZXJ2aWNlLmlzRmlsdGVyUm93VmlzaWJsZVwiIFtjb2x1bW5dPVwiZmlsdGVyaW5nU2VydmljZS5maWx0ZXJlZENvbHVtblwiPjwvaWd4LWdyaWQtZmlsdGVyaW5nLXJvdz5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5XCIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLmhlaWdodC5weF09J2NhbGNIZWlnaHQnIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgI3Rib2R5IChzY3JvbGwpPSdzY3JvbGxIYW5kbGVyKCRldmVudCknICh3aGVlbCk9XCJ3aGVlbEhhbmRsZXIoKVwiPlxuICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtbiAmJiBwaW5uZWRDb2x1bW5zLmxlbmd0aCA8PSAwXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJsZWZ0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctbGVmdFwiPjwvc3Bhbj5cbiAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW4gJiYgcGlubmVkQ29sdW1ucy5sZW5ndGggPiAwXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJsZWZ0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcGlubmVkXCIgW3N0eWxlLmxlZnQucHhdPVwicGlubmVkV2lkdGhcIj48L3NwYW4+XG4gICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgbGV0LXJvd0RhdGEgW2lneEdyaWRGb3JPZl09XCJkYXRhIFxuXHR8IHRyZWVHcmlkVHJhbnNhY3Rpb246aWQ6cGlwZVRyaWdnZXJcdFxuXHR8IHRyZWVHcmlkSGllcmFyY2hpemluZzpwcmltYXJ5S2V5OmZvcmVpZ25LZXk6Y2hpbGREYXRhS2V5OmlkOnBpcGVUcmlnZ2VyXG4gICAgfCB0cmVlR3JpZEZpbHRlcmluZzpmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6aWQ6cGlwZVRyaWdnZXIgXG4gICAgfCB0cmVlR3JpZFNvcnRpbmc6c29ydGluZ0V4cHJlc3Npb25zOmlkOnBpcGVUcmlnZ2VyXG4gICAgfCB0cmVlR3JpZEZsYXR0ZW5pbmc6aWQ6ZXhwYW5zaW9uRGVwdGg6ZXhwYW5zaW9uU3RhdGVzOnBpcGVUcmlnZ2VyXG4gICAgfCB0cmVlR3JpZFBhZ2luZzpwYWdlOnBlclBhZ2U6aWQ6cGlwZVRyaWdnZXJcIlxuXG4gICAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ3ZlcnRpY2FsJ1wiXG4gICAgW2lneEZvckNvbnRhaW5lclNpemVdPSdjYWxjSGVpZ2h0JyBbaWd4Rm9ySXRlbVNpemVdPVwicm93SGVpZ2h0XCIgI3ZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyIChvbkNodW5rUHJlbG9hZCk9XCJkYXRhTG9hZGluZygkZXZlbnQpXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcmVjb3JkX3RlbXBsYXRlPlxuICAgICAgICAgICAgPGlneC10cmVlLWdyaWQtcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbdHJlZVJvd109XCJyb3dEYXRhXCIgI3Jvdz5cbiAgICAgICAgICAgIDwvaWd4LXRyZWUtZ3JpZC1yb3c+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgIFxuICAgICAgICA8bmctY29udGFpbmVyICppZ3hUZW1wbGF0ZU91dGxldD1cInJlY29yZF90ZW1wbGF0ZTsgY29udGV4dDogZ2V0Q29udGV4dChyb3dEYXRhKSBcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtblwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwicmlnaHRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1yaWdodFwiPjwvc3Bhbj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Jvdy1lZGl0aW5nLW91dGxldFwiIGlneE92ZXJsYXlPdXRsZXQgI2lneFJvd0VkaXRpbmdPdmVybGF5T3V0bGV0PjwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGZvb3RcIiByb2xlPVwicm93Z3JvdXBcIiBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnICN0Zm9vdD5cbiAgICA8IS0tIEhpZGluZyB1bnRpbCBzdW1tYXJpZXMgYXJlIGltcGxlbWVudGVkIGZvciBUcmVlR3JpZCAtLT5cbiAgICA8IS0tIDxkaXYgKm5nSWY9XCJoYXNTdW1tYXJpemVkQ29sdW1uc1wiIGNsYXNzPVwiaWd4LWdyaWRfX3N1bW1hcmllc1wiIFtzdHlsZS5oZWlnaHQucHhdPVwic3VtbWFyaWVzSGVpZ2h0XCIgcm9sZT1cInJvd1wiICNzdW1tYXJpZXM+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzdW1tYXJpZXNNYXJnaW5cIj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3N1bW1hcmllcy1wYXRjaFwiXG4gICAgICAgICAgICBbc3R5bGUubWluLXdpZHRoLnB4XT1cInN1bW1hcmllc01hcmdpblwiXG4gICAgICAgICAgICBbc3R5bGUuZmxleC1iYXNpcy5weF09XCJzdW1tYXJpZXNNYXJnaW5cIlxuICAgICAgICAgICAgPjwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgPGlneC1ncmlkLXN1bW1hcnkgW2dyaWRJRF09XCJpZFwiICpuZ0Zvcj1cImxldCBjb2wgb2Ygbm90R3JvdXBzKHBpbm5lZENvbHVtbnMpXCIgIFtjb2x1bW5dPVwiY29sXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1zdW1tYXJ5PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgbGV0LWNvbCBbaWd4R3JpZEZvck9mXT1cIm5vdEdyb3Vwcyh1bnBpbm5lZENvbHVtbnMpXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwicGFyZW50VmlydERpclwiIFtpZ3hGb3JDb250YWluZXJTaXplXT0ndW5waW5uZWRXaWR0aCcgW2lneEZvclRyYWNrQnldPSd0cmFja0NvbHVtbkNoYW5nZXMnICNzdW1tYXJ5Q29udGFpbmVyPlxuICAgICAgICAgICAgPGlneC1ncmlkLXN1bW1hcnkgW2dyaWRJRF09XCJpZFwiIFtjb2x1bW5dPVwiY29sXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1zdW1tYXJ5PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PiAtLT5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbFwiIFtzdHlsZS5oZWlnaHRdPVwiJzE4cHgnXCIgI3NjciBbaGlkZGVuXT1cInVucGlubmVkV2lkdGggLSB0b3RhbFdpZHRoID49IDBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1zdGFydFwiIFtzdHlsZS53aWR0aC5weF09J3Bpbm5lZFdpZHRoJyBbaGlkZGVuXT1cInBpbm5lZFdpZHRoID09PSAwXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtbWFpblwiIFtzdHlsZS53aWR0aC5weF09J3VucGlubmVkV2lkdGgnPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBbaWd4R3JpZEZvck9mXT0nW10nICNzY3JvbGxDb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1wYWdpbmF0b3IgaWd4LWdyaWQtcGFnaW5hdG9yXCIgKm5nSWY9XCJwYWdpbmdcIiAjcGFnaW5hdG9yPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwYWdpbmF0aW9uVGVtcGxhdGUgPyBwYWdpbmF0aW9uVGVtcGxhdGUgOiBkZWZhdWx0UGFnZXI7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB0aGlzIH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2VtcHR5RmlsdGVyZWRHcmlkPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LW1lc3NhZ2VcIj57e2VtcHR5RmlsdGVyZWRHcmlkTWVzc2FnZX19PC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0RW1wdHlHcmlkPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LW1lc3NhZ2VcIj57e2VtcHR5R3JpZE1lc3NhZ2V9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgKm5nSWY9XCJyb3dFZGl0YWJsZVwiIGlneFRvZ2dsZT5cbiAgICA8ZGl2IFtjbGFzc05hbWVdPVwiYmFubmVyQ2xhc3NcIj4gXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dFZGl0Q29udGFpbmVyOyBjb250ZXh0OiB7IHJvd0NoYW5nZXNDb3VudDogcm93Q2hhbmdlc0NvdW50LCBlbmRFZGl0OiBlbmRFZGl0LmJpbmQodGhpcykgfVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9kaXY+XG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0VGVtcGxhdGUgPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19tZXNzYWdlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWJhbm5lcl9fdGV4dFwiPllvdSBoYXZlIHt7IHJvd0NoYW5nZXNDb3VudCB9fSBjaGFuZ2VzIGluIHRoaXMgcm93PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19hY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19yb3dcIj5cbiAgICAgICAgICAgIDxidXR0b24gaWd4QnV0dG9uIGlneFJvd0VkaXRUYWJTdG9wIChjbGljayk9XCJlbmRFZGl0KGZhbHNlLCAkZXZlbnQpXCI+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCAoY2xpY2spPVwiZW5kRWRpdCh0cnVlLCAkZXZlbnQpXCI+RG9uZTwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fb3V0bGV0XCIgI2lneEZpbHRlcmluZ092ZXJsYXlPdXRsZXQgaWd4T3ZlcmxheU91dGxldD48L2Rpdj5cbmAsXG4gICAgcHJvdmlkZXJzOiBbIElneEdyaWROYXZpZ2F0aW9uU2VydmljZSwgeyBwcm92aWRlOiBHcmlkQmFzZUFQSVNlcnZpY2UsIHVzZUNsYXNzOiBJZ3hUcmVlR3JpZEFQSVNlcnZpY2UgfSxcbiAgICAgICAgeyBwcm92aWRlOiBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSWd4VHJlZUdyaWRDb21wb25lbnQpIH0sIElneEZpbHRlcmluZ1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VDb21wb25lbnQge1xuICAgIHByaXZhdGUgX2lkID0gYGlneC10cmVlLWdyaWQtJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtpZF09XCInaWd4LXRyZWUtZ3JpZC0xJ1wiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkSWQgPSB0aGlzLl9pZDtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9ncmlkQVBJLnJlc2V0KG9sZElkLCB0aGlzLl9pZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHJhbnNhY3Rpb25zIHNlcnZpY2UgZm9yIHRoZSBncmlkLlxuICAgICAqIEBleHBlcmltZW50YWwgQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbnMoKTogSWd4SGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlPEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLCBIaWVyYXJjaGljYWxTdGF0ZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIGZsYXREYXRhOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvb3QgbGV2ZWwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyByb290UmVjb3JkczogSVRyZWVHcmlkUmVjb3JkW107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHJlY29yZCB3aXRoIHByaW1hcnlLZXk9MlxuICAgICAqIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ3JpZC5yZWNvcmRzLmdldCgyKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHJlY29yZHM6IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4gPSBuZXcgTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPigpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9jZXNzZWQgKGZpbHRlcmVkIGFuZCBzb3J0ZWQpIHJvb3QgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSBwcm9jZXNzZWQgcm9vdCByZWNvcmQgd2l0aCBpbmRleD0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnByb2Nlc3NlZFJvb3RSZWNvcmRzWzJdO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgcHJvY2Vzc2VkIChmaWx0ZXJlZCBhbmQgc29ydGVkKSBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHByb2Nlc3NlZCByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucHJvY2Vzc2VkUmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwcm9jZXNzZWRSZWNvcmRzOiBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+ID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGNoaWxkIGRhdGEga2V5IG9mIHRoZSBgSWd4VHJlZUdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cImVtcGxveWVlc1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2hpbGREYXRhS2V5O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cImVtcGxveWVlSURcIiBbZm9yZWlnbktleV09XCJwYXJlbnRJRFwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZm9yZWlnbktleTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSBpbmRpY2F0aW5nIHdoZXRoZXIgY2hpbGQgcmVjb3JkcyBzaG91bGQgYmUgZGVsZXRlZCB3aGVuIHRoZWlyIHBhcmVudCBnZXRzIGRlbGV0ZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZSBhbmQgZGVsZXRlcyBhbGwgY2hpbGRyZW4gYWxvbmcgd2l0aCB0aGUgcGFyZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCJlbXBsb3llZUlEXCIgW2ZvcmVpZ25LZXldPVwicGFyZW50SURcIiBjYXNjYWRlT25EZWxldGU9XCJmYWxzZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2FzY2FkZU9uRGVsZXRlID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cImVtcGxveWVlc1wiIGV4cGFuc2lvbkRlcHRoPVwiMVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGV4cGFuc2lvbkRlcHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25EZXB0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGV4cGFuc2lvbkRlcHRoKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZXhwYW5zaW9uU3RhdGVzOiAgTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGtleS12YWx1ZSBwYWlycyBbcm93IElELCBleHBhbnNpb24gc3RhdGVdLiBJbmNsdWRlcyBvbmx5IHN0YXRlcyB0aGF0IGRpZmZlciBmcm9tIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZXhwYW5zaW9uU3RhdGVzID0gdGhpcy5ncmlkLmV4cGFuc2lvblN0YXRlcztcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGV4cGFuc2lvblN0YXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvblN0YXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMgW3JvdyBJRCwgZXhwYW5zaW9uIHN0YXRlXS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICogc3RhdGVzLnNldCgxLCB0cnVlKTtcbiAgICAgKiB0aGlzLmdyaWQuZXhwYW5zaW9uU3RhdGVzID0gc3RhdGVzO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGV4cGFuc2lvblN0YXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25TdGF0ZXMgPSB0aGlzLmNsb25lTWFwKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgYSByb3cgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiByb3dUb2dnbGUoZXZlbnQ6IElSb3dUb2dnbGVFdmVudEFyZ3Mpe1xuICAgICAqICAvLyB0aGUgaWQgb2YgdGhlIHJvd1xuICAgICAqICBjb25zdCByb3dJRCA9IGV2ZW50LnJvd0lEO1xuICAgICAqICAvLyB0aGUgbmV3IGV4cGFuc2lvbiBzdGF0ZVxuICAgICAqICBjb25zdCBuZXdFeHBhbmRlZFN0YXRlID0gZXZlbnQuZXhwYW5kZWQ7XG4gICAgICogIC8vIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBvblJvd1RvZ2dsZVxuICAgICAqICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gZXZlbnQuZXZlbnQ7XG4gICAgICogIC8vIHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBjYW5jZWxsZWRcbiAgICAgKiAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIChvblJvd1RvZ2dsZSk9XCJyb3dUb2dnbGUoJGV2ZW50KVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uUm93VG9nZ2xlID0gbmV3IEV2ZW50RW1pdHRlcjxJUm93VG9nZ2xlRXZlbnRBcmdzPigpO1xuXG4gICAgcHJpdmF0ZSBfZ3JpZEFQSTogSWd4VHJlZUdyaWRBUElTZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudD4sXG4gICAgICAgIHNlbGVjdGlvbjogSWd4U2VsZWN0aW9uQVBJU2VydmljZSxcbiAgICAgICAgQEluamVjdChJZ3hHcmlkVHJhbnNhY3Rpb24pIHByb3RlY3RlZCBfdHJhbnNhY3Rpb25zOiBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2U8SGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sIEhpZXJhcmNoaWNhbFN0YXRlPixcbiAgICAgICAgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgem9uZTogTmdab25lLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQsXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgdmlld1JlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgbmF2aWdhdGlvbjogSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBmaWx0ZXJpbmdTZXJ2aWNlOiBJZ3hGaWx0ZXJpbmdTZXJ2aWNlKSB7XG4gICAgICAgICAgICBzdXBlcihncmlkQVBJLCBzZWxlY3Rpb24sIF90cmFuc2FjdGlvbnMsIGVsZW1lbnRSZWYsIHpvbmUsIGRvY3VtZW50LCBjZHIsIHJlc29sdmVyLCBkaWZmZXJzLCB2aWV3UmVmLCBuYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIGZpbHRlcmluZ1NlcnZpY2UpO1xuICAgICAgICB0aGlzLl9ncmlkQVBJID0gPElneFRyZWVHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4VHJlZUdyaWRDb21wb25lbnRgIGhhcyBzdW1tYXJpemVkIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHN1bW1hcml6ZWRHcmlkID0gdGhpcy5ncmlkLmhhc1N1bW1hcml6ZWRDb2x1bW5zO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGFzU3VtbWFyaXplZENvbHVtbnMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb25lTWFwKG1hcEluOiBNYXA8YW55LCBib29sZWFuPik6ICBNYXA8YW55LCBib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IG1hcENsb25lZDogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcblxuICAgICAgICBtYXBJbi5mb3JFYWNoKCh2YWx1ZTogYm9vbGVhbiwga2V5OiBhbnksIG1hcE9iajogTWFwPGFueSwgYm9vbGVhbj4pID0+IHtcblxuICAgICAgICAgIG1hcENsb25lZC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXBDbG9uZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgYElneFRyZWVHcmlkUm93Q29tcG9uZW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgcm93SUQuXG4gICAgICogQHBhcmFtIHJvd0lEIFRoZSBpZGVudGlmaWVyIG9mIHRoZSByb3cgdG8gYmUgZXhwYW5kZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5leHBhbmRSb3coMik7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRSb3cocm93SUQ6IGFueSkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmV4cGFuZF9yb3codGhpcy5pZCwgcm93SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyB0aGUgYElneFRyZWVHcmlkUm93Q29tcG9uZW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgcm93SUQuXG4gICAgICogQHBhcmFtIHJvd0lEIFRoZSBpZGVudGlmaWVyIG9mIHRoZSByb3cgdG8gYmUgY29sbGFwc2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY29sbGFwc2VSb3coMik7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBjb2xsYXBzZVJvdyhyb3dJRDogYW55KSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuY29sbGFwc2Vfcm93KHRoaXMuaWQsIHJvd0lEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgdGhlIGBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudGAgd2l0aCB0aGUgc3BlY2lmaWVkIHJvd0lELlxuICAgICAqIEBwYXJhbSByb3dJRCBUaGUgaWRlbnRpZmllciBvZiB0aGUgcm93IHRvIGJlIHRvZ2dsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC50b2dnbGVSb3coMik7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVSb3cocm93SUQ6IGFueSkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLnRvZ2dsZV9yb3dfZXhwYW5zaW9uKHRoaXMuaWQsIHJvd0lEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCByb3dzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZXhwYW5kQWxsKCk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCByb3dzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY29sbGFwc2VBbGwoKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGNvbGxhcHNlQWxsKCkge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25EZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgSWd4VHJlZUdyaWRSb3dDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGRhdGEuIElmIGEgcGFyZW50Um93SUQgaXMgbm90IHNwZWNpZmllZCwgdGhlIG5ld2x5IGNyZWF0ZWRcbiAgICAgKiByb3cgd291bGQgYmUgYWRkZWQgYXQgdGhlIHJvb3QgbGV2ZWwuIE90aGVyd2lzZSwgaXQgd291bGQgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiB0aGUgcm93IHdob3NlIHByaW1hcnlLZXkgbWF0Y2hlc1xuICAgICAqIHRoZSBzcGVjaWZpZWQgcGFyZW50Um93SUQuIElmIHRoZSBwYXJlbnRSb3dJRCBkb2VzIG5vdCBleGlzdCwgYW4gZXJyb3Igd291bGQgYmUgdGhyb3duLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCByZWNvcmQgPSB7XG4gICAgICogICAgIElEOiB0aGlzLmdyaWQuZGF0YVt0aGlzLmdyaWQxLmRhdGEubGVuZ3RoIC0gMV0uSUQgKyAxLFxuICAgICAqICAgICBOYW1lOiB0aGlzLm5ld1JlY29yZFxuICAgICAqIH07XG4gICAgICogdGhpcy5ncmlkLmFkZFJvdyhyZWNvcmQsIDEpOyAvLyBBZGRzIGEgbmV3IGNoaWxkIHJvdyB0byB0aGUgcm93IHdpdGggSUQ9MS5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBwYXJlbnRSb3dJRFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRSb3coZGF0YTogYW55LCBwYXJlbnRSb3dJRD86IGFueSkge1xuICAgICAgICBpZiAocGFyZW50Um93SUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJlY29yZCA9IHRoaXMucmVjb3Jkcy5nZXQocGFyZW50Um93SUQpO1xuXG4gICAgICAgICAgICBpZiAoIXBhcmVudFJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmVudCByb3cgSUQhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlLZXkgJiYgdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgICAgICAgZGF0YVt0aGlzLmZvcmVpZ25LZXldID0gcGFyZW50Um93SUQ7XG4gICAgICAgICAgICAgICAgc3VwZXIuYWRkUm93KGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnREYXRhID0gcGFyZW50UmVjb3JkLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSB0aGlzLmNoaWxkRGF0YUtleTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJZCA9IHRoaXMucHJpbWFyeUtleSA/IGRhdGFbdGhpcy5wcmltYXJ5S2V5XSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcm93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50Um93SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRyYW5zYWN0aW9uVHlwZS5BRERcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50RGF0YVtjaGlsZEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERhdGFbY2hpbGRLZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGF0YVtjaGlsZEtleV0ucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uUm93QWRkZWQuZW1pdCh7IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGlwZVRyaWdnZXIrKztcbiAgICAgICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFNlYXJjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYWRkUm93KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVSb3dCeUlkKHJvd0lkOiBhbnkpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb25zLmVuYWJsZWQgJiYgdGhpcy5jYXNjYWRlT25EZWxldGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLnN0YXJ0UGVuZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVsZXRlUm93QnlJZChyb3dJZCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb25zLmVuYWJsZWQgJiYgdGhpcy5jYXNjYWRlT25EZWxldGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmVuZFBlbmRpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlbGV0ZVJvd0Zyb21EYXRhKHJvd0lEOiBhbnksIGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgIGlmICh0aGlzLnByaW1hcnlLZXkgJiYgdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgICBzdXBlci5kZWxldGVSb3dGcm9tRGF0YShyb3dJRCwgaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jYXNjYWRlT25EZWxldGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlUmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyb3dJRCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVSZWNvcmQgJiYgdHJlZVJlY29yZC5jaGlsZHJlbiAmJiB0cmVlUmVjb3JkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlUmVjb3JkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRyZWVSZWNvcmQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlci5kZWxldGVSb3dCeUlkKGNoaWxkLnJvd0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyb3dJRCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZERhdGEgPSByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5kYXRhW3RoaXMuY2hpbGREYXRhS2V5XSA6IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wcmltYXJ5S2V5ID8gY2hpbGREYXRhLm1hcChjID0+IGNbdGhpcy5wcmltYXJ5S2V5XSkuaW5kZXhPZihyb3dJRCkgOlxuICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5pbmRleE9mKHJvd0lEKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJvd0lELFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuREVMRVRFLFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnJvd0lEIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FsY01heFN1bW1hcnlIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RXhwb3J0RXhjZWwoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEV4cG9ydENzdigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVzdG9yZUhpZ2hsaWdodCgpOiB2b2lkIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlZnJlc2hTZWFyY2godXBkYXRlQWN0aXZlSW5mbz86IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGZpbmROZXh0KHRleHQ6IHN0cmluZywgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW4sIGV4YWN0TWF0Y2g/OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBmaW5kUHJldih0ZXh0OiBzdHJpbmcsIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuLCBleGFjdE1hdGNoPzogYm9vbGVhbik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJTZWFyY2goKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgIHB1YmxpYyBnZXRDb250ZXh0KHJvd0RhdGEpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLFxuICAgICAgICAgICAgdGVtcGxhdGVJRDogJ2RhdGFSb3cnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHdyaXRlVG9EYXRhKHJvd0luZGV4OiBudW1iZXIsIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgbWVyZ2VPYmplY3RzKHRoaXMuZmxhdERhdGFbcm93SW5kZXhdLCB2YWx1ZSk7XG4gICAgfVxufVxuIl19