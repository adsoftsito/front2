/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, ElementRef, TemplateRef, NgZone, ChangeDetectorRef, ComponentFactoryResolver, IterableDiffers, ViewContainerRef, Inject, HostBinding, forwardRef } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseComponent, IgxGridTransaction } from '../grid-base.component';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxTextHighlightDirective } from '../../directives/text-highlight/text-highlight.directive';
import { IgxGroupByRowTemplateDirective } from './grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { DataUtil } from '../../data-operations/data-util';
import { IgxSelectionAPIService } from '../../core/selection';
import { DOCUMENT } from '@angular/common';
import { IgxGridSortingPipe } from './grid.pipes';
import { takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
let /** @type {?} */ NEXT_ID = 0;
/**
 * @record
 */
export function IGridFocusChangeEventArgs() { }
function IGridFocusChangeEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IGridFocusChangeEventArgs.prototype.groupRow;
}
/**
 * @record
 */
export function IGroupingDoneEventArgs() { }
function IGroupingDoneEventArgs_tsickle_Closure_declarations() {
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.expressions;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.groupedColumns;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.ungroupedColumns;
}
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
export class IgxGridComponent extends IgxGridBaseComponent {
    /**
     * @param {?} gridAPI
     * @param {?} selection
     * @param {?} _transactions
     * @param {?} elementRef
     * @param {?} zone
     * @param {?} document
     * @param {?} cdr
     * @param {?} resolver
     * @param {?} differs
     * @param {?} viewRef
     * @param {?} navigation
     * @param {?} filteringService
     */
    constructor(gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService) {
        super(gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService);
        this.document = document;
        this._id = `igx-grid-${NEXT_ID++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsRecords = [];
        /**
         * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.dropAreaMessage = 'Drag a column header and drop it here to group by that column.';
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.onGroupingDone = new EventEmitter();
        this.onFocusChange = new EventEmitter();
        this._gridAPI = /** @type {?} */ (gridAPI);
    }
    /**
     * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        if (this._id !== value) {
            const /** @type {?} */ oldId = this._id;
            this._id = value;
            this._gridAPI.reset(oldId, this._id);
        }
    }
    /**
     * Returns the group by state of the `IgxGridComponent`.
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    /**
     * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
     * event with the appropriate arguments.
     * ```typescript
     * this.grid.groupingExpressions = [{
     *     fieldName: "ID",
     *     dir: SortingDirection.Asc,
     *     ignoreCase: false
     * }];
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const /** @type {?} */ oldExpressions = this.groupingExpressions;
        const /** @type {?} */ newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.get(this.id)) {
            this._gridAPI.arrange_sorting_expressions(this.id);
            /* grouping should work in conjunction with sorting
                        and without overriding separate sorting expressions */
            this._applyGrouping();
            this.cdr.markForCheck();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            const /** @type {?} */ groupedCols = [];
            const /** @type {?} */ ungroupedCols = [];
            const /** @type {?} */ groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const /** @type {?} */ ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const /** @type {?} */ groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Returns a list of expansion states for group rows.
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * ```typescript
     * const groupExpState = this.grid.groupingExpansionState;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    /**
     * Sets a list of expansion states for group rows.
     * ```typescript
     *      this.grid.groupingExpansionState = [{
     *      expanded: false,
     *      hierarchy: [{ fieldName: 'ID', value: 1 }]
     *   }];
     * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpansionState(value) {
        const /** @type {?} */ activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
        let /** @type {?} */ highlightItem = null;
        if (this.collapsedHighlightedItem) {
            highlightItem = this.collapsedHighlightedItem.item;
        }
        else if (this.lastSearchInfo.matchInfoCache.length) {
            highlightItem = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex].item;
        }
        this._groupingExpandState = cloneArray(value);
        this.refreshSearch();
        if (highlightItem !== null && this.groupingExpressions.length) {
            const /** @type {?} */ index = this.filteredSortedData.indexOf(highlightItem);
            const /** @type {?} */ groupRow = this.getGroupByRecords()[index];
            if (!this.isExpandedGroup(groupRow)) {
                IgxTextHighlightDirective.clearActiveHighlight(this.id);
                this.collapsedHighlightedItem = {
                    info: activeInfo,
                    item: highlightItem
                };
            }
            else if (this.collapsedHighlightedItem !== null) {
                const /** @type {?} */ collapsedInfo = this.collapsedHighlightedItem.info;
                IgxTextHighlightDirective.setActiveHighlight(this.id, {
                    columnIndex: collapsedInfo.columnIndex,
                    rowIndex: collapsedInfo.rowIndex,
                    index: collapsedInfo.index,
                    page: collapsedInfo.page
                });
            }
        }
        this.cdr.detectChanges();
    }
    /**
     * An \@Input property that sets whether the grouped columns should be hidden as well.
     * The default value is "false"
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * A list of all group rows.
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupsRowList() {
        const /** @type {?} */ res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const /** @type {?} */ rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(rList);
        return res;
    }
    /**
     * @hidden
     * @return {?}
     */
    get groupAreaHostClass() {
        switch (this.displayDensity) {
            case "cosy" /* cosy */:
                return 'igx-drop-area--cosy';
            case "compact" /* compact */:
                return 'igx-drop-area--compact';
            default:
                return 'igx-drop-area';
        }
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group row.
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
     * ```typescript
     * this.grid.groupRowTemplate = myRowTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.markForCheck();
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.markForCheck();
    }
    /**
     * @param {...?} rest
     * @return {?}
     */
    groupBy(...rest) {
        this.endEdit(true);
        this._gridAPI.submit_value(this.id);
        if (rest.length === 1 && rest[0] instanceof Array) {
            this._groupByMultiple(rest[0]);
        }
        else {
            this._groupBy(rest[0]);
        }
        this.cdr.detectChanges();
        this.calculateGridSizes();
        this.restoreHighlight();
    }
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(this.id, name);
        this.calculateGridSizes();
        this.restoreHighlight();
    }
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    isExpandedGroup(group) {
        const /** @type {?} */ state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.cdr.detectChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _setGroupColsVisibility(value) {
        this.groupingExpressions.forEach((expr) => {
            const /** @type {?} */ col = this.getColumnByName(expr.fieldName);
            col.hidden = value;
        });
    }
    /**
     * Returns if the grid's group by drop area is visible.
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    _groupBy(expression) {
        this._gridAPI.groupBy(this.id, expression.fieldName, expression.dir, expression.ignoreCase, expression.strategy);
    }
    /**
     * @hidden
     * @param {?} expressions
     * @return {?}
     */
    _groupByMultiple(expressions) {
        this._gridAPI.groupBy_multiple(this.id, expressions);
    }
    /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(this.id, groupRow);
    }
    /**
     * @hidden
     * @param {?} groupRow
     * @return {?}
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(this.id, groupRow);
    }
    /**
     * @hidden
     * @return {?}
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this.id, this._groupingExpressions);
    }
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    getContext(rowData) {
        return {
            $implicit: rowData,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : 'dataRow'
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    getGroupIncrementData() {
        if (this.groupingExpressions && this.groupingExpressions.length) {
            const /** @type {?} */ groupsRecords = this.getGroupByRecords();
            const /** @type {?} */ groupByIncrements = [];
            const /** @type {?} */ values = [];
            let /** @type {?} */ prevHierarchy = null;
            let /** @type {?} */ increment = 0;
            groupsRecords.forEach((gbr) => {
                if (values.indexOf(gbr) === -1) {
                    let /** @type {?} */ levelIncrement = 1;
                    if (prevHierarchy !== null) {
                        levelIncrement += this.getLevelIncrement(0, gbr.groupParent, prevHierarchy.groupParent);
                    }
                    else {
                        // This is the first level we stumble upon, so we haven't accounted for any of its parents
                        levelIncrement += gbr.level;
                    }
                    increment += levelIncrement;
                    prevHierarchy = gbr;
                    values.push(gbr);
                }
                groupByIncrements.push(increment);
            });
            return groupByIncrements;
        }
        else {
            return null;
        }
    }
    /**
     * @param {?} currentIncrement
     * @param {?} currentHierarchy
     * @param {?} prevHierarchy
     * @return {?}
     */
    getLevelIncrement(currentIncrement, currentHierarchy, prevHierarchy) {
        if (currentHierarchy !== prevHierarchy && !!prevHierarchy && !!currentHierarchy) {
            return this.getLevelIncrement(++currentIncrement, currentHierarchy.groupParent, prevHierarchy.groupParent);
        }
        else {
            return currentIncrement;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getGroupByRecords() {
        if (this.groupingExpressions && this.groupingExpressions.length) {
            const /** @type {?} */ state = {
                expressions: this.groupingExpressions,
                expansion: this.groupingExpansionState,
                defaultExpanded: this.groupsExpanded
            };
            return DataUtil.group(cloneArray(this.filteredSortedData), state).metadata;
        }
        else {
            return null;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    chipsOrderChanged(event) {
        const /** @type {?} */ newGrouping = [];
        for (let /** @type {?} */ i = 0; i < event.chipsArray.length; i++) {
            const /** @type {?} */ expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.markForCheck();
    }
    /**
     * @hidden
     * @return {?}
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.markForCheck();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipClicked(event) {
        const /** @type {?} */ sortingExpr = this.sortingExpressions;
        const /** @type {?} */ columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.markForCheck();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            const /** @type {?} */ sortingExpr = this.sortingExpressions;
            const /** @type {?} */ columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.markForCheck();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    }
    /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    getPinnedWidth(takeHidden = false) {
        let /** @type {?} */ sum = super.getPinnedWidth(takeHidden);
        if (this.groupingExpressions.length > 0 && this.headerGroupContainer) {
            sum += this.headerGroupContainer.nativeElement.clientWidth;
        }
        return sum;
    }
    /**
     * @hidden
     * @param {?} row
     * @param {?} column
     * @param {?} page
     * @param {?=} groupByRecord
     * @return {?}
     */
    scrollTo(row, column, page, groupByRecord) {
        if (groupByRecord && !this.isExpandedGroup(groupByRecord)) {
            this.toggleGroup(groupByRecord);
        }
        super.scrollTo(row, column, page, groupByRecord);
    }
    /**
     * @hidden
     * @return {?}
     */
    resolveFilteredSortedData() {
        let /** @type {?} */ data = super.resolveFilteredSortedData();
        if (this.sortingExpressions &&
            this.sortingExpressions.length > 0) {
            const /** @type {?} */ sortingPipe = new IgxGridSortingPipe(this._gridAPI);
            data = sortingPipe.transform(data, this.sortingExpressions, this.id, -1);
        }
        return data;
    }
    /**
     * @hidden
     * @return {?}
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        super.ngAfterContentInit();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe(() => this.endEdit(true));
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.groupingDiffer) {
            const /** @type {?} */ changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem((rec) => {
                    const /** @type {?} */ col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    const /** @type {?} */ col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    }
}
IgxGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [IgxGridNavigationService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: forwardRef(() => IgxGridComponent) },
                    IgxFilteringService
                ],
                selector: 'igx-grid',
                template: `<igx-grid-toolbar role="rowgroup" [style.width.px]="calcWidth" *ngIf="shouldShowToolbar" [gridID]="id" [displayDensity]="displayDensity" #toolbar>
</igx-grid-toolbar>

<ng-template #defaultPager let-api>
    <button [disabled]="api.isFirstPage" (click)="api.paginate(0)" igxButton="icon" igxRipple igxRippleCentered="true">
        <igx-icon fontSet="material">first_page</igx-icon>
    </button>
    <button [disabled]="api.isFirstPage" (click)="api.previousPage()" igxButton="icon" igxRipple igxRippleCentered="true">
        <igx-icon fontSet="material">chevron_left</igx-icon>
    </button>
    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>
    <button [disabled]="api.isLastPage" (click)="api.nextPage()" igxRipple igxRippleCentered="true" igxButton="icon">
        <igx-icon fontSet="material">chevron_right</igx-icon>
    </button>
        <button [disabled]="api.isLastPage" (click)="api.paginate(api.totalPages - 1)" igxButton="icon" igxRipple igxRippleCentered="true">
        <igx-icon fontSet="material">last_page</igx-icon>
    </button>
    <select style="margin-left: 1rem;" (change)="api.perPage = $event.target.value">
            <option [value]="val" [selected]="api.perPage == val" *ngFor="let val of [5, 10, 15, 25, 50, 100, 500]">{{ val }}</option>
    </select>
</ng-template>

<div [style.width.px]='calcWidth' class="igx-grid__grouparea" *ngIf="groupingExpressions.length > 0 || hasGroupableColumns" #groupArea>
    <igx-chips-area (onReorder)="chipsOrderChanged($event)" (onMoveEnd)="chipsMovingEnded()">
        <ng-container *ngFor="let expr of chipsGoupingExpressions; let last = last;">
            <igx-chip [id]="expr.fieldName" [removable]="getColumnByName(expr.fieldName).groupable" [draggable]="getColumnByName(expr.fieldName).groupable" [displayDensity]="displayDensity"
                (onKeyDown)="onChipKeyDown($event)" (onRemove)="onChipRemoved($event)" (onClick)="getColumnByName(expr.fieldName).groupable ? onChipClicked($event): null" [disabled]='!getColumnByName(expr.fieldName).groupable'>
                    <span>{{ getColumnByName(expr.fieldName).header || expr.fieldName }}</span>
                    <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>
            </igx-chip>
            <span class="igx-grid__grouparea-connector">
                <igx-icon [style.visibility]="(!last || dropAreaVisible) ? 'visible' : 'hidden'" >arrow_forward</igx-icon>
            </span>
        </ng-container>
        <div igxGroupAreaDrop [style.visibility]="dropAreaVisible ? 'visible' : 'hidden'" [class]="groupAreaHostClass">
            <ng-container *ngTemplateOutlet="dropAreaTemplateResolved"></ng-container>
        </div>
    </igx-chips-area>
</div>

<div class="igx-grid__thead" role="rowgroup" [style.width.px]='calcWidth' #theadRow>
    <div class="igx-grid__tr" [style.width.px]='calcWidth' role="row">
        <span *ngIf="hasMovableColumns && draggedColumn && pinnedColumns.length <= 0" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="left" class="igx-grid__scroll-on-drag-left"></span>
        <span *ngIf="hasMovableColumns && draggedColumn && pinnedColumns.length > 0" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="left" class="igx-grid__scroll-on-drag-pinned" [style.left.px]="pinnedWidth"></span>
        <ng-container *ngIf="groupingExpressions.length > 0">
            <div class="igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}" #headerGroupContainer>
                <igx-icon role="button" class="igx-grid__group-expand-btn" (click)="toggleAllGroupRows()">reorder</igx-icon>
            </div>
        </ng-container>
        <ng-container *ngIf="rowSelectable">
            <div class="igx-grid__cbx-selection" #headerCheckboxContainer>
                <igx-checkbox [checked]="allRowsSelected" (change)="onHeaderCheckboxClick($event)" disableRipple="true" [aria-label]="headerCheckboxAriaLabel" #headerCheckbox></igx-checkbox>
            </div>
        </ng-container>
        <ng-container *ngIf="pinnedColumns.length > 0">
            <ng-template ngFor let-col [ngForOf]="onlyTopLevel(pinnedColumns)">
                <div class="igx-grid__thead-item igx-grid__th--pinned">
                    <igx-grid-header [igxColumnMovingDrag]="col" [attr.droppable]="true" [igxColumnMovingDrop]="col" [gridID]="id"
                        [column]="col" [style.min-width.px]="col.width" [style.flex-basis.px]="col.width" [style.max-width.px]='col.width'></igx-grid-header>
                    <igx-grid-filtering-cell *ngIf="allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col"
                        [column]="col" [style.min-width.px]="col.width" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>
                </div>
            </ng-template>
        </ng-container>
        <ng-template igxGridFor let-col [igxGridForOf]="onlyTopLevel(unpinnedColumns)" [igxForScrollOrientation]="'horizontal'" [igxForScrollContainer]="parentVirtDir"
            [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #headerContainer>
            <div class="igx-grid__thead-item">
                <igx-grid-header [igxColumnMovingDrag]="col" [attr.droppable]="true" [igxColumnMovingDrop]="col" [gridID]="id" [column]="col"
                    [style.min-width.px]="col.width" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-header>
                <igx-grid-filtering-cell *ngIf="allowFiltering && !col.columnGroup && filteringService.filteredColumn !== col" [column]="col"
                    [style.min-width.px]="col.width" [style.flex-basis.px]='col.width' [style.max-width.px]='col.width'></igx-grid-filtering-cell>
            </div>
        </ng-template>
        <span *ngIf="hasMovableColumns && draggedColumn" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="right" class="igx-grid__scroll-on-drag-right"></span>
    </div>
    <igx-grid-filtering-row *ngIf="filteringService.isFilterRowVisible" [column]="filteringService.filteredColumn"></igx-grid-filtering-row>
</div>

<div class="igx-grid__tbody" role="rowgroup" [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)' (wheel)="wheelHandler()">
    <span *ngIf="hasMovableColumns && draggedColumn && pinnedColumns.length <= 0" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="left" class="igx-grid__scroll-on-drag-left"></span>
    <span *ngIf="hasMovableColumns && draggedColumn && pinnedColumns.length > 0" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="left" class="igx-grid__scroll-on-drag-pinned" [style.left.px]="pinnedWidth"></span>
    <ng-template igxGridFor let-rowData [igxGridForOf]="data | gridTransaction:id:pipeTrigger
    | gridFiltering:filteringExpressionsTree:id:pipeTrigger
    | gridSort:sortingExpressions:id:pipeTrigger
    | gridPreGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:pipeTrigger
    | gridPaging:page:perPage:id:pipeTrigger
    | gridPostGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger"
    let-rowIndex="index" [igxForScrollOrientation]="'vertical'"
    [igxForContainerSize]='calcHeight' [igxForItemSize]="rowHeight" #verticalScrollContainer (onChunkPreload)="dataLoading($event)">
        <ng-template #record_template>
            <igx-grid-row [gridID]="id" [index]="rowIndex" [rowData]="rowData" #row>
            </igx-grid-row>
        </ng-template>
        <ng-template #group_template>
            <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row>
            </igx-grid-groupby-row>
        </ng-template>
        <ng-container *igxTemplateOutlet="isGroupByRecord(rowData) ? group_template : record_template; context: getContext(rowData) "></ng-container>
    </ng-template>
    <ng-container *ngTemplateOutlet="template"></ng-container>
    <span *ngIf="hasMovableColumns && draggedColumn" [igxColumnMovingDrop]="parentVirtDir" [attr.droppable]="true" id="right" class="igx-grid__scroll-on-drag-right"></span>
    <div class="igx-grid__row-editing-outlet" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>
</div>


<div class="igx-grid__tfoot" role="rowgroup" [style.width.px]='calcWidth' #tfoot>
    <div *ngIf="hasSummarizedColumns" class="igx-grid__summaries" [style.height.px]="summariesHeight" role="row" #summaries>
        <ng-container *ngIf="groupingExpressions.length > 0">
            <div class="igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}"></div>
        </ng-container>
        <ng-container *ngIf="summariesMargin">
            <div
            class="igx-grid__summaries-patch"
            [style.min-width.px]="summariesMargin"
            [style.flex-basis.px]="summariesMargin"
            ></div>
        </ng-container>
        <ng-container *ngIf="pinnedColumns.length > 0">
            <igx-grid-summary [gridID]="id" *ngFor="let col of notGroups(pinnedColumns)"  [column]="col" [style.min-width.px]="col.width" [style.flex-basis.px]='col.width'></igx-grid-summary>
        </ng-container>
        <ng-template igxGridFor let-col [igxGridForOf]="notGroups(unpinnedColumns)" [igxForScrollOrientation]="'horizontal'" [igxForScrollContainer]="parentVirtDir" [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' #summaryContainer>
            <igx-grid-summary [gridID]="id" [column]="col" [style.min-width.px]="col.width" [style.flex-basis.px]='col.width'></igx-grid-summary>
        </ng-template>
    </div>
</div>

<div class="igx-grid__scroll" [style.height]="'18px'" #scr [hidden]="unpinnedWidth - totalWidth >= 0">
    <div class="igx-grid__scroll-start" [style.width.px]='pinnedWidth' [hidden]="pinnedWidth === 0"></div>
    <div class="igx-grid__scroll-main" [style.width.px]='unpinnedWidth'>
        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>
        </ng-template>
    </div>
</div>

<div class="igx-paginator igx-grid-paginator" *ngIf="paging" #paginator>
    <ng-container *ngTemplateOutlet="paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }">
    </ng-container>
</div>

<ng-template #emptyFilteredGrid>
    <span class="igx-grid__tbody-message">{{emptyFilteredGridMessage}}</span>
</ng-template>

<ng-template #defaultEmptyGrid>
    <span class="igx-grid__tbody-message">{{emptyGridMessage}}</span>
</ng-template>

<ng-template #defaultDropArea>
    <igx-icon fontSet="material" class="igx-drop-area__icon">group_work</igx-icon>
    <span class="igx-drop-area__text">{{dropAreaMessage}}</span>
</ng-template>

<div *ngIf="rowEditable" igxToggle>
    <div [className]="bannerClass">
        <ng-container *ngTemplateOutlet="rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }"></ng-container>
    </div>
</div>
<ng-template #defaultRowEditText>
    You have {{ rowChangesCount }} changes in this row
</ng-template>
<ng-template #defaultRowEditActions>
    <button igxButton igxRowEditTabStop (click)="endEdit(false, $event)">Cancel</button>
    <button igxButton igxRowEditTabStop (click)="endEdit(true, $event)">Done</button>
</ng-template>
<ng-template #defaultRowEditTemplate>
    <div class="igx-banner__message">
        <span class="igx-banner__text">
            <ng-container *ngTemplateOutlet="rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }"></ng-container>
        </span>
    </div>
    <div class="igx-banner__actions">
        <div class="igx-banner__row">
            <ng-container *ngTemplateOutlet="rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }"></ng-container>
        </div>
    </div>
</ng-template>

<div class="igx-grid__outlet" #igxFilteringOverlayOutlet igxOverlayOutlet></div>
`
            },] },
];
/** @nocollapse */
IgxGridComponent.ctorParameters = () => [
    { type: GridBaseAPIService, },
    { type: IgxSelectionAPIService, },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] },] },
    { type: ElementRef, },
    { type: NgZone, },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    { type: ChangeDetectorRef, },
    { type: ComponentFactoryResolver, },
    { type: IterableDiffers, },
    { type: ViewContainerRef, },
    { type: IgxGridNavigationService, },
    { type: IgxFilteringService, },
];
IgxGridComponent.propDecorators = {
    "id": [{ type: HostBinding, args: ['attr.id',] }, { type: Input },],
    "groupingExpressions": [{ type: Input },],
    "groupingExpansionState": [{ type: Input },],
    "groupsExpanded": [{ type: Input },],
    "hideGroupedColumns": [{ type: Input },],
    "dropAreaMessage": [{ type: Input },],
    "dropAreaTemplate": [{ type: Input },],
    "onGroupingDone": [{ type: Output },],
    "onFocusChange": [{ type: Output },],
    "groupTemplate": [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] },],
    "_groupsRowList": [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] },],
    "defaultDropAreaTemplate": [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef },] },],
    "groupArea": [{ type: ViewChild, args: ['groupArea',] },],
};
function IgxGridComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxGridComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxGridComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxGridComponent.propDecorators;
    /** @type {?} */
    IgxGridComponent.prototype._id;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupingExpressions;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupingExpandState;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupRowTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype._groupAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupingDiffer;
    /** @type {?} */
    IgxGridComponent.prototype._hideGroupedColumns;
    /** @type {?} */
    IgxGridComponent.prototype._gridAPI;
    /**
     * An \@Input property that determines whether created groups are rendered expanded or collapsed.
     * The default rendered state is expanded.
     * ```html
     * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsExpanded;
    /**
     * A hierarchical representation of the group by records.
     * ```typescript
     * let groupRecords = this.grid.groupsRecords;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsRecords;
    /**
     * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaMessage;
    /**
     * An \@Input property that sets the template that will be rendered as a GroupBy drop area.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid [dropAreaTemplate]="dropAreaRef">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     *
     * <ng-template #myDropArea>
     *      <span> Custom drop area! </span>
     * </ng-template>
     * ```
     * ```ts
     * \@ViewChild('myDropArea', { read: TemplateRef })
     * public dropAreaRef: TemplateRef<any>;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaTemplate;
    /**
     * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
     * grouped/ungrouped at once by using the Group By API.
     * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
     * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
     * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
     * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
     * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
     * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
     * columns.
     * ```typescript
     * groupingDone(event: IGroupingDoneEventArgs){
     *     const expressions = event.expressions;
     *     //the newly grouped columns
     *     const groupedColumns = event.groupedColumns;
     *     //the newly ungrouped columns
     *     const ungroupedColumns = event.ungroupedColumns;
     * }
     * ```
     * ```html
     * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.onGroupingDone;
    /** @type {?} */
    IgxGridComponent.prototype.onFocusChange;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupTemplate;
    /** @type {?} */
    IgxGridComponent.prototype._groupsRowList;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.defaultDropAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupArea;
    /** @type {?} */
    IgxGridComponent.prototype.document;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsdUJBQXVCLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFDaEcsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFXLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSx3QkFBd0IsRUFDM0csZUFBZSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBb0IsV0FBVyxFQUFFLFVBQVUsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUN4SCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQXlCLE1BQU0sd0JBQXdCLENBQUM7QUFDekcsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDdEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFdkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzlDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDBEQUEwRCxDQUFDO0FBRXJHLE9BQU8sRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25FLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBS3JFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUU5RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFM0MsT0FBTyxFQUFF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O3VDQXdFTCxLQUFLOytCQTZETCxLQUFLO21DQW9CTCxLQUFLO2dDQTRCTCxLQUFLO2lDQXFCTCxLQUFLOytCQTJCTCxNQUFNOzhCQUdOLE1BQU07OEJBTU4sWUFBWSxTQUFDLDhCQUE4QixFQUFFLEVBQUUsSUFBSSxFQUFFLDhCQUE4QixFQUFFOytCQUdyRixZQUFZLFNBQUMsMEJBQTBCLEVBQUUsRUFBRSxJQUFJLEVBQUUsMEJBQTBCLEVBQUU7d0NBTTdFLFNBQVMsU0FBQyxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7MEJBeUJsRCxTQUFTLFNBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBWaWV3Q2hpbGRyZW4sXG4gICAgUXVlcnlMaXN0LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIFRlbXBsYXRlUmVmLCBEb0NoZWNrLCBOZ1pvbmUsIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgSXRlcmFibGVEaWZmZXJzLCBWaWV3Q29udGFpbmVyUmVmLCBJbmplY3QsIEFmdGVyQ29udGVudEluaXQsIEhvc3RCaW5kaW5nLCBmb3J3YXJkUmVmLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlQ29tcG9uZW50LCBJZ3hHcmlkVHJhbnNhY3Rpb24sIElGb2N1c0NoYW5nZUV2ZW50QXJncyB9IGZyb20gJy4uL2dyaWQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEFQSVNlcnZpY2UgfSBmcm9tICcuL2dyaWQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgY2xvbmVBcnJheSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4VGV4dEhpZ2hsaWdodERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvdGV4dC1oaWdobGlnaHQvdGV4dC1oaWdobGlnaHQuZGlyZWN0aXZlJztcbmltcG9ydCB7IElHcm91cEJ5UmVjb3JkIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktcmVjb3JkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2dyaWQuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCB9IGZyb20gJy4vZ3JvdXBieS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vLi4vY29yZS9kaXNwbGF5RGVuc2l0eSc7XG5pbXBvcnQgeyBJR3JvdXBCeUV4cGFuZFN0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElDaGlwQ2xpY2tFdmVudEFyZ3MsIElDaGlwS2V5RG93bkV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvY2hpcHMtYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0YVV0aWwgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IElneFNlbGVjdGlvbkFQSVNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblNlcnZpY2UsIFRyYW5zYWN0aW9uLCBTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZFNvcnRpbmdQaXBlIH0gZnJvbSAnLi9ncmlkLnBpcGVzJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4RmlsdGVyaW5nU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlcmluZy9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcblxubGV0IE5FWFRfSUQgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIElHcmlkRm9jdXNDaGFuZ2VFdmVudEFyZ3MgZXh0ZW5kcyBJRm9jdXNDaGFuZ2VFdmVudEFyZ3Mge1xuICAgIGdyb3VwUm93OiBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSUdyb3VwaW5nRG9uZUV2ZW50QXJncyB7XG4gICAgZXhwcmVzc2lvbnM6IEFycmF5PElTb3J0aW5nRXhwcmVzc2lvbj4gfCBJU29ydGluZ0V4cHJlc3Npb247XG4gICAgZ3JvdXBlZENvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQ7XG4gICAgdW5ncm91cGVkQ29sdW1uczogQXJyYXk8SWd4Q29sdW1uQ29tcG9uZW50PiB8IElneENvbHVtbkNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBHcmlkKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL2dyaWQuaHRtbClcbiAqXG4gKiBUaGUgSWduaXRlIFVJIEdyaWQgaXMgdXNlZCBmb3IgcHJlc2VudGluZyBhbmQgbWFuaXB1bGF0aW5nIHRhYnVsYXIgZGF0YSBpbiB0aGUgc2ltcGxlc3Qgd2F5IHBvc3NpYmxlLiAgT25jZSBkYXRhXG4gKiBoYXMgYmVlbiBib3VuZCwgaXQgY2FuIGJlIG1hbmlwdWxhdGVkIHRocm91Z2ggZmlsdGVyaW5nLCBzb3J0aW5nICYgZWRpdGluZyBvcGVyYXRpb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgYXV0b0dlbmVyYXRlPVwiZmFsc2VcIj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJmaXJzdFwiIGhlYWRlcj1cIkZpcnN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwibGFzdFwiIGhlYWRlcj1cIkxhc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJyb2xlXCIgaGVhZGVyPVwiUm9sZVwiPjwvaWd4LWNvbHVtbj5cbiAqIDwvaWd4LWdyaWQ+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgcHJvdmlkZXJzOiBbSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IEdyaWRCYXNlQVBJU2VydmljZSwgdXNlQ2xhc3M6IElneEdyaWRBUElTZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSWd4R3JpZEJhc2VDb21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneEdyaWRDb21wb25lbnQpIH0sXG4gICAgICAgIElneEZpbHRlcmluZ1NlcnZpY2VcbiAgICBdLFxuICAgIHNlbGVjdG9yOiAnaWd4LWdyaWQnLFxuICAgIHRlbXBsYXRlOiBgPGlneC1ncmlkLXRvb2xiYXIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLndpZHRoLnB4XT1cImNhbGNXaWR0aFwiICpuZ0lmPVwic2hvdWxkU2hvd1Rvb2xiYXJcIiBbZ3JpZElEXT1cImlkXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImRpc3BsYXlEZW5zaXR5XCIgI3Rvb2xiYXI+XG48L2lneC1ncmlkLXRvb2xiYXI+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFBhZ2VyIGxldC1hcGk+XG4gICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiYXBpLmlzRmlyc3RQYWdlXCIgKGNsaWNrKT1cImFwaS5wYWdpbmF0ZSgwKVwiIGlneEJ1dHRvbj1cImljb25cIiBpZ3hSaXBwbGUgaWd4UmlwcGxlQ2VudGVyZWQ9XCJ0cnVlXCI+XG4gICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5maXJzdF9wYWdlPC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCJhcGkuaXNGaXJzdFBhZ2VcIiAoY2xpY2spPVwiYXBpLnByZXZpb3VzUGFnZSgpXCIgaWd4QnV0dG9uPVwiaWNvblwiIGlneFJpcHBsZSBpZ3hSaXBwbGVDZW50ZXJlZD1cInRydWVcIj5cbiAgICAgICAgPGlneC1pY29uIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmNoZXZyb25fbGVmdDwvaWd4LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPHNwYW4+e3sgYXBpLnBhZ2UgKyAxIH19IG9mIHt7IGFwaS50b3RhbFBhZ2VzIH19PC9zcGFuPlxuICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImFwaS5pc0xhc3RQYWdlXCIgKGNsaWNrKT1cImFwaS5uZXh0UGFnZSgpXCIgaWd4UmlwcGxlIGlneFJpcHBsZUNlbnRlcmVkPVwidHJ1ZVwiIGlneEJ1dHRvbj1cImljb25cIj5cbiAgICAgICAgPGlneC1pY29uIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmNoZXZyb25fcmlnaHQ8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCJhcGkuaXNMYXN0UGFnZVwiIChjbGljayk9XCJhcGkucGFnaW5hdGUoYXBpLnRvdGFsUGFnZXMgLSAxKVwiIGlneEJ1dHRvbj1cImljb25cIiBpZ3hSaXBwbGUgaWd4UmlwcGxlQ2VudGVyZWQ9XCJ0cnVlXCI+XG4gICAgICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5sYXN0X3BhZ2U8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxzZWxlY3Qgc3R5bGU9XCJtYXJnaW4tbGVmdDogMXJlbTtcIiAoY2hhbmdlKT1cImFwaS5wZXJQYWdlID0gJGV2ZW50LnRhcmdldC52YWx1ZVwiPlxuICAgICAgICAgICAgPG9wdGlvbiBbdmFsdWVdPVwidmFsXCIgW3NlbGVjdGVkXT1cImFwaS5wZXJQYWdlID09IHZhbFwiICpuZ0Zvcj1cImxldCB2YWwgb2YgWzUsIDEwLCAxNSwgMjUsIDUwLCAxMDAsIDUwMF1cIj57eyB2YWwgfX08L29wdGlvbj5cbiAgICA8L3NlbGVjdD5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgW3N0eWxlLndpZHRoLnB4XT0nY2FsY1dpZHRoJyBjbGFzcz1cImlneC1ncmlkX19ncm91cGFyZWFcIiAqbmdJZj1cImdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoID4gMCB8fCBoYXNHcm91cGFibGVDb2x1bW5zXCIgI2dyb3VwQXJlYT5cbiAgICA8aWd4LWNoaXBzLWFyZWEgKG9uUmVvcmRlcik9XCJjaGlwc09yZGVyQ2hhbmdlZCgkZXZlbnQpXCIgKG9uTW92ZUVuZCk9XCJjaGlwc01vdmluZ0VuZGVkKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgZXhwciBvZiBjaGlwc0dvdXBpbmdFeHByZXNzaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICAgICAgPGlneC1jaGlwIFtpZF09XCJleHByLmZpZWxkTmFtZVwiIFtyZW1vdmFibGVdPVwiZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKS5ncm91cGFibGVcIiBbZHJhZ2dhYmxlXT1cImdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSkuZ3JvdXBhYmxlXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImRpc3BsYXlEZW5zaXR5XCJcbiAgICAgICAgICAgICAgICAob25LZXlEb3duKT1cIm9uQ2hpcEtleURvd24oJGV2ZW50KVwiIChvblJlbW92ZSk9XCJvbkNoaXBSZW1vdmVkKCRldmVudClcIiAob25DbGljayk9XCJnZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmdyb3VwYWJsZSA/IG9uQ2hpcENsaWNrZWQoJGV2ZW50KTogbnVsbFwiIFtkaXNhYmxlZF09JyFnZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmdyb3VwYWJsZSc+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7IGdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSkuaGVhZGVyIHx8IGV4cHIuZmllbGROYW1lIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4U3VmZml4Pnt7IGV4cHIuZGlyID09IDEgPyAnYXJyb3dfdXB3YXJkJyA6ICdhcnJvd19kb3dud2FyZCcgfX08L2lneC1pY29uPlxuICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX2dyb3VwYXJlYS1jb25uZWN0b3JcIj5cbiAgICAgICAgICAgICAgICA8aWd4LWljb24gW3N0eWxlLnZpc2liaWxpdHldPVwiKCFsYXN0IHx8IGRyb3BBcmVhVmlzaWJsZSkgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1wiID5hcnJvd19mb3J3YXJkPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgaWd4R3JvdXBBcmVhRHJvcCBbc3R5bGUudmlzaWJpbGl0eV09XCJkcm9wQXJlYVZpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1wiIFtjbGFzc109XCJncm91cEFyZWFIb3N0Q2xhc3NcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkcm9wQXJlYVRlbXBsYXRlUmVzb2x2ZWRcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9pZ3gtY2hpcHMtYXJlYT5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RoZWFkXCIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLndpZHRoLnB4XT0nY2FsY1dpZHRoJyAjdGhlYWRSb3c+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190clwiIFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgcm9sZT1cInJvd1wiPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW4gJiYgcGlubmVkQ29sdW1ucy5sZW5ndGggPD0gMFwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwibGVmdFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLWxlZnRcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTW92YWJsZUNvbHVtbnMgJiYgZHJhZ2dlZENvbHVtbiAmJiBwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIiBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJwYXJlbnRWaXJ0RGlyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1waW5uZWRcIiBbc3R5bGUubGVmdC5weF09XCJwaW5uZWRXaWR0aFwiPjwvc3Bhbj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19oZWFkZXItaW5kZW50YXRpb24gaWd4LWdyaWRfX3Jvdy1pbmRlbnRhdGlvbi0tbGV2ZWwte3tncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aH19XCIgI2hlYWRlckdyb3VwQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fZ3JvdXAtZXhwYW5kLWJ0blwiIChjbGljayk9XCJ0b2dnbGVBbGxHcm91cFJvd3MoKVwiPnJlb3JkZXI8L2lneC1pY29uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicm93U2VsZWN0YWJsZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19jYngtc2VsZWN0aW9uXCIgI2hlYWRlckNoZWNrYm94Q29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxpZ3gtY2hlY2tib3ggW2NoZWNrZWRdPVwiYWxsUm93c1NlbGVjdGVkXCIgKGNoYW5nZSk9XCJvbkhlYWRlckNoZWNrYm94Q2xpY2soJGV2ZW50KVwiIGRpc2FibGVSaXBwbGU9XCJ0cnVlXCIgW2FyaWEtbGFiZWxdPVwiaGVhZGVyQ2hlY2tib3hBcmlhTGFiZWxcIiAjaGVhZGVyQ2hlY2tib3g+PC9pZ3gtY2hlY2tib3g+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cIm9ubHlUb3BMZXZlbChwaW5uZWRDb2x1bW5zKVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGhlYWQtaXRlbSBpZ3gtZ3JpZF9fdGgtLXBpbm5lZFwiPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyIFtpZ3hDb2x1bW5Nb3ZpbmdEcmFnXT1cImNvbFwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiY29sXCIgW2dyaWRJRF09XCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImNvbFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLm1heC13aWR0aC5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtZ3JpZC1maWx0ZXJpbmctY2VsbCAqbmdJZj1cImFsbG93RmlsdGVyaW5nICYmICFjb2wuY29sdW1uR3JvdXAgJiYgZmlsdGVyaW5nU2VydmljZS5maWx0ZXJlZENvbHVtbiAhPT0gY29sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09J2NvbC53aWR0aCcgW3N0eWxlLm1heC13aWR0aC5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1maWx0ZXJpbmctY2VsbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtY29sIFtpZ3hHcmlkRm9yT2ZdPVwib25seVRvcExldmVsKHVucGlubmVkQ29sdW1ucylcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvclNjcm9sbENvbnRhaW5lcl09XCJwYXJlbnRWaXJ0RGlyXCJcbiAgICAgICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT0ndW5waW5uZWRXaWR0aCcgW2lneEZvclRyYWNrQnldPSd0cmFja0NvbHVtbkNoYW5nZXMnICNoZWFkZXJDb250YWluZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RoZWFkLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyIFtpZ3hDb2x1bW5Nb3ZpbmdEcmFnXT1cImNvbFwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiY29sXCIgW2dyaWRJRF09XCJpZFwiIFtjb2x1bW5dPVwiY29sXCJcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aC5weF09XCJjb2wud2lkdGhcIiBbc3R5bGUuZmxleC1iYXNpcy5weF09J2NvbC53aWR0aCcgW3N0eWxlLm1heC13aWR0aC5weF09J2NvbC53aWR0aCc+PC9pZ3gtZ3JpZC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgPGlneC1ncmlkLWZpbHRlcmluZy1jZWxsICpuZ0lmPVwiYWxsb3dGaWx0ZXJpbmcgJiYgIWNvbC5jb2x1bW5Hcm91cCAmJiBmaWx0ZXJpbmdTZXJ2aWNlLmZpbHRlcmVkQ29sdW1uICE9PSBjb2xcIiBbY29sdW1uXT1cImNvbFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPSdjb2wud2lkdGgnIFtzdHlsZS5tYXgtd2lkdGgucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtZmlsdGVyaW5nLWNlbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJyaWdodFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLXJpZ2h0XCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxpZ3gtZ3JpZC1maWx0ZXJpbmctcm93ICpuZ0lmPVwiZmlsdGVyaW5nU2VydmljZS5pc0ZpbHRlclJvd1Zpc2libGVcIiBbY29sdW1uXT1cImZpbHRlcmluZ1NlcnZpY2UuZmlsdGVyZWRDb2x1bW5cIj48L2lneC1ncmlkLWZpbHRlcmluZy1yb3c+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX190Ym9keVwiIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS5oZWlnaHQucHhdPSdjYWxjSGVpZ2h0JyBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnICN0Ym9keSAoc2Nyb2xsKT0nc2Nyb2xsSGFuZGxlcigkZXZlbnQpJyAod2hlZWwpPVwid2hlZWxIYW5kbGVyKClcIj5cbiAgICA8c3BhbiAqbmdJZj1cImhhc01vdmFibGVDb2x1bW5zICYmIGRyYWdnZWRDb2x1bW4gJiYgcGlubmVkQ29sdW1ucy5sZW5ndGggPD0gMFwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwibGVmdFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLWxlZnRcIj48L3NwYW4+XG4gICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cInBhcmVudFZpcnREaXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwibGVmdFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLXBpbm5lZFwiIFtzdHlsZS5sZWZ0LnB4XT1cInBpbm5lZFdpZHRoXCI+PC9zcGFuPlxuICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1yb3dEYXRhIFtpZ3hHcmlkRm9yT2ZdPVwiZGF0YSB8IGdyaWRUcmFuc2FjdGlvbjppZDpwaXBlVHJpZ2dlclxuICAgIHwgZ3JpZEZpbHRlcmluZzpmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6aWQ6cGlwZVRyaWdnZXJcbiAgICB8IGdyaWRTb3J0OnNvcnRpbmdFeHByZXNzaW9uczppZDpwaXBlVHJpZ2dlclxuICAgIHwgZ3JpZFByZUdyb3VwQnk6Z3JvdXBpbmdFeHByZXNzaW9uczpncm91cGluZ0V4cGFuc2lvblN0YXRlOmdyb3Vwc0V4cGFuZGVkOmlkOnBpcGVUcmlnZ2VyXG4gICAgfCBncmlkUGFnaW5nOnBhZ2U6cGVyUGFnZTppZDpwaXBlVHJpZ2dlclxuICAgIHwgZ3JpZFBvc3RHcm91cEJ5Omdyb3VwaW5nRXhwcmVzc2lvbnM6Z3JvdXBpbmdFeHBhbnNpb25TdGF0ZTpncm91cHNFeHBhbmRlZDppZDpncm91cHNSZWNvcmRzOnBpcGVUcmlnZ2VyXCJcbiAgICBsZXQtcm93SW5kZXg9XCJpbmRleFwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCIndmVydGljYWwnXCJcbiAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09J2NhbGNIZWlnaHQnIFtpZ3hGb3JJdGVtU2l6ZV09XCJyb3dIZWlnaHRcIiAjdmVydGljYWxTY3JvbGxDb250YWluZXIgKG9uQ2h1bmtQcmVsb2FkKT1cImRhdGFMb2FkaW5nKCRldmVudClcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNyZWNvcmRfdGVtcGxhdGU+XG4gICAgICAgICAgICA8aWd4LWdyaWQtcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbcm93RGF0YV09XCJyb3dEYXRhXCIgI3Jvdz5cbiAgICAgICAgICAgIDwvaWd4LWdyaWQtcm93PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2dyb3VwX3RlbXBsYXRlPlxuICAgICAgICAgICAgPGlneC1ncmlkLWdyb3VwYnktcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZ3JvdXBSb3ddPVwicm93RGF0YVwiICNyb3c+XG4gICAgICAgICAgICA8L2lneC1ncmlkLWdyb3VwYnktcm93PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctY29udGFpbmVyICppZ3hUZW1wbGF0ZU91dGxldD1cImlzR3JvdXBCeVJlY29yZChyb3dEYXRhKSA/IGdyb3VwX3RlbXBsYXRlIDogcmVjb3JkX3RlbXBsYXRlOyBjb250ZXh0OiBnZXRDb250ZXh0KHJvd0RhdGEpIFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPHNwYW4gKm5nSWY9XCJoYXNNb3ZhYmxlQ29sdW1ucyAmJiBkcmFnZ2VkQ29sdW1uXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwicGFyZW50VmlydERpclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJyaWdodFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLXJpZ2h0XCI+PC9zcGFuPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fcm93LWVkaXRpbmctb3V0bGV0XCIgaWd4T3ZlcmxheU91dGxldCAjaWd4Um93RWRpdGluZ092ZXJsYXlPdXRsZXQ+PC9kaXY+XG48L2Rpdj5cblxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rmb290XCIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLndpZHRoLnB4XT0nY2FsY1dpZHRoJyAjdGZvb3Q+XG4gICAgPGRpdiAqbmdJZj1cImhhc1N1bW1hcml6ZWRDb2x1bW5zXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc3VtbWFyaWVzXCIgW3N0eWxlLmhlaWdodC5weF09XCJzdW1tYXJpZXNIZWlnaHRcIiByb2xlPVwicm93XCIgI3N1bW1hcmllcz5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19yb3ctaW5kZW50YXRpb24gaWd4LWdyaWRfX3Jvdy1pbmRlbnRhdGlvbi0tbGV2ZWwte3tncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aH19XCI+PC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic3VtbWFyaWVzTWFyZ2luXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX19zdW1tYXJpZXMtcGF0Y2hcIlxuICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aC5weF09XCJzdW1tYXJpZXNNYXJnaW5cIlxuICAgICAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXMucHhdPVwic3VtbWFyaWVzTWFyZ2luXCJcbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgIDxpZ3gtZ3JpZC1zdW1tYXJ5IFtncmlkSURdPVwiaWRcIiAqbmdGb3I9XCJsZXQgY29sIG9mIG5vdEdyb3VwcyhwaW5uZWRDb2x1bW5zKVwiICBbY29sdW1uXT1cImNvbFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtc3VtbWFyeT5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1jb2wgW2lneEdyaWRGb3JPZl09XCJub3RHcm91cHModW5waW5uZWRDb2x1bW5zKVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cInBhcmVudFZpcnREaXJcIiBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09J3VucGlubmVkV2lkdGgnIFtpZ3hGb3JUcmFja0J5XT0ndHJhY2tDb2x1bW5DaGFuZ2VzJyAjc3VtbWFyeUNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxpZ3gtZ3JpZC1zdW1tYXJ5IFtncmlkSURdPVwiaWRcIiBbY29sdW1uXT1cImNvbFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sLndpZHRoXCIgW3N0eWxlLmZsZXgtYmFzaXMucHhdPSdjb2wud2lkdGgnPjwvaWd4LWdyaWQtc3VtbWFyeT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbFwiIFtzdHlsZS5oZWlnaHRdPVwiJzE4cHgnXCIgI3NjciBbaGlkZGVuXT1cInVucGlubmVkV2lkdGggLSB0b3RhbFdpZHRoID49IDBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1zdGFydFwiIFtzdHlsZS53aWR0aC5weF09J3Bpbm5lZFdpZHRoJyBbaGlkZGVuXT1cInBpbm5lZFdpZHRoID09PSAwXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtbWFpblwiIFtzdHlsZS53aWR0aC5weF09J3VucGlubmVkV2lkdGgnPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBbaWd4R3JpZEZvck9mXT0nW10nICNzY3JvbGxDb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1wYWdpbmF0b3IgaWd4LWdyaWQtcGFnaW5hdG9yXCIgKm5nSWY9XCJwYWdpbmdcIiAjcGFnaW5hdG9yPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwYWdpbmF0aW9uVGVtcGxhdGUgPyBwYWdpbmF0aW9uVGVtcGxhdGUgOiBkZWZhdWx0UGFnZXI7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB0aGlzIH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2VtcHR5RmlsdGVyZWRHcmlkPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LW1lc3NhZ2VcIj57e2VtcHR5RmlsdGVyZWRHcmlkTWVzc2FnZX19PC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0RW1wdHlHcmlkPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LW1lc3NhZ2VcIj57e2VtcHR5R3JpZE1lc3NhZ2V9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdERyb3BBcmVhPlxuICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIiBjbGFzcz1cImlneC1kcm9wLWFyZWFfX2ljb25cIj5ncm91cF93b3JrPC9pZ3gtaWNvbj5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1kcm9wLWFyZWFfX3RleHRcIj57e2Ryb3BBcmVhTWVzc2FnZX19PC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPGRpdiAqbmdJZj1cInJvd0VkaXRhYmxlXCIgaWd4VG9nZ2xlPlxuICAgIDxkaXYgW2NsYXNzTmFtZV09XCJiYW5uZXJDbGFzc1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RWRpdENvbnRhaW5lcjsgY29udGV4dDogeyByb3dDaGFuZ2VzQ291bnQ6IHJvd0NoYW5nZXNDb3VudCwgZW5kRWRpdDogZW5kRWRpdC5iaW5kKHRoaXMpIH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Um93RWRpdFRleHQ+XG4gICAgWW91IGhhdmUge3sgcm93Q2hhbmdlc0NvdW50IH19IGNoYW5nZXMgaW4gdGhpcyByb3dcbjwvbmctdGVtcGxhdGU+XG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0QWN0aW9ucz5cbiAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCAoY2xpY2spPVwiZW5kRWRpdChmYWxzZSwgJGV2ZW50KVwiPkNhbmNlbDwvYnV0dG9uPlxuICAgIDxidXR0b24gaWd4QnV0dG9uIGlneFJvd0VkaXRUYWJTdG9wIChjbGljayk9XCJlbmRFZGl0KHRydWUsICRldmVudClcIj5Eb25lPC9idXR0b24+XG48L25nLXRlbXBsYXRlPlxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Um93RWRpdFRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19tZXNzYWdlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWJhbm5lcl9fdGV4dFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0VkaXRUZXh0ID8gcm93RWRpdFRleHQgOiBkZWZhdWx0Um93RWRpdFRleHQ7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiByb3dDaGFuZ2VzQ291bnQgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1iYW5uZXJfX2FjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1iYW5uZXJfX3Jvd1wiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0VkaXRBY3Rpb25zID8gcm93RWRpdEFjdGlvbnMgOiBkZWZhdWx0Um93RWRpdEFjdGlvbnM7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBlbmRFZGl0LmJpbmQodGhpcykgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fb3V0bGV0XCIgI2lneEZpbHRlcmluZ092ZXJsYXlPdXRsZXQgaWd4T3ZlcmxheU91dGxldD48L2Rpdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZENvbXBvbmVudCBleHRlbmRzIElneEdyaWRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF9pZCA9IGBpZ3gtZ3JpZC0ke05FWFRfSUQrK31gO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwaW5nRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cGFuZFN0YXRlOiBJR3JvdXBCeUV4cGFuZFN0YXRlW10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cFJvd1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ3JvdXBpbmdEaWZmZXI7XG4gICAgcHJpdmF0ZSBfaGlkZUdyb3VwZWRDb2x1bW5zID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2lkXT1cIidpZ3gtZ3JpZC0xJ1wiIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZElkID0gdGhpcy5faWQ7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5yZXNldChvbGRJZCwgdGhpcy5faWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ3JpZEFQSTogSWd4R3JpZEFQSVNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50PixcbiAgICAgICAgc2VsZWN0aW9uOiBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KElneEdyaWRUcmFuc2FjdGlvbikgX3RyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25TZXJ2aWNlPFRyYW5zYWN0aW9uLCBTdGF0ZT4sXG4gICAgICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50LFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICByZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHZpZXdSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIG5hdmlnYXRpb246IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgZmlsdGVyaW5nU2VydmljZTogSWd4RmlsdGVyaW5nU2VydmljZSkge1xuICAgICAgICAgICAgc3VwZXIoZ3JpZEFQSSwgc2VsZWN0aW9uLCBfdHJhbnNhY3Rpb25zLCBlbGVtZW50UmVmLCB6b25lLCBkb2N1bWVudCwgY2RyLCByZXNvbHZlciwgZGlmZmVycywgdmlld1JlZiwgbmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmluZ1NlcnZpY2UpO1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSSA9IDxJZ3hHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyb3VwIGJ5IHN0YXRlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cEJ5U3RhdGUgPSB0aGlzLmdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBncm91cGluZ0V4cHJlc3Npb25zKCk6IElTb3J0aW5nRXhwcmVzc2lvbltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ3JvdXAgYnkgc3RhdGUgb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCBhbmQgZW1pdHMgdGhlIGBvbkdyb3VwaW5nRG9uZWBcbiAgICAgKiBldmVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBhcmd1bWVudHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cGluZ0V4cHJlc3Npb25zID0gW3tcbiAgICAgKiAgICAgZmllbGROYW1lOiBcIklEXCIsXG4gICAgICogICAgIGRpcjogU29ydGluZ0RpcmVjdGlvbi5Bc2MsXG4gICAgICogICAgIGlnbm9yZUNhc2U6IGZhbHNlXG4gICAgICogfV07XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGdyb3VwaW5nRXhwcmVzc2lvbnModmFsdWU6IElTb3J0aW5nRXhwcmVzc2lvbltdKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01heGltdW0gYW1vdW50IG9mIGdyb3VwZWQgY29sdW1ucyBpcyAxMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRFeHByZXNzaW9uczogQXJyYXk8SVNvcnRpbmdFeHByZXNzaW9uPiA9IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgICAgY29uc3QgbmV3RXhwcmVzc2lvbnM6IEFycmF5PElTb3J0aW5nRXhwcmVzc2lvbj4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucyA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICB0aGlzLmNoaXBzR291cGluZ0V4cHJlc3Npb25zID0gY2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9ncmlkQVBJLmdldCh0aGlzLmlkKSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5hcnJhbmdlX3NvcnRpbmdfZXhwcmVzc2lvbnModGhpcy5pZCk7XG4gICAgICAgICAgICAvKiBncm91cGluZyBzaG91bGQgd29yayBpbiBjb25qdW5jdGlvbiB3aXRoIHNvcnRpbmdcbiAgICAgICAgICAgIGFuZCB3aXRob3V0IG92ZXJyaWRpbmcgc2VwYXJhdGUgc29ydGluZyBleHByZXNzaW9ucyAqL1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlHcm91cGluZygpO1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXR0ZXIgY2FsbGVkIGJlZm9yZSBncmlkIGlzIHJlZ2lzdGVyZWQgaW4gZ3JpZCBBUEkgc2VydmljZVxuICAgICAgICAgICAgdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMudW5zaGlmdC5hcHBseSh0aGlzLnNvcnRpbmdFeHByZXNzaW9ucywgdGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KG9sZEV4cHJlc3Npb25zKSAhPT0gSlNPTi5zdHJpbmdpZnkobmV3RXhwcmVzc2lvbnMpICYmIHRoaXMuY29sdW1uTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBlZENvbHM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHVuZ3JvdXBlZENvbHM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzQXJyID0gbmV3RXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW9sZEV4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cGVkQ29sc0Fyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHMucHVzaCh0aGlzLmdldENvbHVtbkJ5TmFtZShlbGVtLmZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB1bmdyb3VwZWRDb2xzQXJyID0gb2xkRXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW5ld0V4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bmdyb3VwZWRDb2xzQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdEb25lQXJnczogSUdyb3VwaW5nRG9uZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbmV3RXhwcmVzc2lvbnMsXG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHVtbnM6IGdyb3VwZWRDb2xzLFxuICAgICAgICAgICAgICAgIHVuZ3JvdXBlZENvbHVtbnM6IHVuZ3JvdXBlZENvbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uR3JvdXBpbmdEb25lLmVtaXQoZ3JvdXBpbmdEb25lQXJncyk7XG4gICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGV4cGFuc2lvbiBzdGF0ZXMgZm9yIGdyb3VwIHJvd3MuXG4gICAgICogSW5jbHVkZXMgb25seSBzdGF0ZXMgdGhhdCBkaWZmZXIgZnJvbSB0aGUgZGVmYXVsdCBvbmUgKGNvbnRyb2xsZWQgdGhyb3VnaCBncm91cHNFeHBhbmRlZCBhbmQgc3RhdGVzIHRoYXQgdGhlIHVzZXIgaGFzIGNoYW5nZWQuXG4gICAgICogQ29udGFpbnMgdGhlIGV4cGFuc2lvbiBzdGF0ZSAoZXhwYW5kZWQ6IGJvb2xlYW4pIGFuZCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cCByb3cgKEFycmF5KS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBFeHBTdGF0ZSA9IHRoaXMuZ3JpZC5ncm91cGluZ0V4cGFuc2lvblN0YXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZ0V4cGFuZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBsaXN0IG9mIGV4cGFuc2lvbiBzdGF0ZXMgZm9yIGdyb3VwIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICAgICAgdGhpcy5ncmlkLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGUgPSBbe1xuICAgICAqICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAqICAgICAgaGllcmFyY2h5OiBbeyBmaWVsZE5hbWU6ICdJRCcsIHZhbHVlOiAxIH1dXG4gICAgICogICB9XTtcbiAgICAgKiAvLyBZb3UgY2FuIHVzZSBEYXRhVXRpbC5nZXRIaWVyYXJjaHkoZ3JvdXBSb3cpIHRvIGdldCB0aGUgZ3JvdXAgYElneEdyaWRSb3dDb21wb25lbnRgIGhpZXJhcmNoeS5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhY3RpdmVJbmZvID0gSWd4VGV4dEhpZ2hsaWdodERpcmVjdGl2ZS5oaWdobGlnaHRHcm91cHNNYXAuZ2V0KHRoaXMuaWQpO1xuXG4gICAgICAgIGxldCBoaWdobGlnaHRJdGVtID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkSGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRJdGVtID0gdGhpcy5jb2xsYXBzZWRIaWdobGlnaHRlZEl0ZW0uaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RTZWFyY2hJbmZvLm1hdGNoSW5mb0NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgaGlnaGxpZ2h0SXRlbSA9IHRoaXMubGFzdFNlYXJjaEluZm8ubWF0Y2hJbmZvQ2FjaGVbdGhpcy5sYXN0U2VhcmNoSW5mby5hY3RpdmVNYXRjaEluZGV4XS5pdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZSA9IGNsb25lQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaFNlYXJjaCgpO1xuXG4gICAgICAgIGlmIChoaWdobGlnaHRJdGVtICE9PSBudWxsICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maWx0ZXJlZFNvcnRlZERhdGEuaW5kZXhPZihoaWdobGlnaHRJdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwUm93ID0gdGhpcy5nZXRHcm91cEJ5UmVjb3JkcygpW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXhwYW5kZWRHcm91cChncm91cFJvdykpIHtcbiAgICAgICAgICAgICAgICBJZ3hUZXh0SGlnaGxpZ2h0RGlyZWN0aXZlLmNsZWFyQWN0aXZlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2VkSGlnaGxpZ2h0ZWRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmZvOiBhY3RpdmVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBoaWdobGlnaHRJdGVtXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2xsYXBzZWRIaWdobGlnaHRlZEl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsYXBzZWRJbmZvID0gdGhpcy5jb2xsYXBzZWRIaWdobGlnaHRlZEl0ZW0uaW5mbztcbiAgICAgICAgICAgICAgICBJZ3hUZXh0SGlnaGxpZ2h0RGlyZWN0aXZlLnNldEFjdGl2ZUhpZ2hsaWdodCh0aGlzLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2xsYXBzZWRJbmZvLmNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogY29sbGFwc2VkSW5mby5yb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbGxhcHNlZEluZm8uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IGNvbGxhcHNlZEluZm8ucGFnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgY3JlYXRlZCBncm91cHMgYXJlIHJlbmRlcmVkIGV4cGFuZGVkIG9yIGNvbGxhcHNlZC5cbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlZCBzdGF0ZSBpcyBleHBhbmRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbZ3JvdXBzRXhwYW5kZWRdPVwiZmFsc2VcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdyb3Vwc0V4cGFuZGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEEgaGllcmFyY2hpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncm91cCBieSByZWNvcmRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBSZWNvcmRzID0gdGhpcy5ncmlkLmdyb3Vwc1JlY29yZHM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdyb3Vwc1JlY29yZHM6IElHcm91cEJ5UmVjb3JkW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgd2hldGhlciB0aGUgZ3JvdXBlZCBjb2x1bW5zIHNob3VsZCBiZSBoaWRkZW4gYXMgd2VsbC5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcImZhbHNlXCJcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtoaWRlR3JvdXBlZENvbHVtbnNdPVwidHJ1ZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGhpZGVHcm91cGVkQ29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGVHcm91cGVkQ29sdW1ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGhpZGVHcm91cGVkQ29sdW1ucyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZCh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpLmNyZWF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0RpZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGlzdCAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgbWVzc2FnZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBHcm91cEJ5IGRyb3AgYXJlYSB3aGVyZSBjb2x1bW5zIGNhbiBiZSBkcmFnZ2VkIG9uLlxuICAgICAqIE5vdGU6IFRoZSBncmlkIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGdyb3VwYWJsZSBjb2x1bW4gaW4gb3JkZXIgdGhlIEdyb3VwQnkgYXJlYSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBkcm9wQXJlYU1lc3NhZ2U9XCJEcm9wIGhlcmUgdG8gZ3JvdXAhXCI+XG4gICAgICogICAgICA8aWd4LWNvbHVtbiBbZ3JvdXBhYmxlXT1cInRydWVcIiBmaWVsZD1cIklEXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJvcEFyZWFNZXNzYWdlID0gJ0RyYWcgYSBjb2x1bW4gaGVhZGVyIGFuZCBkcm9wIGl0IGhlcmUgdG8gZ3JvdXAgYnkgdGhhdCBjb2x1bW4uJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHRlbXBsYXRlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhcyBhIEdyb3VwQnkgZHJvcCBhcmVhLlxuICAgICAqIE5vdGU6IFRoZSBncmlkIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGdyb3VwYWJsZSBjb2x1bW4gaW4gb3JkZXIgdGhlIEdyb3VwQnkgYXJlYSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbZHJvcEFyZWFUZW1wbGF0ZV09XCJkcm9wQXJlYVJlZlwiPlxuICAgICAqICAgICAgPGlneC1jb2x1bW4gW2dyb3VwYWJsZV09XCJ0cnVlXCIgZmllbGQ9XCJJRFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqXG4gICAgICogPG5nLXRlbXBsYXRlICNteURyb3BBcmVhPlxuICAgICAqICAgICAgPHNwYW4+IEN1c3RvbSBkcm9wIGFyZWEhIDwvc3Bhbj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHRzXG4gICAgICogQFZpZXdDaGlsZCgnbXlEcm9wQXJlYScsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgZHJvcEFyZWFSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJvcEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIG5ldyBgSWd4Q29sdW1uQ29tcG9uZW50YCBnZXRzIGdyb3VwZWQvdW5ncm91cGVkLCBvciBtdWx0aXBsZSBjb2x1bW5zIGdldFxuICAgICAqIGdyb3VwZWQvdW5ncm91cGVkIGF0IG9uY2UgYnkgdXNpbmcgdGhlIEdyb3VwIEJ5IEFQSS5cbiAgICAgKiBUaGUgYG9uR3JvdXBpbmdEb25lYCBldmVudCB3b3VsZCBiZSByYWlzZWQgb25seSBvbmNlIGlmIHNldmVyYWwgY29sdW1ucyBnZXQgZ3JvdXBlZCBhdCBvbmNlIGJ5IGNhbGxpbmdcbiAgICAgKiB0aGUgYGdyb3VwQnkoKWAgb3IgYGNsZWFyR3JvdXBpbmcoKWAgQVBJIG1ldGhvZHMgYW5kIHBhc3NpbmcgYW4gYXJyYXkgYXMgYW4gYXJndW1lbnQuXG4gICAgICogVGhlIGV2ZW50IGFyZ3VtZW50cyBwcm92aWRlIHRoZSBgZXhwcmVzc2lvbnNgLCBgZ3JvdXBlZENvbHVtbnNgIGFuZCBgdW5ncm91cGVkQ29sdW1uc2AgcHJvcGVydGllcywgd2hpY2ggY29udGFpblxuICAgICAqIHRoZSBgSVNvcnRpbmdFeHByZXNzaW9uYCBhbmQgdGhlIGBJZ3hDb2x1bW5Db21wb25lbnRgIHJlbGF0ZWQgdG8gdGhlIGdyb3VwaW5nL3VuZ3JvdXBpbmcgb3BlcmF0aW9uLlxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgYGdyb3VwZWRDb2x1bW5zYCBhbmQgYHVuZ3JvdXBlZENvbHVtbnNgIHNob3cgb25seSB0aGUgKipuZXdseSoqIGNoYW5nZWQgY29sdW1ucyAoYWZmZWN0ZWQgYnkgdGhlICoqbGFzdCoqXG4gICAgICogZ3JvdXBpbmcvdW5ncm91cGluZyBvcGVyYXRpb24pLCBub3QgYWxsIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBncm91cGVkL3VuZ3JvdXBlZC5cbiAgICAgKiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBncm91cGluZ0RvbmUoZXZlbnQ6IElHcm91cGluZ0RvbmVFdmVudEFyZ3Mpe1xuICAgICAqICAgICBjb25zdCBleHByZXNzaW9ucyA9IGV2ZW50LmV4cHJlc3Npb25zO1xuICAgICAqICAgICAvL3RoZSBuZXdseSBncm91cGVkIGNvbHVtbnNcbiAgICAgKiAgICAgY29uc3QgZ3JvdXBlZENvbHVtbnMgPSBldmVudC5ncm91cGVkQ29sdW1ucztcbiAgICAgKiAgICAgLy90aGUgbmV3bHkgdW5ncm91cGVkIGNvbHVtbnNcbiAgICAgKiAgICAgY29uc3QgdW5ncm91cGVkQ29sdW1ucyA9IGV2ZW50LnVuZ3JvdXBlZENvbHVtbnM7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgKG9uR3JvdXBpbmdEb25lKT1cImdyb3VwaW5nRG9uZSgkZXZlbnQpXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Hcm91cGluZ0RvbmUgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cGluZ0RvbmVFdmVudEFyZ3M+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Gb2N1c0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyaWRGb2N1c0NoYW5nZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgZ3JvdXBUZW1wbGF0ZTogSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgQFZpZXdDaGlsZHJlbihJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCwgeyByZWFkOiBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCB9KVxuICAgIHByaXZhdGUgX2dyb3Vwc1Jvd0xpc3Q6IFF1ZXJ5TGlzdDxJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdERyb3BBcmVhJywgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBkZWZhdWx0RHJvcEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbGwgZ3JvdXAgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBMaXN0ID0gdGhpcy5ncmlkLmdyb3Vwc1Jvd0xpc3Q7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHNSb3dMaXN0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgUXVlcnlMaXN0PGFueT4oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNSb3dMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJMaXN0ID0gdGhpcy5fZ3JvdXBzUm93TGlzdC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLnJlc2V0KHJMaXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBBcmVhJylcbiAgICBwdWJsaWMgZ3JvdXBBcmVhOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFIb3N0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvc3k6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpZ3gtZHJvcC1hcmVhLS1jb3N5JztcbiAgICAgICAgICAgIGNhc2UgRGlzcGxheURlbnNpdHkuY29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2lneC1kcm9wLWFyZWEtLWNvbXBhY3QnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2lneC1kcm9wLWFyZWEnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCByb3cuXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZ3JvdXBSb3dUZW1wbGF0ZSA9IHRoaXMuZ3JpZC5ncm91cFJvd1RlbXBsYXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBncm91cFJvd1RlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGBJZ3hHcmlkUm93Q29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGUgPSBteVJvd1RlbXBsYXRlLlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBncm91cFJvd1RlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwUm93VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgJ3MgZ3JvdXAgYXJlYS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBBcmVhVGVtcGxhdGUgPSB0aGlzLmdyaWQuZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGdyb3VwQXJlYVRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCBhcmVhLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBBcmVhVGVtcGxhdGUgPSBteUFyZWFUZW1wbGF0ZS5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBBcmVhVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBBcmVhVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYnkgYSBuZXcgYElneENvbHVtbkNvbXBvbmVudGAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGV4cHJlc3Npb24sIG9yIG1vZGlmaWVzIGFuIGV4aXN0aW5nIG9uZS5cbiAgICAgKiBBbHNvIGFsbG93cyBmb3IgbXVsdGlwbGUgY29sdW1ucyB0byBiZSBncm91cGVkIGF0IG9uY2UgaWYgYW4gYXJyYXkgb2YgYElTb3J0aW5nRXhwcmVzc2lvbmAgaXMgcGFzc2VkLlxuICAgICAqIFRoZSBvbkdyb3VwaW5nRG9uZSBldmVudCB3b3VsZCBnZXQgcmFpc2VkIG9ubHkgKipvbmNlKiogaWYgdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5KHsgZmllbGROYW1lOiBuYW1lLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9KTtcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBCeShbXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTEsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5Bc2MsIGlnbm9yZUNhc2U6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTIsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiB0cnVlIH0sXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTMsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9XG4gICAgICAgIF0pO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cEJ5KGV4cHJlc3Npb246IElTb3J0aW5nRXhwcmVzc2lvbiB8IEFycmF5PElTb3J0aW5nRXhwcmVzc2lvbj4pOiB2b2lkO1xuICAgIHB1YmxpYyBncm91cEJ5KC4uLnJlc3QpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbmRFZGl0KHRydWUpO1xuICAgICAgICB0aGlzLl9ncmlkQVBJLnN1Ym1pdF92YWx1ZSh0aGlzLmlkKTtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAxICYmIHJlc3RbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBCeU11bHRpcGxlKHJlc3RbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBCeShyZXN0WzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlR3JpZFNpemVzKCk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhpZ2hsaWdodCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZ3JvdXBpbmcgaW4gdGhlIGdyaWQsIGlmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQuXG4gICAgICogSWYgYSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIGNsZWFycyBncm91cGluZyBmb3IgYSBwYXJ0aWN1bGFyIGNvbHVtbiBvciBhbiBhcnJheSBvZiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZygpOyAvL2NsZWFycyBhbGwgZ3JvdXBpbmdcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZyhcIklEXCIpOyAvL3VuZ3JvdXBzIGEgc2luZ2xlIGNvbHVtblxuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKFtcIklEXCIsIFwiQ29sdW1uMVwiLCBcIkNvbHVtbjJcIl0pOyAvL3VuZ3JvdXBzIG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhckdyb3VwaW5nKG5hbWU/OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuY2xlYXJfZ3JvdXBieSh0aGlzLmlkLCBuYW1lKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVHcmlkU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGlnaGxpZ2h0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBhIGdyb3VwIGlzIGV4cGFuZGVkIG9yIG5vdC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAgKiBjb25zdCBleHBhbmRlZEdyb3VwID0gdGhpcy5ncmlkLmlzRXhwYW5kZWRHcm91cCh0aGlzLmdyb3VwUm93KTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNFeHBhbmRlZEdyb3VwKGdyb3VwOiBJR3JvdXBCeVJlY29yZCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzdGF0ZTogSUdyb3VwQnlFeHBhbmRTdGF0ZSA9IHRoaXMuX2dldFN0YXRlRm9yR3JvdXBSb3coZ3JvdXApO1xuICAgICAgICByZXR1cm4gc3RhdGUgPyBzdGF0ZS5leHBhbmRlZCA6IHRoaXMuZ3JvdXBzRXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIGEgZ3JvdXAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgdG9nZ2xlRXhwR3JvdXAgPSB0aGlzLmdyaWQudG9nZ2xlR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZUdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl90b2dnbGVHcm91cChncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBpc0dyb3VwQnlSZWNvcmQocmVjb3JkOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgLy8gcmV0dXJuIHJlY29yZC5yZWNvcmRzIGluc3RhbmNlIG9mIEdyb3VwZWRSZWNvcmRzIGZhaWxzIHVuZGVyIFdlYnBhY2tcbiAgICAgICAgcmV0dXJuIHJlY29yZC5yZWNvcmRzICYmIHJlY29yZC5yZWNvcmRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgYWxsIGdyb3VwIHJvd3MgcmVjdXJzaXZlbHkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC50b2dnbGVBbGxHcm91cFJvd3M7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZUFsbEdyb3VwUm93cygpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBzRXhwYW5kZWQgPSAhdGhpcy5ncm91cHNFeHBhbmRlZDtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCBoYXMgZ3JvdXBhYmxlIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwYWJsZUdyaWQgPSB0aGlzLmdyaWQuaGFzR3JvdXBhYmxlQ29sdW1ucztcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGFzR3JvdXBhYmxlQ29sdW1ucygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTGlzdC5zb21lKChjb2wpID0+IGNvbC5ncm91cGFibGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZvckVhY2goKGV4cHIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKTtcbiAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZ3JpZCdzIGdyb3VwIGJ5IGRyb3AgYXJlYSBpcyB2aXNpYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBkcm9wVmlzaWJsZSA9IHRoaXMuZ3JpZC5kcm9wQXJlYVZpc2libGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBkcm9wQXJlYVZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5kcmFnZ2VkQ29sdW1uICYmIHRoaXMuZHJhZ2dlZENvbHVtbi5ncm91cGFibGUpIHx8XG4gICAgICAgICAgICAhdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBCeShleHByZXNzaW9uOiBJU29ydGluZ0V4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5KHRoaXMuaWQsIGV4cHJlc3Npb24uZmllbGROYW1lLCBleHByZXNzaW9uLmRpciwgZXhwcmVzc2lvbi5pZ25vcmVDYXNlLCBleHByZXNzaW9uLnN0cmF0ZWd5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cEJ5TXVsdGlwbGUoZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeV9tdWx0aXBsZSh0aGlzLmlkLCBleHByZXNzaW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ2V0U3RhdGVGb3JHcm91cFJvdyhncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpOiBJR3JvdXBCeUV4cGFuZFN0YXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeV9nZXRfZXhwYW5kZWRfZm9yX2dyb3VwKHRoaXMuaWQsIGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF90b2dnbGVHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X3RvZ2dsZV9ncm91cCh0aGlzLmlkLCBncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlHcm91cGluZygpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5zb3J0X211bHRpcGxlKHRoaXMuaWQsIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICBwdWJsaWMgZ2V0Q29udGV4dChyb3dEYXRhKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogcm93RGF0YSxcbiAgICAgICAgICAgIHRlbXBsYXRlSUQ6IHRoaXMuaXNHcm91cEJ5UmVjb3JkKHJvd0RhdGEpID8gJ2dyb3VwUm93JyA6ICdkYXRhUm93J1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRoaXMgbWV0aG9kJ3MgaWRlYSBpcyB0byBnZXQgYnkgaG93IG11Y2ggZWFjaCBkYXRhIHJvdyBpcyBvZmZzZXQgYnkgdGhlIGdyb3VwIGJ5IHJvd3MgYmVmb3JlIGl0LlxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHJvdGVjdGVkIGdldEdyb3VwSW5jcmVtZW50RGF0YSgpOiBudW1iZXJbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBzUmVjb3JkcyA9IHRoaXMuZ2V0R3JvdXBCeVJlY29yZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwQnlJbmNyZW1lbnRzID0gW107XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgbGV0IHByZXZIaWVyYXJjaHkgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IDA7XG5cbiAgICAgICAgICAgIGdyb3Vwc1JlY29yZHMuZm9yRWFjaCgoZ2JyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKGdicikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZXZlbEluY3JlbWVudCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZIaWVyYXJjaHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsSW5jcmVtZW50ICs9IHRoaXMuZ2V0TGV2ZWxJbmNyZW1lbnQoMCwgZ2JyLmdyb3VwUGFyZW50LCBwcmV2SGllcmFyY2h5Lmdyb3VwUGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGxldmVsIHdlIHN0dW1ibGUgdXBvbiwgc28gd2UgaGF2ZW4ndCBhY2NvdW50ZWQgZm9yIGFueSBvZiBpdHMgcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxJbmNyZW1lbnQgKz0gZ2JyLmxldmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ICs9IGxldmVsSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgICAgICBwcmV2SGllcmFyY2h5ID0gZ2JyO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChnYnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyb3VwQnlJbmNyZW1lbnRzLnB1c2goaW5jcmVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQnlJbmNyZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldExldmVsSW5jcmVtZW50KGN1cnJlbnRJbmNyZW1lbnQsIGN1cnJlbnRIaWVyYXJjaHksIHByZXZIaWVyYXJjaHkpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRIaWVyYXJjaHkgIT09IHByZXZIaWVyYXJjaHkgJiYgISFwcmV2SGllcmFyY2h5ICYmICEhY3VycmVudEhpZXJhcmNoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGV2ZWxJbmNyZW1lbnQoKytjdXJyZW50SW5jcmVtZW50LCBjdXJyZW50SGllcmFyY2h5Lmdyb3VwUGFyZW50LCBwcmV2SGllcmFyY2h5Lmdyb3VwUGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5jcmVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRHcm91cEJ5UmVjb3JkcygpOiBJR3JvdXBCeVJlY29yZFtdIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uczogdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLFxuICAgICAgICAgICAgICAgIGV4cGFuc2lvbjogdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRFeHBhbmRlZDogdGhpcy5ncm91cHNFeHBhbmRlZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIERhdGFVdGlsLmdyb3VwKGNsb25lQXJyYXkodGhpcy5maWx0ZXJlZFNvcnRlZERhdGEpLCBzdGF0ZSkubWV0YWRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25DaGlwUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJHcm91cGluZyhldmVudC5vd25lci5pZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjaGlwc09yZGVyQ2hhbmdlZChldmVudDogSUNoaXBzQXJlYVJlb3JkZXJFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmV3R3JvdXBpbmcgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC5jaGlwc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZpZWxkTmFtZSA9PT0gZXZlbnQuY2hpcHNBcnJheVtpXS5pZDtcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKS5ncm91cGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBkaXNhbGxvdyBjaGFuZ2luZyBvcmRlciBpZiB0aGVyZSBhcmUgY29sdW1ucyB3aXRoIGdyb3VwYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdHcm91cGluZy5wdXNoKGV4cHIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLmNoaXBzR291cGluZ0V4cHJlc3Npb25zID0gbmV3R3JvdXBpbmc7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBXaGVuIHJlb3JkZXJlZCB1c2luZyBrZXlib2FyZCBuYXZpZ2F0aW9uLCB3ZSBkb24ndCBoYXZlIGBvbk1vdmVFbmRgIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zID0gdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpcHNNb3ZpbmdFbmRlZCgpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zID0gdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcENsaWNrZWQoZXZlbnQ6IElDaGlwQ2xpY2tFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc29ydGluZ0V4cHIgPSB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucztcbiAgICAgICAgY29uc3QgY29sdW1uRXhwciA9IHNvcnRpbmdFeHByLmZpbmQoKGV4cHIpID0+IGV4cHIuZmllbGROYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIGNvbHVtbkV4cHIuZGlyID0gMyAtIGNvbHVtbkV4cHIuZGlyO1xuICAgICAgICB0aGlzLnNvcnQoY29sdW1uRXhwcik7XG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoaXBLZXlEb3duKGV2ZW50OiBJQ2hpcEtleURvd25FdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSAnICcgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5rZXkgPT09ICdTcGFjZWJhcicgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRpbmdFeHByID0gdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnM7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5FeHByID0gc29ydGluZ0V4cHIuZmluZCgoZXhwcikgPT4gZXhwci5maWVsZE5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgICAgIGNvbHVtbkV4cHIuZGlyID0gMyAtIGNvbHVtbkV4cHIuZGlyO1xuICAgICAgICAgICAgdGhpcy5zb3J0KGNvbHVtbkV4cHIpO1xuICAgICAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0R3JvdXBBcmVhSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwQXJlYSA/IHRoaXMuZ3JvdXBBcmVhLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIHBpbm5lZCBhcmVhLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwaW5uZWRXaWR0aCA9IHRoaXMuZ3JpZC5nZXRQaW5uZWRXaWR0aCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB0YWtlSGlkZGVuIElmIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCB0aGUgaGlkZGVuIGNvbHVtbnMgaW4gdGhlIHBpbm5lZCBhcmVhLlxuICAgICAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldFBpbm5lZFdpZHRoKHRha2VIaWRkZW4gPSBmYWxzZSkge1xuICAgICAgICBsZXQgc3VtID0gc3VwZXIuZ2V0UGlubmVkV2lkdGgodGFrZUhpZGRlbik7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGggPiAwICYmIHRoaXMuaGVhZGVyR3JvdXBDb250YWluZXIpIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLmhlYWRlckdyb3VwQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNjcm9sbFRvKHJvdzogbnVtYmVyLCBjb2x1bW46IG51bWJlciwgcGFnZTogbnVtYmVyLCBncm91cEJ5UmVjb3JkPzogSUdyb3VwQnlSZWNvcmQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGdyb3VwQnlSZWNvcmQgJiYgIXRoaXMuaXNFeHBhbmRlZEdyb3VwKGdyb3VwQnlSZWNvcmQpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUdyb3VwKGdyb3VwQnlSZWNvcmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuc2Nyb2xsVG8ocm93LCBjb2x1bW4sIHBhZ2UsIGdyb3VwQnlSZWNvcmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZUZpbHRlcmVkU29ydGVkRGF0YSgpOiBhbnlbXSB7XG4gICAgICAgIGxldCBkYXRhOiBhbnlbXSA9IHN1cGVyLnJlc29sdmVGaWx0ZXJlZFNvcnRlZERhdGEoKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuc29ydGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29uc3Qgc29ydGluZ1BpcGUgPSBuZXcgSWd4R3JpZFNvcnRpbmdQaXBlKHRoaXMuX2dyaWRBUEkpO1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRpbmdQaXBlLnRyYW5zZm9ybShkYXRhLCB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucywgdGhpcy5pZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICBwdWJsaWMgZ2V0IGRyb3BBcmVhVGVtcGxhdGVSZXNvbHZlZCgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcEFyZWFUZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcEFyZWFUZW1wbGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHREcm9wQXJlYVRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwUm93VGVtcGxhdGUgPSB0aGlzLmdyb3VwVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oaWRlR3JvdXBlZENvbHVtbnMgJiYgdGhpcy5jb2x1bW5MaXN0ICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh0aGlzLmhpZGVHcm91cGVkQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLm9uR3JvdXBpbmdEb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5lbmRFZGl0KHRydWUpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5ncm91cGluZ0RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZ3JvdXBpbmdEaWZmZXIuZGlmZih0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiYgdGhpcy5jb2x1bW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiJdfQ==