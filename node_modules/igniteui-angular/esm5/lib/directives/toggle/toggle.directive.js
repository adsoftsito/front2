/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, Optional, Output, Inject } from '@angular/core';
import { IgxNavigationService } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { ConnectedPositioningStrategy, AbsoluteScrollStrategy } from '../../services';
import { filter, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
var IgxToggleDirective = /** @class */ (function () {
    /**
     * @hidden
     */
    function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
        var _this = this;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(function (x) { return x.id === _this._overlayId; })
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        this.overlayClosed = function () {
            _this._collapsed = true;
            _this.cdr.detectChanges();
            delete _this._overlayId;
            _this.onClosed.emit();
            _this.unsubscribe();
        };
    }
    Object.defineProperty(IgxToggleDirective.prototype, "collapsed", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "element", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "hiddenClass", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "defaultClass", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.open = /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        var _this = this;
        this._collapsed = false;
        this.cdr.detectChanges();
        var /** @type {?} */ openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        if (this._overlayId) {
            this.overlayService.show(this._overlayId, overlaySettings);
        }
        else {
            this._overlayId = this.overlayService.show(this.elementRef, overlaySettings);
        }
        this.unsubscribe();
        this._overlayOpenedSub = (_a = this.overlayService.onOpened).pipe.apply(_a, tslib_1.__spread(this._overlaySubFilter, [takeUntil(this.destroy$)])).subscribe(function () {
            _this.onOpened.emit();
        });
        this._overlayClosingSub = (_b = this.overlayService
            .onClosing).pipe.apply(_b, tslib_1.__spread(this._overlaySubFilter, [takeUntil(this.destroy$)])).subscribe(function (e) {
            var /** @type {?} */ eventArgs = { cancel: false };
            _this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                _this.clearSubscription(_this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = (_c = this.overlayService.onClosed).pipe.apply(_c, tslib_1.__spread(this._overlaySubFilter, [takeUntil(this.destroy$)])).subscribe(this.overlayClosed);
        var _a, _b, _c;
    };
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.close = /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    function () {
        this.overlayService.hide(this._overlayId);
    };
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.toggle = /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        this.collapsed ? this.open(overlaySettings) : this.close();
    };
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.reposition = /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    function () {
        this.overlayService.reposition(this._overlayId);
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @return {?}
     */
    IgxToggleDirective.prototype.unsubscribe = /**
     * @return {?}
     */
    function () {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    IgxToggleDirective.prototype.clearSubscription = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    };
    IgxToggleDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]'
                },] },
    ];
    /** @nocollapse */
    IgxToggleDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] },] },
        { type: IgxNavigationService, decorators: [{ type: Optional },] },
    ]; };
    IgxToggleDirective.propDecorators = {
        "onOpened": [{ type: Output },],
        "onOpening": [{ type: Output },],
        "onClosed": [{ type: Output },],
        "onClosing": [{ type: Output },],
        "id": [{ type: Input },],
        "hiddenClass": [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] },],
        "defaultClass": [{ type: HostBinding, args: ['class.igx-toggle',] },],
    };
    return IgxToggleDirective;
}());
export { IgxToggleDirective };
function IgxToggleDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxToggleDirective.propDecorators;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayId;
    /** @type {?} */
    IgxToggleDirective.prototype.destroy$;
    /** @type {?} */
    IgxToggleDirective.prototype._overlaySubFilter;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayOpenedSub;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayClosingSub;
    /** @type {?} */
    IgxToggleDirective.prototype._overlayClosedSub;
    /**
     * Emits an event after the toggle container is opened.
     *
     * ```typescript
     * onToggleOpened(event) {
     *    alert("Toggle opened!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpened)='onToggleOpened($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpened;
    /**
     * Emits an event before the toggle container is opened.
     *
     * ```typescript
     * onToggleOpening(event) {
     *  alert("Toggle opening!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpening)='onToggleOpening($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpening;
    /**
     * Emits an event after the toggle container is closed.
     *
     * ```typescript
     * onToggleClosed(event) {
     *  alert("Toggle closed!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onClosed)='onToggleClosed($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosed;
    /**
     * Emits an event before the toggle container is closed.
     *
     * ```typescript
     * onToggleClosing(event) {
     *  alert("Toggle closing!");
     * }
     * ```
     *
     * ```html
     * <div
     *  igxToggle
     *  (onClosing)='onToggleClosing($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosing;
    /** @type {?} */
    IgxToggleDirective.prototype._collapsed;
    /**
     * Identifier which is registered into `IgxNavigationService`
     *
     * ```typescript
     * let myToggleId = this.toggle.id;
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.id;
    /** @type {?} */
    IgxToggleDirective.prototype.overlayClosed;
    /** @type {?} */
    IgxToggleDirective.prototype.elementRef;
    /** @type {?} */
    IgxToggleDirective.prototype.cdr;
    /** @type {?} */
    IgxToggleDirective.prototype.overlayService;
    /** @type {?} */
    IgxToggleDirective.prototype.navigationService;
}
var IgxToggleActionDirective = /** @class */ (function () {
    function IgxToggleActionDirective(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    Object.defineProperty(IgxToggleActionDirective.prototype, "closeOnOutsideClick", {
        get: /**
         * DEPRECATED. Determines whether the toggle should close when you click outside.
         *
         * ```typescript
         * // get
         * let closesOnOutsideClick = this.toggle.closeOnOutsideClick;
         * ```
         * @return {?}
         */
        function () {
            return this._closeOnOutsideClick;
        },
        set: /**
         * ```html
         * <!--set-->
         * <div igxToggleAction [closeOnOutsideClick]="'true'"></div>
         * ```
         * @param {?} v
         * @return {?}
         */
        function (v) {
            console.warn("igxToggleAction 'closeOnOutsideClick' input is deprecated. Use 'overlaySettings' input object instead.");
            this._closeOnOutsideClick = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleActionDirective.prototype, "target", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (typeof this._target === 'string') {
                return this.navigationService.get(this._target);
            }
            return this._target;
        },
        set: /**
         * @hidden
         * @param {?} target
         * @return {?}
         */
        function (target) {
            if (target !== null && target !== '') {
                this._target = target;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false
        };
    };
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.onClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.closeOnOutsideClick !== undefined) {
            this._overlayDefaults.closeOnOutsideClick = this.closeOnOutsideClick;
        }
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        if (this.overlaySettings && this.overlaySettings.positionStrategy && !this.overlaySettings.positionStrategy.settings.target) {
            this.overlaySettings.positionStrategy.settings.target = this.element.nativeElement;
        }
        this.target.toggle(Object.assign({}, this._overlayDefaults, this.overlaySettings));
    };
    IgxToggleActionDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]'
                },] },
    ];
    /** @nocollapse */
    IgxToggleActionDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: IgxNavigationService, decorators: [{ type: Optional },] },
    ]; };
    IgxToggleActionDirective.propDecorators = {
        "overlaySettings": [{ type: Input },],
        "closeOnOutsideClick": [{ type: Input },],
        "outlet": [{ type: Input, args: ['igxToggleOutlet',] },],
        "target": [{ type: Input, args: ['igxToggleAction',] },],
        "onClick": [{ type: HostListener, args: ['click',] },],
    };
    return IgxToggleActionDirective;
}());
export { IgxToggleActionDirective };
function IgxToggleActionDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleActionDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleActionDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    IgxToggleActionDirective.propDecorators;
    /** @type {?} */
    IgxToggleActionDirective.prototype._overlayDefaults;
    /**
     * Provide settings that control the toggle overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: false,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <!--set-->
     * <div igxToggleAction [overlaySettings]="settings"></div>
     * ```
     * @type {?}
     */
    IgxToggleActionDirective.prototype.overlaySettings;
    /** @type {?} */
    IgxToggleActionDirective.prototype._closeOnOutsideClick;
    /**
     * Determines where the toggle element overlay should be attached.
     *
     * ```html
     * <!--set-->
     * <div igxToggleAction [igxToggleOutlet]="outlet"></div>
     * ```
     * Where `outlet` in an instance of `IgxOverlayOutletDirective` or an `ElementRef`
     * @type {?}
     */
    IgxToggleActionDirective.prototype.outlet;
    /** @type {?} */
    IgxToggleActionDirective.prototype._target;
    /** @type {?} */
    IgxToggleActionDirective.prototype.element;
    /** @type {?} */
    IgxToggleActionDirective.prototype.navigationService;
}
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
var IgxOverlayOutletDirective = /** @class */ (function () {
    function IgxOverlayOutletDirective(element) {
        this.element = element;
    }
    Object.defineProperty(IgxOverlayOutletDirective.prototype, "nativeElement", {
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    IgxOverlayOutletDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]'
                },] },
    ];
    /** @nocollapse */
    IgxOverlayOutletDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    return IgxOverlayOutletDirective;
}());
export { IgxOverlayOutletDirective };
function IgxOverlayOutletDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxOverlayOutletDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxOverlayOutletDirective.ctorParameters;
    /** @type {?} */
    IgxOverlayOutletDirective.prototype.element;
}
var IgxToggleModule = /** @class */ (function () {
    function IgxToggleModule() {
    }
    IgxToggleModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    providers: [IgxNavigationService]
                },] },
    ];
    return IgxToggleModule;
}());
export { IgxToggleModule };
function IgxToggleModule_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    IgxToggleModule.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    IgxToggleModule.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsUUFBUSxFQUdSLFFBQVEsRUFDUixNQUFNLEVBQ04sTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBZSxNQUFNLHVCQUF1QixDQUFDO0FBQzFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFBcUMsNEJBQTRCLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6SCxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25ELE9BQU8sRUFBa0MsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDOztJQXdJM0Q7O09BRUc7SUFDSCw0QkFDWSxZQUNBLEtBQzJCLGdCQUNmO1FBSnhCLGlCQUtDO1FBSlcsZUFBVSxHQUFWLFVBQVU7UUFDVixRQUFHLEdBQUgsR0FBRztRQUN3QixtQkFBYyxHQUFkLGNBQWM7UUFDN0Isc0JBQWlCLEdBQWpCLGlCQUFpQjt3QkFySXRCLElBQUksT0FBTyxFQUFXO2lDQUMyQztZQUNoRixNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUksQ0FBQyxVQUFVLEVBQXhCLENBQXdCLENBQUM7U0FDeEM7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQXNCaUIsSUFBSSxZQUFZLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQW1CakIsSUFBSSxZQUFZLEVBQXVCOzs7Ozs7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Ozs7Ozs7Ozs7O0lBMEhqQyxtQ0FBbUIsT0FBbUI7UUFBbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtLQUFLOzBCQUdoQyxvREFBYTs7Ozs7O1lBQ3BCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQzs7Ozs7O2dCQVR6QyxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsUUFBUSxFQUFFLG9CQUFvQjtpQkFDakM7Ozs7Z0JBNVpHLFVBQVU7O29DQUhkOztTQWdhYSx5QkFBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBU3JDLFFBQVEsU0FBQztvQkFDTixZQUFZLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSx3QkFBd0IsRUFBRSx5QkFBeUIsQ0FBQztvQkFDdkYsT0FBTyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLENBQUM7b0JBQ2xGLFNBQVMsRUFBRSxDQUFDLG9CQUFvQixDQUFDO2lCQUNwQzs7MEJBN2FEOztTQThhYSxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIEluamVjdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uLy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQgeyBPdmVybGF5U2V0dGluZ3MsIE92ZXJsYXlFdmVudEFyZ3MsIENvbm5lY3RlZFBvc2l0aW9uaW5nU3RyYXRlZ3ksIEFic29sdXRlU2Nyb2xsU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgT3BlcmF0b3JGdW5jdGlvbiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgT3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9vdmVybGF5L3V0aWxpdGllcyc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAndG9nZ2xlJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hUb2dnbGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hUb2dnbGVEaXJlY3RpdmUgaW1wbGVtZW50cyBJVG9nZ2xlVmlldywgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX292ZXJsYXlJZDogc3RyaW5nO1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByaXZhdGUgX292ZXJsYXlTdWJGaWx0ZXI6IE9wZXJhdG9yRnVuY3Rpb248T3ZlcmxheUV2ZW50QXJncywgT3ZlcmxheUV2ZW50QXJncz5bXSA9IFtcbiAgICAgICAgZmlsdGVyKHggPT4geC5pZCA9PT0gdGhpcy5fb3ZlcmxheUlkKVxuICAgIF07XG4gICAgcHJpdmF0ZSBfb3ZlcmxheU9wZW5lZFN1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NlZFN1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmVkKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJUb2dnbGUgb3BlbmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuZWQpPSdvblRvZ2dsZU9wZW5lZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25PcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmluZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBvcGVuaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuaW5nKT0nb25Ub2dnbGVPcGVuaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbk9wZW5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyPENhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVDbG9zZWQoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25DbG9zZWQpPSdvblRvZ2dsZUNsb3NlZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25DbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlQ2xvc2luZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBjbG9zaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICBpZ3hUb2dnbGVcbiAgICAgKiAgKG9uQ2xvc2luZyk9J29uVG9nZ2xlQ2xvc2luZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25DbG9zaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxDYW5jZWxhYmxlRXZlbnRBcmdzPigpO1xuXG4gICAgcHJpdmF0ZSBfY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllciB3aGljaCBpcyByZWdpc3RlcmVkIGludG8gYElneE5hdmlnYXRpb25TZXJ2aWNlYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBteVRvZ2dsZUlkID0gdGhpcy50b2dnbGUuaWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdG9nZ2xlLS1oaWRkZW4nKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhpZGRlbicpXG4gICAgcHVibGljIGdldCBoaWRkZW5DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUnKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoSWd4T3ZlcmxheVNlcnZpY2UpIHByaXZhdGUgb3ZlcmxheVNlcnZpY2U6IElneE92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9wZW4ob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAgICAgY29uc3Qgb3BlbkV2ZW50QXJnczogQ2FuY2VsYWJsZUV2ZW50QXJncyA9IHsgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLm9uT3BlbmluZy5lbWl0KG9wZW5FdmVudEFyZ3MpO1xuICAgICAgICBpZiAob3BlbkV2ZW50QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheUlkKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLnNob3codGhpcy5fb3ZlcmxheUlkLCBvdmVybGF5U2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUlkID0gdGhpcy5vdmVybGF5U2VydmljZS5zaG93KHRoaXMuZWxlbWVudFJlZiwgb3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheU9wZW5lZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2Uub25PcGVuZWQucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uT3BlbmVkLmVtaXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViID0gdGhpcy5vdmVybGF5U2VydmljZVxuICAgICAgICAgICAgLm9uQ2xvc2luZ1xuICAgICAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlciwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZTogT3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEFyZ3M6IENhbmNlbGFibGVFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2luZy5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgZS5jYW5jZWwgPSBldmVudEFyZ3MuY2FuY2VsO1xuXG4gICAgICAgICAgICAgICAgLy8gIGluIGNhc2UgZXZlbnQgaXMgbm90IGNhbmNlbGVkIHRoaXMgd2lsbCBjbG9zZSB0aGUgdG9nZ2xlIGFuZCB3ZSBuZWVkIHRvIHVuc3Vic2NyaWJlLlxuICAgICAgICAgICAgICAgIC8vICBPdGhlcndpc2UgaWYgZm9yIHNvbWUgcmVhc29uLCBlLmcuIGNsb3NlIG9uIG91dHNpZGUgY2xpY2ssIGNsb3NlKCkgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gIG9uQ2xvc2VkIHdhcyBmaXJlZCB3ZSB3aWxsIGVuZCB3aXRoIGNhbGxpbmcgb25DbG9zaW5nIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFlLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNsb3NlZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2Uub25DbG9zZWRcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIsIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vdmVybGF5Q2xvc2VkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRvZ2dsZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGNsb3NlKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLmhpZGUodGhpcy5fb3ZlcmxheUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBvciBjbG9zZXMgdGhlIHRvZ2dsZSwgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZShvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPyB0aGlzLm9wZW4ob3ZlcmxheVNldHRpbmdzKSA6IHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9ucyB0aGUgdG9nZ2xlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnJlcG9zaXRpb24oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVwb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5yZXBvc2l0aW9uKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hZGQodGhpcy5pZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZSAmJiB0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2VkICYmIHRoaXMuX292ZXJsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5oaWRlKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG92ZXJsYXlDbG9zZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX292ZXJsYXlJZDtcbiAgICAgICAgdGhpcy5vbkNsb3NlZC5lbWl0KCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlPcGVuZWRTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2VkU3ViKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZS1hY3Rpb24nLFxuICAgIHNlbGVjdG9yOiAnW2lneFRvZ2dsZUFjdGlvbl0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSB0b2dnbGUgb3ZlcmxheSBwb3NpdGlvbmluZywgaW50ZXJhY3Rpb24gYW5kIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgICAqICAgICAgbW9kYWw6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBgYGBcbiAgICAgKiAtLS1cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtvdmVybGF5U2V0dGluZ3NdPVwic2V0dGluZ3NcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIHByaXZhdGUgX2Nsb3NlT25PdXRzaWRlQ2xpY2s6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogREVQUkVDQVRFRC4gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0b2dnbGUgc2hvdWxkIGNsb3NlIHdoZW4geW91IGNsaWNrIG91dHNpZGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IGNsb3Nlc09uT3V0c2lkZUNsaWNrID0gdGhpcy50b2dnbGUuY2xvc2VPbk91dHNpZGVDbGljaztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNsb3NlT25PdXRzaWRlQ2xpY2soKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZU9uT3V0c2lkZUNsaWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtjbG9zZU9uT3V0c2lkZUNsaWNrXT1cIid0cnVlJ1wiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBjbG9zZU9uT3V0c2lkZUNsaWNrKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBpZ3hUb2dnbGVBY3Rpb24gJ2Nsb3NlT25PdXRzaWRlQ2xpY2snIGlucHV0IGlzIGRlcHJlY2F0ZWQuIFVzZSAnb3ZlcmxheVNldHRpbmdzJyBpbnB1dCBvYmplY3QgaW5zdGVhZC5gKTtcbiAgICAgICAgdGhpcy5fY2xvc2VPbk91dHNpZGVDbGljayA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGVyZSB0aGUgdG9nZ2xlIGVsZW1lbnQgb3ZlcmxheSBzaG91bGQgYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtpZ3hUb2dnbGVPdXRsZXRdPVwib3V0bGV0XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogV2hlcmUgYG91dGxldGAgaW4gYW4gaW5zdGFuY2Ugb2YgYElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmVgIG9yIGFuIGBFbGVtZW50UmVmYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4VG9nZ2xlT3V0bGV0JylcbiAgICBwdWJsaWMgb3V0bGV0OiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHwgRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneFRvZ2dsZUFjdGlvbicpXG4gICAgc2V0IHRhcmdldCh0YXJnZXQ6IGFueSkge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCk6IGFueSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZ2V0KHRoaXMuX3RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RhcmdldDogSVRvZ2dsZVZpZXcgfCBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIEBPcHRpb25hbCgpIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlEZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IG5ldyBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5KHsgdGFyZ2V0OiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCB9KSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiBuZXcgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSgpLFxuICAgICAgICAgICAgY2xvc2VPbk91dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGFsOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgcHVibGljIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzLmNsb3NlT25PdXRzaWRlQ2xpY2sgPSB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMub3V0bGV0ID0gdGhpcy5vdXRsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVNldHRpbmdzICYmIHRoaXMub3ZlcmxheVNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kgJiYgIXRoaXMub3ZlcmxheVNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kuc2V0dGluZ3MudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlTZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LnNldHRpbmdzLnRhcmdldCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0LnRvZ2dsZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vdmVybGF5RGVmYXVsdHMsIHRoaXMub3ZlcmxheVNldHRpbmdzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1hcmsgYW4gZWxlbWVudCBhcyBhbiBpZ3hPdmVybGF5IG91dGxldCBjb250YWluZXIuXG4gKiBEaXJlY3RpdmUgaW5zdGFuY2UgaXMgZXhwb3J0ZWQgYXMgYG92ZXJsYXktb3V0bGV0YCB0byBiZSBhc3NpZ25lZCB0byB0ZW1wbGF0ZXMgdmFyaWFibGVzOlxuICogYGBgaHRtbFxuICogPGRpdiBpZ3hPdmVybGF5T3V0bGV0ICNvdXRsZXQ9XCJvdmVybGF5LW91dGxldFwiPjwvZGl2PlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnb3ZlcmxheS1vdXRsZXQnLFxuICAgIHNlbGVjdG9yOiAnW2lneE92ZXJsYXlPdXRsZXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZikgeyB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hUb2dnbGVEaXJlY3RpdmUsIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSwgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFRvZ2dsZURpcmVjdGl2ZSwgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlLCBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtJZ3hOYXZpZ2F0aW9uU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlTW9kdWxlIHsgfVxuIl19